{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quarkus","text":""},{"location":"#course-objective","title":"Course objective","text":"<ul> <li>Discover and use microservices with quarkus</li> <li>Use JPA with databases</li> <li>Use state-of-the-art architecture and most used technologies </li> </ul>"},{"location":"#definitions","title":"Definitions","text":""},{"location":"#microservices","title":"Microservices","text":"<p>Microservices are a software development technique \u2014 a variation of service-oriented architecture (SOA) \u2014 that structures an application as a set of loosely coupled services. Independent microservices communicate with each other using programming language-independent APIs. </p> <p>REST APIs are often used to connect each microservice to the others. A noticeable advantage is that during a critical microservice update, only the microservice containing this resource will be updated, the entire application remaining compatible with the modification, unlike the entire application in a classical architecture.</p>"},{"location":"#rest","title":"REST","text":"<p>REST (Representational State Transfer) is an architectural style for designing networked applications. It relies on a stateless, client-server communication protocol, most commonly HTTP.</p> <p>In REST architecture, resources are represented by URIs (Uniform Resource Identifiers), and interactions with these resources are performed using standard HTTP methods:</p> <ol> <li>GET: Retrieves a representation of a resource without altering its state.</li> <li>POST: Creates a new resource.</li> <li>PUT: Updates an existing resource or creates a new one if it doesn't exist.</li> <li>DELETE: Removes a resource.</li> <li>PATCH: Applies partial modifications to a resource.</li> <li>OPTIONS: Describes the communication options for the target resource.</li> <li>HEAD: Similar to GET, but retrieves only the headers for the resource without the body.</li> </ol> <p>These HTTP methods, combined with URIs, form the foundation of RESTful APIs, enabling clients to interact with resources over the web in a predictable and standardized manner.</p> <p>Example: Collection ressource like http://api.exemple.com/collection/</p> <p>Example Swagger</p> <p>Plus d'infos: HTTP, REST</p>"},{"location":"#why-quarkus","title":"Why Quarkus?","text":"<p>Quarkus is a Java framework designed for building Kubernetes-native, lightweight, and fast Java applications. It's particularly optimized for running Java in containerized environments and serverless architectures. Quarkus offers features like ahead-of-time compilation, low memory consumption, and fast startup times, making it suitable for microservices and cloud-native applications.</p> <p>Quarkus supports a variety of programming models and extensions, allowing developers to easily integrate with other technologies such as RESTful services, messaging systems, databases, and more. It's built to support popular Java standards like CDI (Contexts and Dependency Injection), JAX-RS (Java API for RESTful Web Services), and Hibernate ORM (Object-Relational Mapping).</p> <p>Studying Quarkus can offer several advantages compared to other Java frameworks. Here are some reasons why one might choose to study Quarkus:</p> <ol> <li> <p>Cloud-Native Focus: Quarkus is designed specifically for cloud-native applications. It's optimized for running Java workloads efficiently in containerized environments like Kubernetes and serverless platforms. This focus on cloud-native development aligns with modern software development trends.</p> </li> <li> <p>Fast Startup and Low Memory Consumption: Quarkus is known for its fast startup times and low memory usage. This is achieved through features like ahead-of-time (AOT) compilation, GraalVM compatibility, and optimized runtime behaviors. These characteristics make Quarkus suitable for microservices and serverless architectures where quick scaling and efficient resource utilization are critical.</p> </li> <li> <p>Developer Productivity: Quarkus aims to enhance developer productivity by providing a familiar development experience with support for popular Java standards like CDI, JAX-RS, and Hibernate ORM. Additionally, it offers a wide range of extensions for integrating with various technologies and frameworks, reducing the need for manual configuration and boilerplate code.</p> </li> <li> <p>Microservices and Reactive Programming: Quarkus supports reactive programming paradigms and is well-suited for building microservices architectures. It provides support for reactive streams and non-blocking I/O, enabling developers to build highly scalable and responsive applications.</p> </li> <li> <p>Integration with GraalVM: Quarkus can be compiled ahead-of-time using GraalVM, which allows developers to create native executables. These native executables have faster startup times and lower memory overhead compared to traditional Java applications running on a Java Virtual Machine (JVM). This capability makes Quarkus suitable for resource-constrained environments and environments where high performance is a priority.</p> </li> <li> <p>Vibrant Ecosystem and Community: Quarkus has gained significant traction within the Java community, leading to a vibrant ecosystem of extensions, libraries, and community support. This active community contributes to the continuous improvement and evolution of the framework, providing developers with access to a wealth of resources and expertise.</p> </li> </ol> <p>In summary, studying Quarkus can provide valuable insights and skills for developing modern, cloud-native Java applications with a focus on performance, scalability, and developer productivity. Its advantages in terms of cloud-native optimization, fast startup times, low resource consumption, and extensive ecosystem make it a compelling choice for Java developers looking to stay ahead in the rapidly evolving landscape of software development.</p> <p>Performances:</p> <p></p> <p>Downsides of Quarkus:</p> <ol> <li> <p>Learning Curve: Quarkus introduces new concepts and optimizations, leading to a steep learning curve for developers unfamiliar with cloud-native environments and GraalVM. Reactive programming must be used for specific applications.</p> </li> <li> <p>Compatibility Challenges: While Quarkus aims for compatibility with existing Java standards and libraries, compatibility challenges may arise, particularly with libraries relying on reflection or dynamic class loading.</p> </li> <li> <p>Complexity of Native Compilation: While native compilation with GraalVM offers performance benefits, it introduces complexities such as dependency management, reflection usage, and platform-specific nuances.</p> </li> </ol> <p>Conclusion</p> <p>There are lots more advantages than downsides. Moreover, there is no need to use Native compilation.</p> <p>In addition, Quarkus as a few other frameworks implements the Eclipse Microprofile specification which is a subset of the JEE specification tailored for cloud native application.</p> <p>Like legacy JEE frameworks, you can switch with almost no effort to another Microprofile implementation.</p>"},{"location":"#quarkus-web-configuration-tool","title":"Quarkus web configuration tool","text":"<p>The site code.quarkus.io allows you to generate all the project dependencies and create the skeleton of the application.</p> <p></p>"},{"location":"#hello-rest-world","title":"Hello REST World","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>java 21 Mandrel </li> <li>java 21 Mandrel Windows</li> <li>java 21 Mandrel Linux</li> <li>maven 3.9.6</li> <li>docker</li> <li>IntelliJ (recommended) or VsCode</li> <li>Git</li> </ul>"},{"location":"#under-linux","title":"Under linux","text":"<pre><code>sudo apt install g++ zlib1g-dev libfreetype6-dev\nmkdir ~/maven\ncd ~/maven\nwget https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.zip\nunzip apache-maven-3.9.6-bin.zip\nmkdir ~/Mandrel\ncd ~/Mandrel\nwget https://github.com/graalvm/mandrel/releases/download/mandrel-24.0.0.0-Final/mandrel-java22-linux-amd64-24.0.0.0-Final.tar.gz\ntar xf mandrel-java22-linux-amd64-24.0.0.0-Final.tar.gz\n# Dans bashrc / zshrc\nexport M2_HOME=\"~/maven/apache-maven-3.9.6-bin\"\nexport JAVA_HOME=\"~/Mandrel/mandrel-java21-24.0.0.0-Final\"\nexport GRAALVM_HOME=\"${JAVA_HOME}\"\nexport PATH=\"${JAVA_HOME}/bin:${M2_HOME}/bin:${PATH}\"\nalias quarkus=\"mvn  -DquarkusRegistryClient=false\"\n# fin\nmvn io.quarkus.platform:quarkus-maven-plugin:3.8.3:create  -DprojectGroupId=my-groupId -DprojectArtifactId=my-artifactId\ncd my-artifactId\nquarkus quarkus:add-extension -Dextensions='quarkus-resteasy-reactive'\nmvn package -Pnative\n./target/*-runner\n</code></pre>"},{"location":"#under-windows","title":"Under windows","text":"<pre><code>powershell -c \"Invoke-WebRequest -OutFile quarkus.zip -Uri https://code.quarkus.io/d?e=io.quarkus:quarkus-resteasy\"\npowershell -c \"Expand-Archive -Path quarkus.zip -DestinationPath . -Force\"\ncd code-with-quarkus\nmvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:jdk-22\ndocker build -f src/main/docker/Dockerfile.native -t my-quarkus-mandrel-app .\ndocker run -i --rm -p 8080:8080 my-quarkus-mandrel-app\n</code></pre>"},{"location":"#docker-or-podman","title":"Docker or Podman","text":"<p>Docker is a set of utilities that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their software, libraries, and configuration files; they can communicate with each other through well-defined channels.</p>"},{"location":"#installing-docker","title":"Installing Docker","text":"<p>Quarkus uses Testcontainers, and therefore also Docker, to ease the management of different technical services (database, monitoring\u2026) during development. Our workshop also uses Docker to manage these services in a production-style deployment. So for this, we need to install <code>docker</code> and <code>docker compose</code> Installation instructions are available on the following page:</p> <ul> <li>Windows - https://docs.docker.com/docker-for-windows/install/ (version 20+)</li> </ul> If you do not have a Docker licence, you might prefer <code>podman</code> (https://podman.io/) instead of <code>docker</code>. To install <code>podman</code> and <code>podman-compose</code> please follow the instructions at https://quarkus.io/guides/podman. Do not forget the extra steps to configure the testcontainers library. As a convenience you can even alias <code>docker</code> to <code>podman</code>."},{"location":"#checking-for-docker-installation","title":"Checking for Docker Installation","text":"<p>Once installed, check that both <code>docker</code> and <code>docker compose</code> are available in your <code>PATH</code>. For that, execute the following commands:</p> <p>You should see something like this:</p> <pre><code>Docker version 20.10.8, build 3967b7d\nCloud integration: v1.0.24\nVersion:           20.10.14\nAPI version:       1.41\n</code></pre> <p>Then, check the Docker Compose version:</p> <p>Docker compose being a separate utility, you should get a different version than Docker itself:</p> <pre><code>Docker Compose version v2.5.0\n</code></pre> <p>Finally, run your first container as follows:</p> <p>For the first time, this will download the <code>hello-world</code> image from the Docker Hub and run it. You should get something like this:</p> <pre><code>Hello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n1. The Docker client contacted the Docker daemon.\n2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n(amd64)\n3. The Docker daemon created a new container from that image which runs the\nexecutable that produces the output you are currently reading.\n4. The Docker daemon streamed that output to the Docker client, which sent it\nto your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n$ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>"},{"location":"#some-docker-commands","title":"Some Docker Commands","text":"<p>Docker is a command-line utility where you can use several parameters and options to start/stop a container. You invoke <code>docker</code> with zero, one, or several command-line options with the container or image ID you want to work with. Docker comes with several options that are described in the documentation if you need more help To get some help on the commands and options, you can type, use the following command:</p> <pre><code>$ docker help\n\nUsage:  docker [OPTIONS] COMMAND\n\n$ docker help attach\n\nUsage:  docker attach [OPTIONS] CONTAINER\n\nAttach local standard input, output, and error streams to a running container\n</code></pre> <p>Here are some commands that you will be using to start/stop containers in this workshop.</p> <ul> <li> <p><code>docker container ls</code>: Lists containers.</p> </li> <li> <p><code>docker container start CONTAINER</code>: Starts one or more stopped containers.</p> </li> <li> <p><code>docker compose -f docker-compose.yaml up -d</code>: Starts all containers defined in a Docker Compose file.</p> </li> <li> <p><code>docker compose -f docker-compose.yaml down</code>: Stops all containers defined in a Docker Compose file.</p> </li> </ul>"},{"location":"#build-file","title":"Build file","text":"pom.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;groupId&gt;org.acme&lt;/groupId&gt;\n  &lt;artifactId&gt;code-with-quarkus&lt;/artifactId&gt;\n  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n\n  &lt;properties&gt;\n    &lt;compiler-plugin.version&gt;3.12.1&lt;/compiler-plugin.version&gt;\n    &lt;maven.compiler.release&gt;21&lt;/maven.compiler.release&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n    &lt;quarkus.platform.artifact-id&gt;quarkus-bom&lt;/quarkus.platform.artifact-id&gt;\n    &lt;quarkus.platform.group-id&gt;io.quarkus.platform&lt;/quarkus.platform.group-id&gt;\n    &lt;quarkus.platform.version&gt;3.9.1&lt;/quarkus.platform.version&gt;\n    &lt;skipITs&gt;true&lt;/skipITs&gt;\n    &lt;surefire-plugin.version&gt;3.2.5&lt;/surefire-plugin.version&gt;\n  &lt;/properties&gt;\n\n  &lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;${quarkus.platform.group-id}&lt;/groupId&gt;\n        &lt;artifactId&gt;${quarkus.platform.artifact-id}&lt;/artifactId&gt;\n        &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n        &lt;scope&gt;import&lt;/scope&gt;\n      &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n  &lt;/dependencyManagement&gt;\n\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-rest&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;\n      &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;${quarkus.platform.group-id}&lt;/groupId&gt;\n        &lt;artifactId&gt;quarkus-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;\n        &lt;extensions&gt;true&lt;/extensions&gt;\n        &lt;executions&gt;\n          &lt;execution&gt;\n            &lt;goals&gt;\n              &lt;goal&gt;build&lt;/goal&gt;\n              &lt;goal&gt;generate-code&lt;/goal&gt;\n              &lt;goal&gt;generate-code-tests&lt;/goal&gt;\n            &lt;/goals&gt;\n          &lt;/execution&gt;\n        &lt;/executions&gt;\n      &lt;/plugin&gt;\n      &lt;plugin&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${compiler-plugin.version}&lt;/version&gt;\n        &lt;configuration&gt;\n          &lt;compilerArgs&gt;\n            &lt;arg&gt;-parameters&lt;/arg&gt;\n          &lt;/compilerArgs&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n      &lt;plugin&gt;\n        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${surefire-plugin.version}&lt;/version&gt;\n        &lt;configuration&gt;\n          &lt;systemPropertyVariables&gt;\n            &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;\n            &lt;maven.home&gt;${maven.home}&lt;/maven.home&gt;\n          &lt;/systemPropertyVariables&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n      &lt;plugin&gt;\n        &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${surefire-plugin.version}&lt;/version&gt;\n        &lt;executions&gt;\n          &lt;execution&gt;\n            &lt;goals&gt;\n              &lt;goal&gt;integration-test&lt;/goal&gt;\n              &lt;goal&gt;verify&lt;/goal&gt;\n            &lt;/goals&gt;\n          &lt;/execution&gt;\n        &lt;/executions&gt;\n        &lt;configuration&gt;\n          &lt;systemPropertyVariables&gt;\n            &lt;native.image.path&gt;${project.build.directory}/${project.build.finalName}-runner&lt;/native.image.path&gt;\n            &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;\n            &lt;maven.home&gt;${maven.home}&lt;/maven.home&gt;\n          &lt;/systemPropertyVariables&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n\n  &lt;profiles&gt;\n    &lt;profile&gt;\n      &lt;id&gt;native&lt;/id&gt;\n      &lt;activation&gt;\n        &lt;property&gt;\n          &lt;name&gt;native&lt;/name&gt;\n        &lt;/property&gt;\n      &lt;/activation&gt;\n      &lt;properties&gt;\n        &lt;skipITs&gt;false&lt;/skipITs&gt;\n        &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;\n      &lt;/properties&gt;\n    &lt;/profile&gt;\n  &lt;/profiles&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"#hello-code","title":"Hello Code","text":"src/main/java/org/acme/GreatingResource.java<pre><code>package org.acme;\n\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\n\n@Path(\"/hello\")\npublic class GreetingResource {\n\n  @GET\n  @Produces(MediaType.TEXT_PLAIN)\n  public String hello() {\n    return \"Hello from Quarkus REST\";\n  }\n}\n</code></pre> <p>No main method is required, although it is possible to have it.</p> <p>Here the <code>@Path(\"/hello\")</code> instanciate the class and create a GET (With <code>@GET</code>) REST endpoint <code>/hello</code> producing text (<code>@Produces(MediaType.TEXT_PLAIN)</code>) which is bound to the <code>hello()</code> method</p>"},{"location":"#launching","title":"Launching","text":"<p>Many ways:</p> <ul> <li>With IDE Run asQuarkus Application</li> <li>With maven <code>mvn quarkus:dev</code></li> <li>Launching the generated jar: <code>java -jar target/quarkus-app/*.jar</code></li> </ul>"},{"location":"#manual-tests","title":"Manual tests","text":"<p><code>curl localhost:8080</code></p> <p>or with the browser:</p> <p><code>firefox http://localhost:8080</code></p> <p>8080 is the default Quarkus server port, change it with (for example) <code>quarkus.http.port=8081</code> in <code>src/main/resource/application.properties</code></p>"},{"location":"#junit-tests","title":"Junit Tests","text":"<pre><code>package org.acme;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport org.junit.jupiter.api.Test;\n\nimport static io.restassured.RestAssured.given;\nimport static org.hamcrest.CoreMatchers.is;\n\n@QuarkusTest\nclass ExampleResourceTest {\n  @Test\n  void testHelloEndpoint() {\n    given()\n            .when().get(\"/hello\")\n            .then()\n            .statusCode(200)\n            .body(is(\"Hello from Quarkus REST\"));\n  }\n\n}\n</code></pre>"},{"location":"#concepts","title":"Concepts","text":""},{"location":"#dev-mode","title":"Dev mode","text":"<p>Official Guide</p> <ul> <li>Offer a web UI to help the developer under <code>/q/dev</code> of your url.</li> <li>Live reload of the application when a Rest call is made.</li> <li>And many others: Swagger UI, Database imports, documentation, ...</li> </ul>"},{"location":"#configuration-profil","title":"Configuration / Profil","text":"<p>Official Guide</p> <p>We often need to configure our application differently depending on the target environment. For example, the local development environment may be different from the production environment.</p> <p>Configuration Profiles allow for multiple configurations in the same file or separate files and select between them via a profile name.</p>"},{"location":"#default-profiles","title":"Default Profiles","text":"<p>By default, Quarkus provides three profiles that activate automatically in certain conditions:</p> <ul> <li> <p>dev - Activated when in development mode (i.e. quarkus:dev)</p> </li> <li> <p>test - Activated when running tests</p> </li> <li> <p>prod - The default profile when not running in development or test mode</p> </li> </ul> <p>Example: <pre><code>bar=\u201dhello\u201d\nbaz=\u201dbonjour\u201d\n%dev.bar=\u201dhallo\u201d\n%prod.baz=\"Hej\"\n</code></pre></p>"},{"location":"#injecting-configuration","title":"Injecting configuration","text":"<pre><code>@ConfigProperty(name = \"greeting.message\") \nString message;\n</code></pre>"},{"location":"#cdi","title":"CDI","text":"<p>Official Guide</p> <pre><code>@ApplicationScoped //new Instance of the class\npublic class CounterBean {\n\n    @Inject //  A package-private injection field\n    CounterService counterService; \n\n    void onMessage(@Observes Event msg) { //A package-private observer method. \n    }\n}\n</code></pre>"},{"location":"#references","title":"References","text":"<p>infoq.com/articles/microservicilities-quarkus/</p>"},{"location":"Super-Heroes-Workshop/","title":"Workshop","text":""},{"location":"Super-Heroes-Workshop/#welcome","title":"Welcome","text":"<p>Let\u2019s start from the beginning. Quarkus. What\u2019s Quarkus? That\u2019s a pretty good question and probably a good start. If you go to the Quarkus web site, you\u2019ll read that Quarkus is \"A Kubernetes Native Java stack tailored for OpenJDK HotSpot &amp; GraalVM, crafted from the best of breed Java libraries and standards.\" This description is somewhat unclear but does an outstanding job at using bankable keywords. It\u2019s also written: \"Supersonic Subatomic Java.\" This is a way of saying that Quarkus is really fast, and it\u2019s really light. But what does Quarkus do?</p> <p>In practice, Quarkus is a stack to develop distributed systems and modern applications in Java, Kotlin, or Scala. Quarkus applications are tailored for the Cloud, containers, and Kubernetes. That does not mean you can\u2019t use Quarkus in other environments, there are no limits, but the principles infused in Quarkus have made containerization of applications more efficient. In this workshop, we will explain what Quarkus is and because the best way to understand Quarkus is to use it, build a set of microservices with it. Again, Quarkus is not limited to microservices, but it\u2019s a generally well-understood type of architecture.</p> <p>This workshop offers attendees an intro-level, hands-on session with Quarkus, from the first line of code to making services, to consuming them, and finally to assembling everything in a consistent system. But, what are we going to build? Well, it\u2019s going to be a set of microservices:</p> <ul> <li> <p>Using Quarkus</p> </li> <li> <p>Using blocking and non-blocking HTTP invocations</p> </li> <li> <p>With some parts of the dark side of microservices (resilience, health, etc)</p> </li> <li> <p>Use an event-based architecture using Apache Kafka</p> </li> <li> <p>Use OpenAI to introduce some artificial intelligence</p> </li> <li> <p>Answer the ultimate question: are super-heroes stronger than super-villains?</p> </li> </ul> <p>This workshop is a BYOL (Bring Your Own Laptop) session, so bring your Windows, OSX, or Linux laptop. You just need JDK 21 on your machine and Docker (having Apache Maven 3.9.x installed is optional as you will rely on the Apache Maven Wrapper). On Mac and Windows, Docker for x is recommended instead of the Docker toolbox setup. On Windows it is also recommended to have WSL (Windows Subsystem for Linux) installed.</p> <p>What you are going to learn:</p> <ul> <li> <p>What is Quarkus, and how you can use it</p> </li> <li> <p>How to build an HTTP endpoint (REST API) with Quarkus</p> </li> <li> <p>How to access a relational database</p> </li> <li> <p>How you can use Swagger and OpenAPI</p> </li> <li> <p>How you test your microservice</p> </li> <li> <p>How to build a reactive microservice, including reactive data access</p> </li> <li> <p>How you improve the resilience of your service</p> </li> <li> <p>How to invoke OpenAI/Azure OpenAI APIs using Semantic Kernel</p> </li> <li> <p>How to build event-driven microservices with Kafka</p> </li> <li> <p>How to build use contract testing so we are sure our microservices are fully functional</p> </li> <li> <p>How to build native executable</p> </li> <li> <p>How to containerize our microservices</p> </li> <li> <p>How to deploy the microservices to Kubernetes</p> </li> <li> <p>And much more!</p> </li> </ul>"},{"location":"Super-Heroes-Workshop/#presenting-the-workshop","title":"Presenting the Workshop","text":"<p>This workshop should give you a practical introduction to Quarkus. You will practice all the needed tools to develop an entire microservice architecture, mixing classical HTTP, reactive and event-based microservices. You will finish by extending the capabilities of Quarkus and learn more about the ability to create native executables.</p> <p>The idea is that you leave this workshop with a good understanding of what Quarkus is, what it is not, and how it can help you in your projects. Then, you\u2019ll be prepared to investigate a bit more and, hopefully, contribute.</p>"},{"location":"Super-Heroes-Workshop/#what-will-you-be-developing","title":"What Will You Be Developing?","text":"<p>In this workshop, you will develop an application that allows superheroes to fight against supervillains. You will be developing several microservices communicating with each other:</p> <ul> <li> <p>Super Hero UI: a React application to pick up a random superhero, a random supervillain, and makes them fight. The Super Hero UI is exposed via Quarkus and invokes the Fight REST API</p> </li> <li> <p>Villain REST API: A classical HTTP microservice exposing CRUD operations on Villains, stored in a PostgreSQL database</p> </li> <li> <p>Hero REST API: A reactive HTTP microservice exposing CRUD operations on Heroes, stored in a Postgres database</p> </li> <li> <p>Narration REST API: This microservice talks to OpenAI/Azure OpenAI to generate a random narration of the fight.</p> </li> <li> <p>Fight REST API: This REST API invokes the Hero and Villain APIs to get a random superhero and supervillain. It also invokes the Narration API to get a random narration of the fight. Each fight is, then, stored in a PostgreSQL database. This microservice can be developed using both the classical (imperative) or reactive approach. Invocations to the other microservices are protected using resilience patterns (retry, timeout, circuit-breakers)</p> </li> <li> <p>Statistics: Each fight is asynchronously sent (via Kafka) to the Statistics microservice. It has an HTML + JQuery UI displaying all the statistics.</p> </li> </ul> <p></p> <p>The main UI allows you to pick up one random Hero and Villain by clicking on \"New Fighters.\" Then it\u2019s just a matter of clicking on \"Fight!\" to get them to fight. If you click on \"Narrate the Fight\", you will have some AI-generated text describing the fight. The table at the bottom shows the list of the previous fights.</p> <p></p> <p>The Statistics UI shows the number of fights per hero and villain.</p> <p></p>"},{"location":"Super-Heroes-Workshop/#how-does-this-workshop-work","title":"How Does This Workshop Work?","text":"<p>You have this material in your hands (either electronically or printed), and you can now follow it step by step. The structure of this workshop is as follows:</p> <ul> <li> <p>Installing all the needed tools: in this section, you will install all the tools and code to be able to develop, compile and execute our application</p> </li> <li> <p>Developing microservices with Quarkus: in this section, you will develop a microservice architecture by creating several Maven projects, write some Java code, add JPA entities, JAX-RS REST endpoints, write some tests, use a React web application, and all that on Quarkus</p> </li> <li> <p>Artificial Intelligence: in this section, you will use OpenAI or Azure OpenAI to invoke an AI so you can generate a random narration of the fight</p> </li> <li> <p>Event-driven and Reactive microservices: in this section, you will create a reactive microservice and an event-driven microservice using Kafka</p> </li> <li> <p>Build native executables: in this section, you will build native executables of all the microservices thanks to GraalVM</p> </li> <li> <p>Containers: in this section, you will create Docker images of all the microservices</p> </li> <li> <p>Cloud: once the microservices are all containerize, you can deploy them to Kubernetes</p> </li> </ul> <p>If you already have the tools installed, skip the Installing all the needed tools section and jump to the section Developing with Quarkus, and start hacking some code and add-ons. This \"\u00e0 la carte\" mode lets you make the most of this 6-hour long hands-on lab.</p>"},{"location":"Super-Heroes-Workshop/#what-do-you-have-to-do","title":"What Do You Have to Do?","text":"<p>This workshop should be as self-explanatory as possible. So your job is to follow the instructions by yourself, do what you are supposed to do, and do not hesitate to ask for any clarification or assistance; that\u2019s why the team is here.</p> <p>Oh, and be ready to have some fun!</p>"},{"location":"Super-Heroes-Workshop/#software-requirements","title":"Software Requirements","text":"<p>First of all, make sure you have a 64-bit computer with admin rights (so you can install all the needed tools) and at least 8Gb of RAM (as some tools need a few resources).</p> <p>This workshop will make use of the following software, tools, frameworks that you will need to install and know (more or less) how it works:</p> <ul> <li> <p>Any IDE you feel comfortable with (eg. Intellij IDEA, Eclipse IDE, VS Code..)</p> </li> <li> <p>JDK 21</p> </li> <li> <p>java 21 Mandrel</p> </li> <li> <p>Docker or Podman</p> </li> <li> <p>cURL (should already be installed in your OS) and <code>jq</code></p> </li> <li> <p>OpenAI or Azure OpenAI keys</p> </li> </ul> <p>The following section focuses on how to install and set up the needed software. You can skip the next section if you have already installed all the prerequisites.</p> <p>This workshop assumes a bash shell. If you run on Windows, in particular, adjust the commands accordingly or install WSL.</p>"},{"location":"Super-Heroes-Workshop/#installing-software","title":"Installing Software","text":""},{"location":"Super-Heroes-Workshop/#jdk-21","title":"JDK 21","text":"<p>Essential for the development and execution of this workshop is the Java Development Kit (JDK) The JDK includes several tools such as a compiler (<code>javac</code>), a virtual machine, a documentation generator (`JavaDoc), monitoring tools (Visual VM) and so on. The code in this workshop uses JDK 21 (also compatible with Java 17.</p>"},{"location":"Super-Heroes-Workshop/#docker","title":"docker","text":"<p>Already done in index page.</p>"},{"location":"Super-Heroes-Workshop/#jq","title":"jq","text":"<p>Very often, when using cURL to invoke a RESTful web service, we get some JSON payload. cURL does not format this JSON so that you will get a flat String such as:</p> <pre><code>curl http://localhost:8083/api/heroes\n[{\"id\":\"1\",\"name\":\"Chewbacca\",\"level\":\"14\"},{\"id\":\"2\",\"name\":\"Wonder Woman\",\"level\":\"15\"},{\"id\":\"3\",\"name\":\"Anakin Skywalker\",\"level\":\"8\"}]\n</code></pre> <p>But what we want is to format the JSON payload, so it is easier to read. For that, there is a neat utility tool called <code>jq</code> that we could use. <code>jq</code> is a tool for processing JSON inputs, applying the given filter to its JSON text inputs, and producing the filter\u2019s results as JSON on standard output</p>"},{"location":"Super-Heroes-Workshop/#installing-jq","title":"Installing jq","text":""},{"location":"Super-Heroes-Workshop/#checking-for-jq-installation","title":"Checking for jq Installation","text":"<p>Once installed, it\u2019s just a matter of piping the cURL output to jq like this:</p> <pre><code>curl http://localhost:8083/api/heroes | jq\n\n[\n  {\n    \"id\": \"1\",\n    \"name\": \"Chewbacca\",\n    \"lastName\": \"14\"\n  },\n  {\n    \"id\": \"2\",\n    \"name\": \"Wonder Woman\",\n    \"lastName\": \"15\"\n  },\n  {\n    \"id\": \"3\",\n    \"name\": \"Anakin Skywalker\",\n    \"lastName\": \"8\"\n  }\n]\n</code></pre>"},{"location":"Super-Heroes-Workshop/#openai-or-azure-openai-subscriptions","title":"OpenAI or Azure OpenAI Subscriptions","text":"<p>The Narration microservice needs to access an AI service to generate the text narrating the fight. You can choose between OpenAI or Azure OpenAI. Azure OpenAI, or \"OpenAI on Azure\" is a service that provides REST API access to OpenAI\u2019s models, including the GPT-4, GPT-3, Codex and Embeddings series. The difference between OpenAI and Azure OpenAI is that it runs on Azure global infrastructure, which meets your production needs for critical enterprise security, compliance, and regional availability.</p>"},{"location":"Super-Heroes-Workshop/#openai","title":"OpenAI","text":"<p>OpenAI is a leading artificial intelligence research organization creating cutting-edge AI technologies. OpenAI offers a range of APIs that enable developers to integrate AI capabilities into their applications. Some of these APIs include:</p> <ul> <li> <p>GPT API: This API provides access to the GPT-3 and 4 language model</p> </li> <li> <p>Codex API: This API provides access to the Codex model, which is a language model trained on a dataset of public code</p> </li> <li> <p>DALL-E API: This API provides access to the DALL-E model, which is a language model trained on a dataset of text-image pairs</p> </li> </ul> <p>We will be using the GPT-3 API to generate the text narrating the fight.</p> <p>First, you need to have an OpenAI subscription and then generate an API key. Then you need to ge the organisation id and key to invoke the API. To get the organisation id, go to OpenAI organisation settings and copy the organisation id.:</p> <p></p> <p>Then, to get the API key, go to OpenAI API keys and copy the API key:</p> <p></p> <p></p>"},{"location":"Super-Heroes-Workshop/#azure-openai","title":"Azure OpenAI","text":"<p>If you already have an Azure subscription, you can use it to create an Azure OpenAI resource. Otherwise, you can create a free Azure subscription and use it to create an Azure OpenAI resource. Then, you need to use the Azure OpenAI service to generate the API key and endpoint URL. You can either do that using the Azure Portal or the Azure CLI.</p> <p>The easiest being use the Azure CLI, we recommend that you install it and use it to create the Azure OpenAI resource and generate the API key and endpoint URL. Once Azure CLI is installed and you have your Azure subscription, sign in to your Azure account:</p> <p>If you have several Azure subscription, make sure you are using the right one. For that, you can execute the following command to list all your subscriptions and set the one you want to use:</p><pre><code>az account list --output table\naz account set --subscription \naz account show\n\n<p>Then, execute the following command to create the Azure OpenAI resources:</p>\n<pre><code>echo \"Setting up environment variables...\"\necho \"----------------------------------\"\nPROJECT=\"&lt;give-your-project-a-name&gt;\"\nRESOURCE_GROUP=\"rg-$PROJECT\"\nLOCATION=\"eastus\"\nTAG=\"$PROJECT\"\nCOGNITIVE_SERVICE=\"cognit-$PROJECT\"\nCOGNITIVE_DEPLOYMENT=\"gpt35turbo\"\n\necho \"Creating the resource group...\"\necho \"------------------------------\"\naz group create \\\n  --name \"$RESOURCE_GROUP\" \\\n  --location \"$LOCATION\" \\\n  --tags system=\"$TAG\"\n\n\necho \"Creating the Cognitive Service...\"\necho \"---------------------------------\"\naz cognitiveservices account create \\\n  --name \"$COGNITIVE_SERVICE\" \\\n  --resource-group \"$RESOURCE_GROUP\" \\\n  --location \"$LOCATION\" \\\n  --custom-domain \"$COGNITIVE_SERVICE\" \\\n  --tags system=\"$TAG\" \\\n  --kind \"OpenAI\" \\\n  --sku \"S0\"\n\n\necho \"Deploying the model...\"\necho \"----------------------\"\naz cognitiveservices account deployment create \\\n  --name \"$COGNITIVE_SERVICE\" \\\n  --resource-group \"$RESOURCE_GROUP\" \\\n  --deployment-name \"$COGNITIVE_DEPLOYMENT\" \\\n  --model-name \"gpt-35-turbo\" \\\n  --model-version \"0301\"  \\\n  --model-format \"OpenAI\" \\\n  --sku-capacity 1 \\\n  --sku-name \"Standard\"\n</code></pre>\n<p>This script will create the Azure OpenAI resource and deploy the model. Once the script has executed, you can use the following command to get the API key and endpoint URL. You will need these properties later one when you will configure the Narration microservice:</p>\n<pre><code>echo \"Storing the key and endpoint in environment variables...\"\necho \"--------------------------------------------------------\"\nAZUREOPENAI_KEY=$(\n  az cognitiveservices account keys list \\\n    --name \"$COGNITIVE_SERVICE\" \\\n    --resource-group \"$RESOURCE_GROUP\" \\\n    | jq -r .key1\n)\nAZUREOPENAI_ENDPOINT=$(\n  az cognitiveservices account show \\\n    --name \"$COGNITIVE_SERVICE\" \\\n    --resource-group \"$RESOURCE_GROUP\" \\\n    | jq -r .properties.endpoint\n)\n\n# Set the properties\necho \"--------------------------------------------------\"\necho \"The following properties can be copied to either the rest-narration/src/main/resources/conf.properties or to the ~/.sk/conf.properties file:\"\necho \"--------------------------------------------------\"\necho \"client.azureopenai.key=$AZUREOPENAI_KEY\"\necho \"client.azureopenai.endpoint=$AZUREOPENAI_ENDPOINT\"\necho \"client.azureopenai.deploymentname=$COGNITIVE_DEPLOYMENT\"\n</code></pre>\n<p>Once you\u2019ve finished the workshop, remember to delete the Azure OpenAI resources to avoid being charged for it:</p>\n<pre><code># Clean up\naz group delete \\\n  --name \"$RESOURCE_GROUP\" \\\n  --yes\n\naz cognitiveservices account purge \\\n  --name \"$COGNITIVE_SERVICE\" \\\n  --resource-group \"$RESOURCE_GROUP\" \\\n  --location \"$LOCATION\"\n\naz cognitiveservices account delete \\\n  --name \"$COGNITIVE_SERVICE\" \\\n  --resource-group \"$RESOURCE_GROUP\"\n</code></pre>"},{"location":"Super-Heroes-Workshop/#wsl","title":"WSL","text":"<p>Windows Subsystem for Linux (WSL) lets developers run a GNU/Linux environment\u2009\u2014\u2009including most command-line tools, utilities, and applications\u2009\u2014\u2009directly on Windows, unmodified, without the overhead of a traditional virtual machine or dual-boot setup.</p>\n<p>If you are using Windows, it is recommended to install WSL as all the commands use bash.</p>"},{"location":"Super-Heroes-Workshop/#installing-wsl","title":"Installing WSL","text":"<p>You can install everything you need to run Windows Subsystem for Linux (WSL) by entering this command in an administrator PowerShell or Windows Command Prompt and then restarting your machine:</p>\n<p>This command will enable the required optional components, download the latest Linux kernel, set WSL 2 as your default, and install a Linux distribution for you (Ubuntu by default).</p>\n<p>The first time you launch a newly installed Linux distribution, a console window will open and you\u2019ll be asked to wait for files to de-compress and be stored on your machine. All future launches should take less than a second.</p>"},{"location":"Super-Heroes-Workshop/#recap","title":"Recap","text":"<p>Before going further, make sure the following commands work on your machine.</p>\n<pre><code>java -version\n$GRAALVM_HOME/bin/native-image --version\ncurl --version\ndocker version\ndocker compose version\n</code></pre>\n<p>We have not mentioned cURL up to now, because most modern operating systems ship with it pre-installed.</p>\n<p>And also make sure to have your OpenAI or Azure credentials ready if you want to develop the \"Narration\" microservice.</p>"},{"location":"Super-Heroes-Workshop/#preparing-for-the-workshop","title":"Preparing for the Workshop","text":"<p>In this workshop, you will be developing an application dealing with Super Heroes (and Super-Villains \ud83e\uddb9) as well as Quarkus extensions. The code will be separated into two different directories:</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#download-the-workshop-scaffolding","title":"Download the workshop scaffolding","text":"<p>Clone or download the repository squeleton.</p>"},{"location":"Super-Heroes-Workshop/#super-heroes-application","title":"Super Heroes Application","text":"<p>Under the <code>super-heroes</code> directory you will find the entire Super Hero application spread throughout a set of subdirectories, each one containing a microservice or some tooling. The final structure will be the following (don\u2019t worry if you don\u2019t have all this yet, this is what we\u2019re aiming towards):</p>\n<p></p>\n<p>Most of these subdirectories are Maven projects and follow the Maven directory structure:</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#checking-ports","title":"Checking Ports","text":"<p>During this workshop, we will use several ports.</p>\n<p>Use <code>lsof</code> to make sure the following ports are free, so you don\u2019t run into any conflicts.</p>\n<pre><code>lsof -i tcp:8080    # UI\nlsof -i tcp:8082    # Fight REST API\nlsof -i tcp:8083    # Hero REST API\nlsof -i tcp:8084    # Villain REST API\nlsof -i tcp:8085    # Statistics REST API\nlsof -i tcp:8086    # Narration REST API\nlsof -i tcp:5432    # Postgres\nlsof -i tcp:2181    # Zookeeper\nlsof -i tcp:9092    # Kafka\n</code></pre>\n<p>For windows : <code>netstat -ano |findstr :8080</code></p>"},{"location":"Super-Heroes-Workshop/#ready","title":"Ready?","text":"<p>After the prerequisites have been installed and the environment has been checked, it\u2019s now time to write some code!</p>"},{"location":"Super-Heroes-Workshop/#creating-a-classical-resthttp-microservice","title":"Creating a classical REST/HTTP Microservice","text":"<p>At the heart of the Super-Hero application comes Villains! You can\u2019t have superheroes without super-villains.</p>\n<p>We need to expose a REST API allowing CRUD operations on villains. This microservice is, let\u2019s say, a classical REST microservice. It uses HTTP to expose a REST API and internally store data into a database. It\u2019s using the imperative development model.</p>\n<p>The fight microservice will use this service.</p>\n<p></p>\n<p>In the following sections, you learn:</p>\n<ul>\n<li>\n<p>How to create a new Quarkus application</p>\n</li>\n<li>\n<p>How to implement REST API using JAX-RS and the RESTEasy Reactive extensio</p>\n</li>\n<li>\n<p>How to compose your application using beans</p>\n</li>\n<li>\n<p>How to access your database using Hibernate ORM with Panache</p>\n</li>\n<li>\n<p>How to use transactions</p>\n</li>\n<li>\n<p>How to enable OpenAPI and Swagger-UI</p>\n</li>\n</ul>\nThis service is exposed on the port 8084.\n\n<p>But first, let\u2019s describe our service. The Super-Villains microservice manages villains with their names, powers, and so on. The REST API allows adding, removing, listing, and picking a random villain from the stored set. Nothing outstanding but a good first step to discover Quarkus.</p>"},{"location":"Super-Heroes-Workshop/#villain-microservice","title":"Villain Microservice","text":"<p>First thing first, we need a project. That\u2019s what you are going to see in this section.</p>"},{"location":"Super-Heroes-Workshop/#bootstrapping-the-villain-rest-endpoint","title":"Bootstrapping the Villain REST Endpoint","text":"<p>The easiest way to create a new Quarkus project is to use the Quarkus Maven plugin. Open a terminal and run the following command under the <code>quarkus-workshop-super-heroes/super-heroes</code> directory:</p>\n<pre><code>./mvnw io.quarkus:quarkus-maven-plugin:3.9.1:create -\"DplatformVersion=3.9.1\" -\"DprojectGroupId=io.quarkus.workshop.super-heroes\"   -\"DprojectArtifactId=rest-villains\" -DclassName=\"io.quarkus.workshop.superheroes.villain.VillainResource\" -Dpath=\"api/villains\"   -Dextensions=\"rest-jackson\"\n</code></pre>\n<p>Notice that we scaffold the project with a reactive implementation of RestEasy (<code>rest-jackson</code>). This is the recommended way to develop REST applications with Quarkus even if we use the imperative programming model in the Villain microservice.</p>\n\n<p>Remember that <code>mvnw</code> is the maven wrapper. It behaves like <code>mvn</code>, but allows a project\u2019s build dependencies to be encapsulated.</p>\n<p>The last line selects the extension we want to use. As a start, we only select <code>rest-jackson</code>, which will also import <code>rest</code>.</p>\n<p>If you want your IDE to manage this new Maven project, you can declare it in the parent POM (<code>quarkus-super-heroes/pom.xml</code>) by adding this new module in the <code>&lt;modules&gt;</code> section:</p>\n<pre><code>&lt;module&gt;super-heroes/rest-villains&lt;/module&gt;\n</code></pre>\n<p>Prefer a Web UI?</p><p>Instead of the Maven command, you can use https://code.quarkus.io and select the <code>rest-jackson</code> extension.</p>"},{"location":"Super-Heroes-Workshop/#directory-structure","title":"Directory Structure","text":"<p>Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts :</p>\n<p></p>\n<p>The Maven archetype generates the following <code>rest-villains</code> sub-directory:</p>\n<ul>\n<li>\n<p>The Maven structure with a <code>pom.xml</code></p>\n</li>\n<li>\n<p>An <code>io.quarkus.workshop.superheroes.villain.VillainResource</code> resource exposed on <code>/api/villains</code></p>\n</li>\n<li>\n<p>An associated unit test <code>VillainResourceTest</code></p>\n</li>\n<li>\n<p>The landing page <code>index.html</code> that is accessible on http://localhost:8080 after starting the application</p>\n</li>\n<li>\n<p>Example <code>Dockerfile</code> files for both native and JVM modes in <code>src/main/docker</code></p>\n</li>\n<li>\n<p>The <code>application.properties</code> configuration file</p>\n</li>\n</ul>\n<p>Once generated, look at the <code>pom.xml</code>. You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies. In addition, you can see the <code>quarkus-maven-plugin</code> responsible for the packaging of the application and providing the development mode.</p>\n<pre><code>&lt;project&gt;\n  &lt;!-- ... --&gt;\n  &lt;properties&gt;\n    &lt;compiler-plugin.version&gt;3.11.0&lt;/compiler-plugin.version&gt;\n    &lt;maven.compiler.release&gt;21&lt;/maven.compiler.release&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n    &lt;quarkus.platform.artifact-id&gt;quarkus-bom&lt;/quarkus.platform.artifact-id&gt;\n    &lt;quarkus.platform.group-id&gt;io.quarkus&lt;/quarkus.platform.group-id&gt;\n    &lt;quarkus.platform.version&gt;3.6.0&lt;/quarkus.platform.version&gt;\n    &lt;skipITs&gt;true&lt;/skipITs&gt;\n    &lt;surefire-plugin.version&gt;3.2.2&lt;/surefire-plugin.version&gt;\n  &lt;/properties&gt;\n  &lt;!-- ... --&gt;\n  &lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;${quarkus.platform.group-id}&lt;/groupId&gt;\n        &lt;artifactId&gt;${quarkus.platform.artifact-id}&lt;/artifactId&gt;\n        &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n        &lt;scope&gt;import&lt;/scope&gt;\n      &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n  &lt;/dependencyManagement&gt;\n  &lt;!-- ... --&gt;\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;${quarkus.platform.group-id}&lt;/groupId&gt;\n        &lt;artifactId&gt;quarkus-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;\n        &lt;extensions&gt;true&lt;/extensions&gt;\n        &lt;executions&gt;\n          &lt;execution&gt;\n            &lt;goals&gt;\n              &lt;goal&gt;build&lt;/goal&gt;\n              &lt;goal&gt;generate-code&lt;/goal&gt;\n              &lt;goal&gt;generate-code-tests&lt;/goal&gt;\n            &lt;/goals&gt;\n          &lt;/execution&gt;\n        &lt;/executions&gt;\n      &lt;/plugin&gt;\n     &lt;!-- ... --&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n&lt;!-- ... --&gt;\n&lt;/project&gt;\n</code></pre>\n<p>If we focus on the dependencies section, you can see the extensions allowing the development of REST applications (rest and rest-jackson)</p>\n<pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-rest&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-rest-jackson&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- ... --&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<ul>\n<li>\n<p><code>quarkus-arc</code> is the dependency injection framework integrated into Quarkus. It\u2019s designed to perform build-time injections. We will see later why this is essential for Quarkus.</p>\n</li>\n<li>\n<p><code>rest</code> is the framework we will use to implement our REST API. It uses JAX-RS annotations such as <code>@Path</code>, <code>@GET</code>\u2026</p>\n</li>\n<li>\n<p><code>rest-jackson</code> adds JSON object mapping capabilities to RESTEasy reactive.</p>\n</li>\n</ul>"},{"location":"Super-Heroes-Workshop/#the-villain-resource","title":"The Villain Resource","text":"<p>During the project creation, the <code>VillainResource.java</code> file has been created with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\n\n@Path(\"/api/villains\")\npublic class VillainResource {\n\n    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    public String hello() {\n        return \"Hello from RESTEasy Reactive\";\n    }\n}\n</code></pre>\n<p>It\u2019s a very simple REST endpoint returning a \"Hello World\" to requests on <code>/api/villains</code>. It uses JAX-RS annotations:</p>\n<ul>\n<li>\n<p><code>@Path</code> indicates the HTTP path handled by the resource,</p>\n</li>\n<li>\n<p><code>@GET</code> indicates that the method should be called when receiving a <code>GET</code> request on <code>/api/villains</code>.</p>\n</li>\n</ul>\nMethods can also have their own <code>@Path</code> annotation suffixed to the class one (if any)."},{"location":"Super-Heroes-Workshop/#running-the-application","title":"Running the Application","text":"<p>Now we are ready to run our application.</p>\n<p>Use: <code>./mvnw quarkus:dev</code> in the <code>rest-villains</code> directory:</p>\n<pre><code>$ ./mvnw quarkus:dev\n[INFO] Scanning for projects...\n[INFO]\n[INFO] -----------&lt; io.quarkus.workshop.super-heroes:rest-villains &gt;-----------\n[INFO] Building rest-villains 1.0.0-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- quarkus-maven-plugin:3.9.1:dev (default-cli) @ rest-villains ---\n[INFO] Invoking resources:3.6.0:resources (default-resources) @ rest-villains\n[INFO] Copying 2 resources from src/main/resources to target/classes\n[INFO] Invoking quarkus:3.6.0:generate-code (default) @ rest-villains\n[INFO] Invoking compiler:3.11.0:compile (default-compile) @ rest-villains\n[INFO] Nothing to compile - all classes are up to date\n[INFO] Invoking resources:3.6.0:testResources (default-testResources) @ rest-villains\n[INFO] skip non existing resourceDirectory /Users/agoncal/Documents/Code/Temp/quarkus-super-heroes/super-heroes/rest-villains/src/test/resources\n[INFO] Invoking quarkus:3.6.0:generate-code-tests (default) @ rest-villains\n[INFO] Invoking compiler:3.11.0:testCompile (default-testCompile) @ rest-villains\n[INFO] Nothing to compile - all classes are up to date\nListening for transport dt_socket at address: 5005\n\n__  ____  __  _____   ___  __ ____  ______\n --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\\n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n2022-11-15 14:05:29,414 INFO  [io.quarkus] (Quarkus Main Thread) rest-villains 1.0.0-SNAPSHOT on JVM (powered by Quarkus 3.9.1) started in 1.093s. Listening on: http://localhost:8080\n\n2022-11-15 14:05:29,423 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.\n2022-11-15 14:05:29,423 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, rest, rest-jackson, smallrye-context-propagation, vertx]\n\nTests paused\nPress [r] to resume testing, [o] Toggle test output, [:] for the terminal, [h] for more options&gt;\n</code></pre>\n<p>Then check that the endpoint returns <code>hello</code> as expected:</p>\n<pre><code>curl http://localhost:8080/api/villains\n</code></pre>\n<p>You should see the following</p>\n<pre><code>Hello from RESTEasy Reactive\n</code></pre>"},{"location":"Super-Heroes-Workshop/#development-mode","title":"Development Mode","text":"<p><code>quarkus:dev</code> runs Quarkus in development mode. It enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and invoke a REST endpoint (i.e., cURL command or refresh your browser), these changes will automatically take effect. It works too for resource files like the configuration property and HTML files. Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</p>\n<p>The development mode also allows debugging and listens for a debugger on port 5005. If you want to wait for the debugger to attach before running, you can pass <code>-Dsuspend=true</code> on the command line. If you don\u2019t want the debugger at all, you can use <code>-Ddebug=false</code>.</p>\n<p>Alright, time to change some code. Open your favorite IDE and import the project. To check that the hot reload is working, update the <code>VillainResource.hello()</code> method by returning the String \"Hello Villain Resource\".</p>\n<p>Now, execute the cURL command again:</p>\n<pre><code>curl http://localhost:8080/api/villains\n</code></pre>\n<p>The output has changed (\"Hello Villain Resource\") without you having to stop and restart Quarkus!</p>"},{"location":"Super-Heroes-Workshop/#testing-the-application","title":"Testing the Application","text":"<p>All right, so far, so good, but wouldn\u2019t it be better with a few tests, just in case.</p>\n<p>In the generated <code>pom.xml</code> file, you can see two test dependencies:</p>\n<pre><code>&lt;dependencies&gt;\n    &lt;!-- ... --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n        &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;\n        &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<p>So, we will use Junit 5 combined with RESTAssured, which eases the testing of REST applications.</p>\n<p>If you look at the <code>maven-surefire-plugin</code> configuration in the <code>pom.xml</code>, you will see that we set the <code>java.util.logging</code> system property to ensure tests will use the correct method log manager.</p>\n<pre><code>&lt;plugin&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;version&gt;${surefire-plugin.version}&lt;/version&gt;\n    &lt;configuration&gt;\n      &lt;systemPropertyVariables&gt;\n        &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;\n        &lt;maven.home&gt;${maven.home}&lt;/maven.home&gt;\n      &lt;/systemPropertyVariables&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>\n<p>The generated project contains a simple test in <code>VillainResourceTest.java</code>.</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport org.junit.jupiter.api.Test;\n\nimport static io.restassured.RestAssured.given;\nimport static org.hamcrest.CoreMatchers.is;\n\n@QuarkusTest\npublic class VillainResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n          .when().get(\"/api/villains\")\n          .then()\n             .statusCode(200)\n             .body(is(\"Hello from RESTEasy Reactive\"));\n    }\n\n}\n</code></pre>\n<p>By using the <code>QuarkusTest</code> runner, the <code>VillainResourceTest</code> class instructs JUnit to start the application before the tests. Then, the <code>testHelloEndpoint</code> method checks the HTTP response status code and content. Notice that these tests use RestAssured, but feel free to use your favorite library</p>\n<p>Quarkus provides a RestAssured integration that updates the default port used by RestAssured before the tests are run. So in your RestAssured tests, you don\u2019t have to specify the default test port 8081 used by Quarkus. You can also configure the ports used by tests by configuring the <code>quarkus.http.test-port</code> property in the application.properties.</p>\n\n<p>In the terminal running the application in dev mode (<code>./mvnw quarkus:dev</code>), you should see at the bottom:</p>\n<pre><code>Tests paused\nPress [r] to resume testing, [o] Toggle test output, [:] for the terminal, [h] for more options&gt;\n</code></pre>\n<p>Hit the <code>r</code> key, and watch Quarkus execute your tests automatically and even continuously. Unfortunately, this first run didn\u2019t end well:</p>\n<pre><code>2022-11-15 14:13:17,924 ERROR [io.qua.test] (Test runner thread) ==================== TEST REPORT #1 ====================\n2022-11-15 14:13:17,925 ERROR [io.qua.test] (Test runner thread) Test VillainResourceTest#testHelloEndpoint() failed\n: java.lang.AssertionError: 1 expectation failed.\nResponse body doesn't match expectation.\nExpected: is \"Hello from RESTEasy Reactive\"\n  Actual: Hello Villain Resource\n\n        at io.restassured.internal.ValidatableResponseImpl.body(ValidatableResponseImpl.groovy)\n        at io.quarkus.workshop.superheroes.villain.VillainResourceTest.testHelloEndpoint(VillainResourceTest.java:18)\n\n\n2022-11-15 14:13:17,927 ERROR [io.qua.test] (Test runner thread) &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Summary: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\nio.quarkus.workshop.superheroes.villain.VillainResourceTest#testHelloEndpoint(VillainResourceTest.java:18) VillainResourceTest#testHelloEndpoint() 1 expectation failed.\nResponse body doesn't match expectation.\nExpected: is \"Hello from RESTEasy Reactive\"\n  Actual: Hello Villain Resource\n\n2022-11-15 14:13:17,929 ERROR [io.qua.test] (Test runner thread) &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1 TEST FAILED &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n\n2022-11-15 14:13:18,155 ERROR [io.qua.test] (Test runner thread) ==================== TEST REPORT #2 ====================\n2022-11-15 14:13:18,155 ERROR [io.qua.test] (Test runner thread) Test VillainResourceTest#testHelloEndpoint() failed\n: java.lang.AssertionError: 1 expectation failed.\nResponse body doesn't match expectation.\nExpected: is \"Hello from RESTEasy Reactive\"\n  Actual: Hello Villain Resource\n\n        at io.restassured.internal.ValidatableResponseImpl.body(ValidatableResponseImpl.groovy)\n        at io.quarkus.workshop.superheroes.villain.VillainResourceTest.testHelloEndpoint(VillainResourceTest.java:18)\n\n\n2022-11-15 14:13:18,156 ERROR [io.qua.test] (Test runner thread) &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Summary: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\nio.quarkus.workshop.superheroes.villain.VillainResourceTest#testHelloEndpoint(VillainResourceTest.java:18) VillainResourceTest#testHelloEndpoint() 1 expectation failed.\nResponse body doesn't match expectation.\nExpected: is \"Hello from RESTEasy Reactive\"\n  Actual: Hello Villain Resource\n\n2022-11-15 14:13:18,157 ERROR [io.qua.test] (Test runner thread) &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1 TEST FAILED &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<p>It fails! It\u2019s expected, you changed the output of <code>VillainResource.hello()</code> earlier. Adjust the test body condition accordingly:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport org.junit.jupiter.api.Test;\n\nimport static io.restassured.RestAssured.given;\nimport static org.hamcrest.CoreMatchers.is;\n\n@QuarkusTest\npublic class VillainResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n          .when().get(\"/api/villains\")\n          .then()\n             .statusCode(200)\n             .body(is(\"Hello Villain Resource\"));\n    }\n\n}\n</code></pre>\n<p>Save the file, and watch the dev mode automatically rerunning your test (and passing)</p>\n<pre><code>--\n2022-11-15 14:15:22,997 INFO  [io.qua.test] (Test runner thread) All tests are now passing\n--\nAll 1 test is passing (0 skipped), 1 test was run in 186ms. Tests completed at 14:15:23.\nPress [r] to re-run, [o] Toggle test output, [:] for the terminal, [h] for more options&gt;\n</code></pre>\n<p>Continuous testing is a big part of Quarkus development. Quarkus detects and runs the tests for you.</p>\n<p>You can also run the tests from a terminal using:</p>"},{"location":"Super-Heroes-Workshop/#packaging-and-running-the-application","title":"Packaging and Running the Application","text":"<p>The application is packaged using the <code>./mvnw package</code> command (it also runs the tests). That command generates:</p>\n<ul>\n<li>\n<p><code>target/rest-villains-1.0.0-SNAPSHOT.jar</code>: containing just the classes and resources of the projects, it\u2019s the regular artifact produced by the Maven build (it is not an executable jar);</p>\n</li>\n<li>\n<p><code>target/quarkus-app/</code> : this directory uses the fast jar packaging. It contains an executable jar (<code>quarkus-run.jar</code>), and all the dependencies (structured into <code>app</code>, <code>lib</code> and <code>quarkus</code>).</p>\n</li>\n</ul>\n<p>This fast jar takes advantage of the build-time principle of Quarkus (we discuss it soon) to improve the application performances and which can be easily transposed to container layers.</p>\n<p>Stop the application running in dev mode (by hitting <code>q</code> or <code>CTRL+C</code>), and run the application using: <code>java -jar target/quarkus-app/quarkus-run.jar</code>.</p>\n<p>Before running the application, don\u2019t forget to stop the hot reload mode (hit CTRL+C), or you will have a port conflict.</p>\n\n<p>Troubleshooting</p><p>You might come across the following error while developing:</p><pre><code>WARN  [io.qu.ne.ru.NettyRecorder] (Thread-48) Localhost lookup took more than one second; you need to add a /etc/hosts entry to improve Quarkus startup time. See https://thoeni.io/post/macos-sierra-java/ for details.</code></pre><p>If this is the case, it\u2019s just a matter of adding the node name of your machine to the /etc/hosts. For that, first, get the name of your node with the following command:</p><p>Then <code>sudo vi /etc/hosts</code> so you have the right to edit the file and add the following entry:</p><pre><code>127.0.0.1 localhost my-node.local</code></pre>\n\n<p>In another terminal, check that the application runs using:</p>\n<pre><code>curl http://localhost:8080/api/villains\nHello Villain Resource\n</code></pre>"},{"location":"Super-Heroes-Workshop/#transactions-and-orm","title":"Transactions and ORM","text":"<p>The Villain API\u2019s role is to allow CRUD operations on Super Villains. In this module we will create a Villain entity and persist/update/delete/retrieve it from a PostgreSQL database in a transactional way.</p>\n<p>This microservice uses an imperative/classic execution model. Interactions with the database will uses Hibernate ORM and will block until the responses from the database are retrieved.</p>"},{"location":"Super-Heroes-Workshop/#directory-structure_1","title":"Directory Structure","text":"<p>In this module we will add extra classes to the Villain API project. You will end-up with the following directory structure:</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#installing-the-postgresql-dependency-hibernate-with-panache-and-hibernate-validator","title":"Installing the PostgreSQL Dependency, Hibernate with Panache and Hibernate Validator","text":"<p>This microservice:</p>\n<ul>\n<li>\n<p>Interacts with a PostgreSQL database - so it needs a driver</p>\n</li>\n<li>\n<p>Uses Hibernate with Panache - needs the extension providing it</p>\n</li>\n<li>\n<p>Validates payloads and entities - needs a validator</p>\n</li>\n<li>\n<p>Consumes and produces JSON - needs a JSON mapper</p>\n</li>\n</ul>\n<p>Hibernate ORM is the de-facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but it does not make simple and common mappings trivial. Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus</p>\n<p>Because JPA and Bean Validation work well together, we will use Bean Validation to constrain our business model.</p>\n<p>To add the required dependencies, just run the following command under the <code>super-heroes/rest-villains</code> directory:</p>\n<pre><code>./mvnw quarkus:add-extension -Dextensions=\"jdbc-postgresql,hibernate-orm-panache,hibernate-validator\"\n</code></pre>\nNo need to add an extension for JSON, we already included <code>rest-jackson</code>.\n\n<p>This will add the following dependencies in the <code>pom.xml</code> file:</p>\n<pre><code>&lt;dependencies&gt;\n    &lt;!-- ... --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n      &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- ... --&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<p>From now on, you can choose to either edit your pom directly or use the <code>quarkus:add-extension</code> command.</p>"},{"location":"Super-Heroes-Workshop/#villain-entity","title":"Villain Entity","text":"<p>To define a Panache entity, simply extend <code>PanacheEntity</code>, annotate it with <code>@Entity</code> and add your columns as public fields (no need to have getters and setters). The <code>Villain</code> entity should look like this:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport io.quarkus.hibernate.orm.panache.PanacheEntity;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\nimport java.util.Random;\n\n@Entity\npublic class Villain extends PanacheEntity {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    public String name;\n\n    public String otherName;\n\n    @NotNull\n    @Min(1)\n    public int level;\n\n    public String picture;\n\n    @Column(columnDefinition = \"TEXT\")\n    public String powers;\n\n\n    @Override\n    public String toString() {\n        return \"Villain{\" +\n            \"id=\" + id +\n            \", name='\" + name + '\\'' +\n            \", otherName='\" + otherName + '\\'' +\n            \", level=\" + level +\n            \", picture='\" + picture + '\\'' +\n            \", powers='\" + powers + '\\'' +\n            '}';\n    }\n}\n</code></pre>\n<p>Notice that you can put all your JPA column annotations and Bean Validation constraint annotations on the public fields.</p>"},{"location":"Super-Heroes-Workshop/#adding-operations","title":"Adding Operations","text":"<p>Thanks to Panache, once you have written the <code>Villain</code> entity, here are the most common operations you will be able to do:</p>\n<pre><code>// creating a villain\nVillain villain = new Villain();\nvillain.name = \"Lex Luthor\";\nvillain.level = 9;\n\n// persist it\nvillain.persist();\n\n// getting a list of all Villain entities\nList&lt;Villain&gt; villains = Villain.listAll();\n\n// finding a specific villain by ID\nvillain = Villain.findById(id);\n\n// counting all villains\nlong countAll = Villain.count();\n</code></pre>\n<p>But we are missing a business method: we need to return a random villain.</p>\n<p>For that it\u2019s just a matter to add the following method to our <code>Villain.java</code> entity:</p>\n<pre><code>public static Villain findRandom() {\n    long countVillains = count();\n    Random random = new Random();\n    int randomVillain = random.nextInt((int) countVillains);\n    return findAll().page(randomVillain, 1).firstResult();\n}\n</code></pre>\n<p>You would need to add the following import statement if not done automatically by your IDE <code>import java.util.Random;</code></p>\n\n<p>Picking a random villain is achieved as follows:</p>\n<ol>\n<li>\n<p>Gets the number of villains stored in the database (<code>count()</code>)</p>\n</li>\n<li>\n<p>Picks a random number between 0 and <code>count()</code></p>\n</li>\n<li>\n<p>Asks Hibernate with Panache to find all villains in a paginated way and return the random page containing 1 villain.</p>\n</li>\n</ol>"},{"location":"Super-Heroes-Workshop/#configuring-hibernate","title":"Configuring Hibernate","text":"<p>Quarkus development mode is really useful for applications that mix front end or services and database access. We use <code>quarkus.hibernate-orm.database.generation=drop-and-create</code> in conjunction with <code>import.sql</code> so every change to your app and in particular to your entities, the database schema will be properly recreated and your data (stored in <code>import.sql</code>) will be used to repopulate it from scratch. This is best to perfectly control your environment and works magic with Quarkus live reload mode: your entity changes or any change to your <code>import.sql</code> is immediately picked up and the schema updated without restarting the application!</p>\n<p>For that, make sure to have the following configuration in your <code>application.properties</code> (located in <code>src/main/resources</code>):</p>\n<pre><code># drop and create the database at startup (use `update` to only update the schema)\nquarkus.hibernate-orm.database.generation=drop-and-create\n</code></pre>"},{"location":"Super-Heroes-Workshop/#villain-service","title":"Villain Service","text":"<p>To manipulate the <code>Villain</code> entity we will develop a transactional <code>VillainService</code> class. The idea is to wrap methods modifying the database (e.g. <code>entity.persist()</code>) within a transaction. Marking a CDI bean method <code>@Transactional</code> will do that for you and make that method a transaction boundary.</p>\n<p><code>@Transactional</code> can be used to control transaction boundaries on any bean at the method level or at the class level to ensure every method is transactional. You can control whether and how the transaction is started with parameters on <code>@Transactional</code>:</p>\n<ul>\n<li>\n<p><code>@Transactional(REQUIRED)</code> (default): starts a transaction if none was started, stays with the existing one otherwise.</p>\n</li>\n<li>\n<p><code>@Transactional(REQUIRES_NEW)</code>: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</p>\n</li>\n<li>\n<p><code>@Transactional(MANDATORY)</code>: fails if no transaction was started ; works within the existing transaction otherwise.</p>\n</li>\n<li>\n<p><code>@Transactional(SUPPORTS)</code>: if a transaction was started, joins it ; otherwise works with no transaction.</p>\n</li>\n<li>\n<p><code>@Transactional(NOT_SUPPORTED)</code>: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.</p>\n</li>\n<li>\n<p><code>@Transactional(NEVER)</code>: if a transaction was started, raises an exception ; otherwise works with no transaction.</p>\n</li>\n</ul>\n<p>Creates a new <code>VillainService.java</code> file in the same package with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport static jakarta.transaction.Transactional.TxType.REQUIRED;\nimport static jakarta.transaction.Transactional.TxType.SUPPORTS;\n\nimport java.util.List;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.transaction.Transactional;\nimport jakarta.validation.Valid;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n\n@ApplicationScoped\n@Transactional(REQUIRED)\npublic class VillainService {\n\n\n    @Transactional(SUPPORTS)\n    public List&lt;Villain&gt; findAllVillains() {\n        return Villain.listAll();\n    }\n\n    @Transactional(SUPPORTS)\n    public Villain findVillainById(Long id) {\n        return Villain.findById(id);\n    }\n\n    @Transactional(SUPPORTS)\n    public Villain findRandomVillain() {\n        Villain randomVillain = null;\n        while (randomVillain == null) {\n            randomVillain = Villain.findRandom();\n        }\n        return randomVillain;\n    }\n\n    public Villain persistVillain(@Valid Villain villain) {\n        villain.persist();\n        return villain;\n    }\n\n    public Villain updateVillain(@Valid Villain villain) {\n        Villain entity = Villain.findById(villain.id);\n        entity.name = villain.name;\n        entity.otherName = villain.otherName;\n        entity.level = villain.level;\n        entity.picture = villain.picture;\n        entity.powers = villain.powers;\n        return entity;\n    }\n\n    public void deleteVillain(Long id) {\n        Villain villain = Villain.findById(id);\n        villain.delete();\n    }\n}\n</code></pre>\n<p>The <code>@ApplicationScoped</code> annotation declares a bean. The other component of the application can access this bean. Arc, the dependency injection framework integrated in Quarkus, handles the creation and the access to this class.</p>\n<p>Notice that both methods that persist and update a villain, pass a <code>Villain</code> object as a parameter. Thanks to the Bean Validation\u2019s <code>@Valid</code> annotation, the <code>Villain</code> object will be checked to see if it\u2019s valid or not. If it\u2019s not, the transaction will be rolled back.</p>"},{"location":"Super-Heroes-Workshop/#accessing-a-database-in-dev-mode","title":"Accessing a database in dev mode","text":"<p>Our project now requires a connection to a PostgreSQL database. In dev mode, no need to start a database or configure anything. Quarkus does that for us (just make sure you have Docker up and running).</p>\n<p>Start the application in dev mode with <code>./mvnw quarkus:dev</code>. In the log, you will see the following:</p>\n<pre><code>2021-09-21 15:58:44,640 INFO  [org.tes.doc.DockerClientProviderStrategy] (build-38) Loaded org.testcontainers.dockerclient.UnixSocketClientProviderStrategy from ~/.testcontainers.properties, will try it first\n2021-09-21 15:58:45,068 INFO  [org.tes.doc.DockerClientProviderStrategy] (build-38) Found Docker environment with local Unix socket (unix:///var/run/docker.sock)\n2021-09-21 15:58:45,070 INFO  [org.tes.DockerClientFactory] (build-38) Docker host IP address is localhost\n2021-09-21 15:58:45,116 INFO  [org.tes.DockerClientFactory] (build-38) Connected to docker:\n  Server Version: 20.10.8\n  API Version: 1.41\n  Operating System: Docker Desktop\n  Total Memory: 5943 MB\n2021-09-21 15:58:45,118 INFO  [org.tes.uti.ImageNameSubstitutor] (build-38) Image name substitution will be performed by: DefaultImageNameSubstitutor (composite of 'ConfigurationFileImageNameSubstitutor' and 'PrefixingImageNameSubstitutor')\n2021-09-21 15:58:45,453 INFO  [org.tes.uti.RegistryAuthLocator] (build-38) Credential helper/store (docker-credential-desktop) does not have credentials for index.docker.io\n2021-09-21 15:58:45,957 INFO  [org.tes.DockerClientFactory] (build-38) Ryuk started - will monitor and terminate Testcontainers containers on JVM exit\n2021-09-21 15:58:45,958 INFO  [org.tes.DockerClientFactory] (build-38) Checking the system...\n2021-09-21 15:58:45,958 INFO  [org.tes.DockerClientFactory] (build-38) \u2714\ufe0e Docker server version should be at least 1.6.0\n2021-09-21 15:58:46,083 INFO  [org.tes.DockerClientFactory] (build-38) \u2714\ufe0e Docker environment should have more than 2GB free disk space\n2021-09-21 15:58:46,143 INFO  [\ud83d\udc33 .2]] (build-38) Creating container for image: postgres:13.2\n2021-09-21 15:58:46,217 INFO  [\ud83d\udc33 .2]] (build-38) Starting container with ID: a7fd54795185ab17baf487388c1e3280fdfea3f6ef8670c0336d367dba3e1d9e\n2021-09-21 15:58:46,545 INFO  [\ud83d\udc33 .2]] (build-38) Container postgres:13.2 is starting: a7fd54795185ab17baf487388c1e3280fdfea3f6ef8670c0336d367dba3e1d9e\n2021-09-21 15:58:48,043 INFO  [\ud83d\udc33 .2]] (build-38) Container postgres:13.2 started in PT1.959377S\n\n2021-09-21 15:58:48,044 INFO  [io.qua.dev.pos.dep.PostgresqlDevServicesProcessor] (build-38) Dev Services for the default datasource (postgresql) started\n</code></pre>\n<p>Quarkus detects the need for a database and starts one using a Docker container. It automatically configures the application, which means we are good to go and implement our REST API.</p>\n<p>If the application fails to start properly and the logs contain something like</p><pre><code>WARN  [or.te.ut.RyukResourceReaper] (testcontainers-ryuk) Can not connect to Ryuk at localhost:49153: java.net.ConnectException: Connection refused (Connection refused)</code></pre><p>try launching the application again after having the <code>TESTCONTAINERS_RYUK_DISABLED</code> environment variable to <code>true</code>. This setting will likely also be needed throughout the workshop.</p>"},{"location":"Super-Heroes-Workshop/#villainresource-endpoint","title":"VillainResource Endpoint","text":"<p>The <code>VillainResource</code> was bootstrapped with only one method <code>hello()</code>. We need to add extra methods that will allow CRUD operations on villains.</p>\n<p>Here are the new methods to add to the <code>VillainResource</code> class:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport org.jboss.logging.Logger;\nimport org.jboss.resteasy.reactive.RestPath;\nimport org.jboss.resteasy.reactive.RestResponse;\n\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport java.util.List;\n\nimport static jakarta.ws.rs.core.MediaType.TEXT_PLAIN;\n\n@Path(\"/api/villains\")\npublic class VillainResource {\n\n    Logger logger;\n    VillainService service;\n\n    public VillainResource(Logger logger, VillainService service) {\n        this.service = service;\n        this.logger = logger;\n    }\n\n    @GET\n    @Path(\"/random\")\n    public RestResponse&lt;Villain&gt; getRandomVillain() {\n        Villain villain = service.findRandomVillain();\n        logger.debug(\"Found random villain \" + villain);\n        return RestResponse.ok(villain);\n    }\n\n    @GET\n    public RestResponse&lt;List&lt;Villain&gt;&gt; getAllVillains() {\n        List&lt;Villain&gt; villains = service.findAllVillains();\n        logger.debug(\"Total number of villains \" + villains.size());\n        return RestResponse.ok(villains);\n    }\n\n    @GET\n    @Path(\"/{id}\")\n    public RestResponse&lt;Villain&gt; getVillain(@RestPath Long id) {\n        Villain villain = service.findVillainById(id);\n        if (villain != null) {\n            logger.debug(\"Found villain \" + villain);\n            return RestResponse.ok(villain);\n        } else {\n            logger.debug(\"No villain found with id \" + id);\n            return RestResponse.noContent();\n        }\n    }\n\n    @POST\n    public RestResponse&lt;Void&gt; createVillain(@Valid Villain villain, @Context UriInfo uriInfo) {\n        villain = service.persistVillain(villain);\n        UriBuilder builder = uriInfo.getAbsolutePathBuilder().path(Long.toString(villain.id));\n        logger.debug(\"New villain created with URI \" + builder.build().toString());\n        return RestResponse.created(builder.build());\n    }\n\n    @PUT\n    public RestResponse&lt;Villain&gt; updateVillain(@Valid Villain villain) {\n        villain = service.updateVillain(villain);\n        logger.debug(\"Villain updated with new valued \" + villain);\n        return RestResponse.ok(villain);\n    }\n\n    @DELETE\n    @Path(\"/{id}\")\n    public RestResponse&lt;Void&gt; deleteVillain(@RestPath Long id) {\n        service.deleteVillain(id);\n        logger.debug(\"Villain deleted with \" + id);\n        return RestResponse.noContent();\n    }\n\n    @GET\n    @Path(\"/hello\")\n    @Produces(TEXT_PLAIN)\n    public String hello() {\n        return \"Hello Villain Resource\";\n    }\n}\n</code></pre>\n<p>Note that we added <code>@Path(\"/hello\")</code> to the <code>hello</code> method to not conflict with the <code>getAllVillains()</code> method.</p>"},{"location":"Super-Heroes-Workshop/#dependency-injection","title":"Dependency Injection","text":"<p>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture You can learn more about it in the Contexts and Dependency Injection guide.</p>\n<p>ArC handles injection at build time. You can use field injection and inject the <code>VillainService</code> and the logger using:</p>\n<pre><code>@Inject Logger logger;\n@Inject VillainService service;\n</code></pre>\n<p>But in your previous class, we used constructor injection. Both the <code>VillainService</code> and the <code>Logger</code> are injected as constructor parameter:</p>\n<pre><code>public VillainResource(Logger logger, VillainService service) {\n    this.service = service;\n    this.logger = logger;\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#adding-data","title":"Adding Data","text":"<p>To load some SQL statements when Hibernate ORM starts, add the following <code>import.sql</code> in the root of the <code>resources</code> directory. It contains SQL statements terminated by a semicolon. This is useful to have a data set ready for the tests or demos.</p>\n<pre><code>ALTER SEQUENCE villain_seq RESTART WITH 50;\n\nINSERT INTO villain(id, name, otherName, picture, powers, level)\nVALUES (nextval('villain_seq'), 'Buuccolo', 'Majin Buu',\n        'https://www.superherodb.com/pictures2/portraits/10/050/15355.jpg',\n        'Accelerated Healing, Adaptation, Agility, Flight, Immortality, Intelligence, Invulnerability, Reflexes, Self-Sustenance, Size Changing, Spatial Awareness, Stamina, Stealth, Super Breath, Super Speed, Super Strength, Teleportation',\n        22);\nINSERT INTO villain(id, name, otherName, picture, powers, level)\nVALUES (nextval('villain_seq'), 'Darth Vader', 'Anakin Skywalker',\n        'https://www.superherodb.com/pictures2/portraits/10/050/10444.jpg',\n        'Accelerated Healing, Agility, Astral Projection, Cloaking, Danger Sense, Durability, Electrokinesis, Energy Blasts, Enhanced Hearing, Enhanced Senses, Force Fields, Hypnokinesis, Illusions, Intelligence, Jump, Light Control, Marksmanship, Precognition, Psionic Powers, Reflexes, Stealth, Super Speed, Telekinesis, Telepathy, The Force, Weapons Master',\n        13);\nINSERT INTO villain(id, name, otherName, picture, powers, level)\nVALUES (nextval('villain_seq'), 'The Rival (CW)', 'Edward Clariss',\n        'https://www.superherodb.com/pictures2/portraits/10/050/13846.jpg',\n        'Accelerated Healing, Agility, Bullet Time, Durability, Electrokinesis, Endurance, Enhanced Senses, Intangibility, Marksmanship, Phasing, Reflexes, Speed Force, Stamina, Super Speed, Super Strength',\n        10);\n</code></pre>\n<p>Ok, but that\u2019s just a few entries. Download the SQL file import.sql and copy it under <code>src/main/resources</code>. Now, you have more than 500 villains that will be loaded in the database.</p>\n<p>If you didn\u2019t yet, start the application in dev mode by executing the following command under the <code>rest-villains</code> directory:</p>"},{"location":"Super-Heroes-Workshop/#crud-tests-in-villainresourcetest","title":"CRUD Tests in VillainResourceTest","text":"<p>To test the <code>VillainResource</code> endpoint, we just need to extend the <code>VillainResourceTest</code> we already have. No need to configure anything, Quarkus will start a test database for you.</p>\n<p>In <code>io.quarkus.workshop.superheroes.villain.VillainResourceTest</code>, you will add the following test methods to the <code>VillainResourceTest</code> class:</p>\n<ul>\n<li>\n<p><code>shouldNotGetUnknownVillain</code>: giving a random Villain identifier, the <code>VillainResource</code> endpoint should return a 204 (No content)</p>\n</li>\n<li>\n<p><code>shouldGetRandomVillain</code>: checks that the <code>VillainResource</code> endpoint returns a random villain</p>\n</li>\n<li>\n<p><code>shouldNotAddInvalidItem</code>: passing an invalid <code>Villain</code> should fail when creating it (thanks to the <code>@Valid</code> annotation)</p>\n</li>\n<li>\n<p><code>shouldGetInitialItems</code>: checks that the <code>VillainResource</code> endpoint returns the list of heroes</p>\n</li>\n<li>\n<p><code>shouldAddAnItem</code>: checks that the <code>VillainResource</code> endpoint creates a valid <code>Villain</code></p>\n</li>\n<li>\n<p><code>shouldUpdateAnItem</code>: checks that the <code>VillainResource</code> endpoint updates a newly created <code>Villain</code></p>\n</li>\n<li>\n<p><code>shouldRemoveAnItem</code>: checks that the <code>VillainResource</code> endpoint deletes a villain from the database</p>\n</li>\n</ul>\n<p>The code is as follows:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.common.mapper.TypeRef;\nimport org.hamcrest.core.Is;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport static io.restassured.RestAssured.get;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.MediaType.TEXT_PLAIN;\nimport static jakarta.ws.rs.core.Response.Status.BAD_REQUEST;\nimport static jakarta.ws.rs.core.Response.Status.CREATED;\nimport static jakarta.ws.rs.core.Response.Status.NO_CONTENT;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n@QuarkusTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class VillainResourceTest {\n\n    private static final String JSON = \"application/json;charset=UTF-8\";\n\n    private static final String DEFAULT_NAME = \"Super Chocolatine\";\n    private static final String UPDATED_NAME = \"Super Chocolatine (updated)\";\n    private static final String DEFAULT_OTHER_NAME = \"Super Chocolatine chocolate in\";\n    private static final String UPDATED_OTHER_NAME = \"Super Chocolatine chocolate in (updated)\";\n    private static final String DEFAULT_PICTURE = \"super_chocolatine.png\";\n    private static final String UPDATED_PICTURE = \"super_chocolatine_updated.png\";\n    private static final String DEFAULT_POWERS = \"does not eat pain au chocolat\";\n    private static final String UPDATED_POWERS = \"does not eat pain au chocolat (updated)\";\n    private static final int DEFAULT_LEVEL = 42;\n    private static final int UPDATED_LEVEL = 43;\n\n    private static final int NB_VILLAINS = 570;\n    private static String villainId;\n\n    @Test\n    public void testHelloEndpoint() {\n        given().header(ACCEPT, TEXT_PLAIN).when().get(\"/api/villains/hello\").then().statusCode(200).body(is(\"Hello Villain Resource\"));\n    }\n\n    @Test\n    void shouldNotGetUnknownVillain() {\n        Long randomId = new Random().nextLong();\n        given().pathParam(\"id\", randomId).when().get(\"/api/villains/{id}\").then().statusCode(NO_CONTENT.getStatusCode());\n    }\n\n    @Test\n    void shouldGetRandomVillain() {\n        given().when().get(\"/api/villains/random\").then().statusCode(OK.getStatusCode()).contentType(APPLICATION_JSON);\n    }\n\n    @Test\n    void shouldNotAddInvalidItem() {\n        Villain villain = new Villain();\n        villain.name = null;\n        villain.otherName = DEFAULT_OTHER_NAME;\n        villain.picture = DEFAULT_PICTURE;\n        villain.powers = DEFAULT_POWERS;\n        villain.level = 0;\n\n        given()\n            .body(villain)\n            .header(CONTENT_TYPE, JSON)\n            .header(ACCEPT, JSON)\n            .when()\n            .post(\"/api/villains\")\n            .then()\n            .statusCode(BAD_REQUEST.getStatusCode());\n    }\n\n    @Test\n    @Order(1)\n    void shouldGetInitialItems() {\n        List&lt;Villain&gt; villains = get(\"/api/villains\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(getVillainTypeRef());\n        assertEquals(NB_VILLAINS, villains.size());\n    }\n\n    @Test\n    @Order(2)\n    void shouldAddAnItem() {\n        Villain villain = new Villain();\n        villain.name = DEFAULT_NAME;\n        villain.otherName = DEFAULT_OTHER_NAME;\n        villain.picture = DEFAULT_PICTURE;\n        villain.powers = DEFAULT_POWERS;\n        villain.level = DEFAULT_LEVEL;\n\n        String location = given()\n            .body(villain)\n            .header(CONTENT_TYPE, JSON)\n            .header(ACCEPT, JSON)\n            .when()\n            .post(\"/api/villains\")\n            .then()\n            .statusCode(CREATED.getStatusCode())\n            .extract()\n            .header(\"Location\");\n        assertTrue(location.contains(\"/api/villains\"));\n\n        // Stores the id\n        String[] segments = location.split(\"/\");\n        villainId = segments[segments.length - 1];\n        assertNotNull(villainId);\n\n        given()\n            .pathParam(\"id\", villainId)\n            .when()\n            .get(\"/api/villains/{id}\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .body(\"name\", Is.is(DEFAULT_NAME))\n            .body(\"otherName\", Is.is(DEFAULT_OTHER_NAME))\n            .body(\"level\", Is.is(DEFAULT_LEVEL))\n            .body(\"picture\", Is.is(DEFAULT_PICTURE))\n            .body(\"powers\", Is.is(DEFAULT_POWERS));\n\n        List&lt;Villain&gt; villains = get(\"/api/villains\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(getVillainTypeRef());\n        assertEquals(NB_VILLAINS + 1, villains.size());\n    }\n\n    @Test\n    @Order(3)\n    void testUpdatingAnItem() {\n        Villain villain = new Villain();\n        villain.id = Long.valueOf(villainId);\n        villain.name = UPDATED_NAME;\n        villain.otherName = UPDATED_OTHER_NAME;\n        villain.picture = UPDATED_PICTURE;\n        villain.powers = UPDATED_POWERS;\n        villain.level = UPDATED_LEVEL;\n\n        given()\n            .body(villain)\n            .header(CONTENT_TYPE, JSON)\n            .header(ACCEPT, JSON)\n            .when()\n            .put(\"/api/villains\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .body(\"name\", Is.is(UPDATED_NAME))\n            .body(\"otherName\", Is.is(UPDATED_OTHER_NAME))\n            .body(\"level\", Is.is(UPDATED_LEVEL))\n            .body(\"picture\", Is.is(UPDATED_PICTURE))\n            .body(\"powers\", Is.is(UPDATED_POWERS));\n\n        List&lt;Villain&gt; villains = get(\"/api/villains\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(getVillainTypeRef());\n        assertEquals(NB_VILLAINS + 1, villains.size());\n    }\n\n    @Test\n    @Order(4)\n    void shouldRemoveAnItem() {\n        given().pathParam(\"id\", villainId).when().delete(\"/api/villains/{id}\").then().statusCode(NO_CONTENT.getStatusCode());\n\n        List&lt;Villain&gt; villains = get(\"/api/villains\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .extract()\n            .body()\n            .as(getVillainTypeRef());\n        assertEquals(NB_VILLAINS, villains.size());\n    }\n\n    private TypeRef&lt;List&lt;Villain&gt;&gt; getVillainTypeRef() {\n        return new TypeRef&lt;List&lt;Villain&gt;&gt;() {\n            // Kept empty on purpose\n        };\n    }\n\n}\n</code></pre>\n<p>The tests and the application runs in the same JVM, meaning that the test can be injected with application beans. This feature is very useful to test specific parts of the application. However, in our case, we just execute HTTP requests to check the result.</p>\n<p>Run the test either in the dev mode or using <code>./mvnw test</code>. They should pass.</p>"},{"location":"Super-Heroes-Workshop/#building-production-package","title":"Building production package","text":"<p>Our service is not completely done yet, but let\u2019s run it in prod mode.</p>"},{"location":"Super-Heroes-Workshop/#configuring-the-application","title":"Configuring the application","text":"<p>In prod mode, the dev services won\u2019t be used. We need to configure the application to connect to a real database.</p>\n<p>The main way of obtaining connections to a database is to use a datasource. In Quarkus, the out of the box datasource and connection pooling implementation is Agroal.</p>\n<p>So, we need to configure the database access in the <code>src/main/resources/application.properties</code> file, but only when the application runs in prod mode.</p>\n<p>Add the following datasource configuration:</p>\n<pre><code>%prod.quarkus.datasource.username=superbad\n%prod.quarkus.datasource.password=superbad\n%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/villains_database\n%prod.quarkus.hibernate-orm.sql-load-script=import.sql\n</code></pre>\n<p><code>%prod</code> indicates that the property is only used when the application runs with the given profile. We configure the access to the database, and force the data initialization (which would have been disabled by default in prod mode).</p>"},{"location":"Super-Heroes-Workshop/#running-the-infrastructure","title":"Running the Infrastructure","text":"<p>Before going further, be sure to run the infrastructure. To execute this service, you need a database. Let\u2019s use Docker and docker compose to ease the installation of such infrastructure.</p>\n<p>You should already have installed the infrastructure into the <code>infrastructure</code> directory.</p>\n<p>Now, just execute <code>docker compose -f docker-compose.yaml up -d</code> under the <code>infrastructure</code> directory. You should see a few logs going on and then all the containers get started.</p>\n<p>During the workshop, just leave all the containers up and running. Then, after the workshop, remember to shut them down using: <code>docker compose -f docker-compose.yaml down</code> .</p>"},{"location":"Super-Heroes-Workshop/#packaging-and-running-the-application_1","title":"Packaging and running the application","text":"<p>Stop the dev mode, and run:</p>\n<p>As previously, you will get your application in <code>target/quarkus-app</code>, run it using:</p>\n<pre><code>java -jar target/quarkus-app/quarkus-run.jar\n</code></pre>\n<p>Open your browser to http://localhost:8080/api/villains, and verify it displays the expected content. Once done, stop the application using <code>CTRL+C</code>.</p>"},{"location":"Super-Heroes-Workshop/#configuring-the-villain-microservice","title":"Configuring the Villain Microservice","text":"<p>Hardcoded values in our code are a no go (even if we all did it at some point). In this guide, we learn how to configure our Villain API as well as some parts of Quarkus.</p>"},{"location":"Super-Heroes-Workshop/#configuring-logging","title":"Configuring Logging","text":"<p>In the <code>VillainResource</code>, we injected a logger. That\u2019s very useful to provide meaningful information about the execution. But you often need to adjust the configuration, such as the log level.</p>\n<p>Runtime configuration of logging is done through the normal <code>application.properties</code> file:</p>\n<pre><code>quarkus.log.console.enable=true\nquarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n\nquarkus.log.console.level=INFO\nquarkus.log.console.darken=1\n</code></pre>"},{"location":"Super-Heroes-Workshop/#configuring-quarkus-listening-port","title":"Configuring Quarkus Listening Port","text":"<p>Because we will end-up running several microservices, let\u2019s configure Quarkus so it listens to a different port than 8080: This is quite easy as we just need to add one property in the <code>application.properties</code> file:</p>\n<pre><code>## HTTP configuration\nquarkus.http.port=8084\n</code></pre>\n<p>Changing the port is one of the rare configuration that cannot be done while the application is running.</p>\n<p>You would need to restart the application to change the port.</p>\n<p>Hit <code>CTRL+C</code> to stop the application if it still running and restart it with: <code>./mvnw quarkus:dev</code>. Then run:</p>\n<pre><code>curl http://localhost:8084/api/villains | jq\n</code></pre>"},{"location":"Super-Heroes-Workshop/#injecting-configuration-value","title":"Injecting Configuration Value","text":"<p>When we persist a new villain, we want to multiply the level by a value that can be configured (to reduce the level, so heroes will win the fights more easily). For this, Quarkus uses MicroProfile Config to inject the configuration in the application. The injection uses the <code>@ConfigProperty</code> annotation.</p>\n<p>When injecting a configured value, you can use <code>@Inject @ConfigProperty</code> or just <code>@ConfigProperty</code>. The <code>@Inject</code> annotation is not necessary for members annotated with <code>@ConfigProperty</code>, a behavior which differs from MicroProfile Config.</p>\n\n<p>Edit the <code>VillainService</code>, and introduce the following configuration properties:</p>\n<pre><code>@ConfigProperty(name = \"level.multiplier\", defaultValue=\"1.0\") double levelMultiplier;\n</code></pre>\n<p>You may need to add the following import statement if your IDE does not do it automatically: <code>import org.eclipse.microprofile.config.inject.ConfigProperty;</code></p>\n\n<p>If you do not provide a value for this property, the application startup fails with <code>jakarta.enterprise.inject.spi.DeploymentException: No config value of type [int] exists for: level.multiplier</code>. To avoid having to configure a value, we configure a default one (property <code>defaultValue</code>).</p>\n<p>Now, modify the <code>VillainService.persistVillain()</code> method to use the injected properties:</p>\n<pre><code>public Villain persistVillain(@Valid Villain villain) {\n        villain.level = (int) Math.round(villain.level * levelMultiplier);\n        villain.persist();\n        return villain;\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#create-the-configuration","title":"Create the Configuration","text":"<p>By default, Quarkus reads <code>application.properties</code>.</p>\n<p>Edit the <code>src/main/resources/application.properties</code> with the following content:</p>"},{"location":"Super-Heroes-Workshop/#running-and-testing-the-application","title":"Running and Testing the Application","text":"<p>If you didn\u2019t already, start the application with <code>./mvnw quarkus:dev</code>. Once started, create a new villain with the following cUrl command (notice the verbose option <code>-v</code> to see the HTTP response headers):</p>\n<pre><code>curl -X POST -d  '{\"level\":5, \"name\":\"Super Bad\", \"powers\":\"Agility, Longevity\"}'  -H \"Content-Type: application/json\" http://localhost:8084/api/villains -v\n</code></pre>\n<p>You should see something like this:</p>\n<pre><code>&lt; HTTP/1.1 201 Created\n&lt; Location: http://localhost:8084/api/villains/582\n</code></pre>\n<p>As you can see, we\u2019ve passed a level of 5 to create this new villain. The cURL command returns the location of the newly created villain. Take this URL and do an HTTP GET on it. You will see that the level has been decreased.</p>\n<p>The example shows a newly created Villain with id <code>582</code>. But this id could be different on your machine. Just make sure to use the correct id in the next command.</p>\n\n<pre><code>curl http://localhost:8084/api/villains/582 | jq\n\n{\n  \"id\": 582,\n  \"level\": 3,\n  \"name\": \"Super Bad\",\n  \"powers\": \"Agility, Longevity\"\n}\n</code></pre>\n<p>Hey! Wait a minute! It you enabled continuous testing, Quarkus should have warned you:</p>\n<pre><code>--\nRunning 2/8. Running: io.quarkus.workshop.superheroes.villain.VillainResourceTest#shouldAddAnItem()\nPress [o] Toggle test output, [h] for more options&gt;WARNING: An illegal reflective access operation has occurred\n2021-09-21 21:02:16,067 ERROR [io.qua.test] (Test runner thread) ==================== TEST REPORT #1 ====================\n2021-09-21 21:02:16,067 ERROR [io.qua.test] (Test runner thread) Test VillainResourceTest#shouldAddAnItem() failed\n: java.lang.AssertionError: 1 expectation failed.\nJSON path level doesn't match.\nExpected: is &lt;42&gt;\n  Actual: &lt;21&gt;\n\n        at io.restassured.internal.ValidatableResponseImpl.body(ValidatableResponseImpl.groovy)\n        at io.quarkus.workshop.superheroes.villain.VillainResourceTest.shouldAddAnItem(VillainResourceTest.java:133)\n\n2021-09-21 21:02:16,070 ERROR [io.qua.test] (Test runner thread) &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1 TEST FAILED &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<p>Tests are failing now! Indeed, they don\u2019t know the multiplier.</p>\nPress <code>r</code> in the dev mode to run the tests.\n\n<p>In the <code>application.properties</code> file, add: <code>%test.level.multiplier=1</code> which set the multiplier to 1 when running the tests:</p>\n<pre><code>All 8 tests are passing (0 skipped), 8 tests were run in 1722ms. Tests completed at 21:03:25.\n</code></pre>"},{"location":"Super-Heroes-Workshop/#open-api","title":"Open API","text":"<p>A Quarkus application can expose its API description through an OpenAPI specification. Quarkus also lets you test it via a user-friendly UI named Swagger UI.</p>\n<p>In this section, we will see how to use OpenAPI with Quarkus and introduce the dev console.</p>"},{"location":"Super-Heroes-Workshop/#directory-structure_2","title":"Directory Structure","text":"<p>In this module we will add extra class (<code>VillainApplication</code>) to the Villain API project. You will end-up with the following directory structure:</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#installing-the-openapi-extension","title":"Installing the OpenAPI extension","text":"<p>Quarkus proposes a <code>smallrye-openapi</code> extension compliant with the MicroProfile OpenAPI specification in order to generate your API OpenAPI v3 specification.</p>\n<p>To install the OpenAPI dependency, just run the following command:</p>\n<pre><code>./mvnw quarkus:add-extension -Dextensions=\"smallrye-openapi\"\n</code></pre>\n<p>This will add the following dependency in the <code>pom.xml</code> file:</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-smallrye-openapi&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#open-api_1","title":"Open API","text":"<pre><code>openapi: 3.0.3\ninfo:\n  title: rest-villains API\n  version: 1.0.0-SNAPSHOT\npaths:\n  /api/villains:\n    get:\n      tags:\n      - Villain Resource\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Villain'\n    put:\n      tags:\n      - Villain Resource\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/Villain'\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Villain'\n    post:\n      tags:\n      - Villain Resource\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/Villain'\n      responses:\n        \"201\":\n          description: Created\n  /api/villains/hello:\n    get:\n      tags:\n      - Villain Resource\n      responses:\n        \"200\":\n          description: OK\n          content:\n            text/plain:\n              schema:\n                type: string\n  /api/villains/random:\n    get:\n      tags:\n      - Villain Resource\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Villain'\n  /api/villains/{id}:\n    get:\n      tags:\n      - Villain Resource\n      parameters:\n      - name: id\n        in: path\n        required: true\n        schema:\n          format: int64\n          type: integer\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Villain'\n    delete:\n      tags:\n      - Villain Resource\n      parameters:\n      - name: id\n        in: path\n        required: true\n        schema:\n          format: int64\n          type: integer\n      responses:\n        \"204\":\n          description: No Content\ncomponents:\n  schemas:\n    Villain:\n      required:\n      - name\n      - level\n      type: object\n      properties:\n        id:\n          format: int64\n          type: integer\n        name:\n          maxLength: 50\n          minLength: 3\n          type: string\n        otherName:\n          type: string\n        level:\n          format: int32\n          minimum: 1\n          type: integer\n        picture:\n          type: string\n        powers:\n          type: string\n  securitySchemes:\n    SecurityScheme:\n      type: http\n      description: Authentication\n      scheme: basic\n</code></pre>\n<p>This contract lacks documentation. The Eclipse MicroProfile OpenAPI allows you to customize the methods of your REST endpoint as well as the application.</p>\n<p>While having the OpenAPI specification is great, it can\u2019t be consumed easily by humans. In your browser, go to http://localhost:8084/q/dev. This is the dev console. It provides all the tools you need to develop your Quarkus application. We will use it several times in this workshop. Note that the dev console is only available in dev mode.</p>\n<p>The Dev Console integrates Swagger, a UI to invoke your endpoints from the comfort of your browser. Click on the \"Swagger UI\" button located in the \"SmallRye OpenAPI\" widget (http://localhost:8084/q/swagger-ui).</p>\n<p>You will see all your endpoints listed. Click on the \"GET\" button for the \"/api/villains\" path, then click on \"Try it out\" and finally on \"Execute\". You can see the result immediately.</p>\n<p>When developing REST APIs, this UI is very convenient. You can test your endpoint and immediately see the outcome. If something does not please you, edit the code, go back to the browser, re-execute, and voil\u00e0!</p>"},{"location":"Super-Heroes-Workshop/#customizing-methods","title":"Customizing Methods","text":"<p>The MicroProfile OpenAPI has a set of annotations to customize each REST endpoint method so the OpenAPI contract is richer and clearer for consumers:</p>\n<ul>\n<li>\n<p><code>@Operation</code>: Describes a single API operation on a path.</p>\n</li>\n<li>\n<p><code>@APIResponse</code>: Corresponds to the OpenAPI Response model object which describes a single response from an API Operation</p>\n</li>\n<li>\n<p><code>@Parameter</code>: The name of the parameter.</p>\n</li>\n<li>\n<p><code>@RequestBody</code>: A brief description of the request body.</p>\n</li>\n</ul>\n<p>This is what the <code>VillainResource</code> endpoint should look like once you have annotated it:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\n\nimport java.net.URI;\nimport java.util.List;\n\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport org.eclipse.microprofile.openapi.annotations.Operation;\nimport org.eclipse.microprofile.openapi.annotations.enums.SchemaType;\nimport org.eclipse.microprofile.openapi.annotations.media.Content;\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\nimport org.eclipse.microprofile.openapi.annotations.responses.APIResponse;\nimport org.eclipse.microprofile.openapi.annotations.tags.Tag;\nimport org.jboss.logging.Logger;\nimport org.jboss.resteasy.reactive.RestPath;\nimport org.jboss.resteasy.reactive.RestResponse;\n\n@Path(\"/api/villains\")\n@Tag(name = \"villains\")\npublic class VillainResource {\n    Logger logger;\n    VillainService service;\n\n    public VillainResource(Logger logger, VillainService service) {\n        this.service = service;\n        this.logger = logger;\n    }\n\n    @Operation(summary = \"Returns a random villain\")\n    @GET\n    @Path(\"/random\")\n    @APIResponse(\n        responseCode = \"200\",\n        content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Villain.class, required = true))\n    )\n    public RestResponse&lt;Villain&gt; getRandomVillain() {\n        Villain villain = service.findRandomVillain();\n        logger.debug(\"Found random villain \" + villain);\n        return RestResponse.ok(villain);\n    }\n\n    @Operation(summary = \"Returns all the villains from the database\")\n    @GET\n    @APIResponse(\n        responseCode = \"200\",\n        content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Villain.class, type = SchemaType.ARRAY))\n    )\n    public RestResponse&lt;List&lt;Villain&gt;&gt; getAllVillains() {\n        List&lt;Villain&gt; villains = service.findAllVillains();\n        logger.debug(\"Total number of villains \" + villains.size());\n        return RestResponse.ok(villains);\n    }\n\n    @Operation(summary = \"Returns a villain for a given identifier\")\n    @GET\n    @Path(\"/{id}\")\n    @APIResponse(responseCode = \"200\", content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Villain.class)))\n    @APIResponse(responseCode = \"204\", description = \"The villain is not found for a given identifier\")\n    public RestResponse&lt;Villain&gt; getVillain(@RestPath Long id) {\n        Villain villain = service.findVillainById(id);\n        if (villain != null) {\n            logger.debug(\"Found villain \" + villain);\n            return RestResponse.ok(villain);\n        } else {\n            logger.debug(\"No villain found with id \" + id);\n            return RestResponse.noContent();\n        }\n    }\n\n    @Operation(summary = \"Creates a valid villain\")\n    @POST\n    @APIResponse(\n        responseCode = \"201\",\n        description = \"The URI of the created villain\",\n        content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = URI.class))\n    )\n    public RestResponse&lt;Void&gt; createVillain(@Valid Villain villain, @Context UriInfo uriInfo) {\n        villain = service.persistVillain(villain);\n        UriBuilder builder = uriInfo.getAbsolutePathBuilder().path(Long.toString(villain.id));\n        logger.debug(\"New villain created with URI \" + builder.build().toString());\n        return RestResponse.created(builder.build());\n    }\n\n    @Operation(summary = \"Updates an exiting  villain\")\n    @PUT\n    @APIResponse(\n        responseCode = \"200\",\n        description = \"The updated villain\",\n        content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Villain.class))\n    )\n    public RestResponse&lt;Villain&gt; updateVillain(@Valid Villain villain) {\n        villain = service.updateVillain(villain);\n        logger.debug(\"Villain updated with new valued \" + villain);\n        return RestResponse.ok(villain);\n    }\n\n    @Operation(summary = \"Deletes an exiting villain\")\n    @DELETE\n    @Path(\"/{id}\")\n    @APIResponse(responseCode = \"204\")\n    public RestResponse&lt;Void&gt; deleteVillain(@RestPath Long id) {\n        service.deleteVillain(id);\n        logger.debug(\"Villain deleted with \" + id);\n        return RestResponse.noContent();\n    }\n\n    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello Villain Resource\";\n    }\n}\n</code></pre>\n<p>With this new code, go back to the Swagger UI at http://localhost:8084/q/swagger-ui and refresh. Your endpoints are organized by tags, and each annotated endpoint is documented.</p>\n<p>Documenting REST API is essential when working with different teams. You can see OpenAPI as the JavaDoc for REST.</p>"},{"location":"Super-Heroes-Workshop/#customizing-the-application","title":"Customizing the Application","text":"<p>The previous annotations allow you to customize the contract for a given REST Endpoint. But it\u2019s also important to document the entire application.</p>\n<p>The Microprofile OpenAPI also has a set of annotation to do so. The difference is that these annotations cannot be used on the endpoint methods, but instead on another Java class configuring the entire application.</p>\n<p>For this, you need to create the <code>src/main/java/io/quarkus/workshop/superheroes/villain/VillainApplication</code> class with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport jakarta.ws.rs.ApplicationPath;\nimport jakarta.ws.rs.core.Application;\nimport org.eclipse.microprofile.openapi.annotations.ExternalDocumentation;\nimport org.eclipse.microprofile.openapi.annotations.OpenAPIDefinition;\nimport org.eclipse.microprofile.openapi.annotations.info.Contact;\nimport org.eclipse.microprofile.openapi.annotations.info.Info;\nimport org.eclipse.microprofile.openapi.annotations.servers.Server;\n\n@ApplicationPath(\"/\")\n@OpenAPIDefinition(\n    info = @Info(\n        title = \"Villain API\",\n        description = \"This API allows CRUD operations on a villain\",\n        version = \"1.0\",\n        contact = @Contact(name = \"Quarkus\", url = \"https://github.com/quarkusio\")\n    ),\n    servers = { @Server(url = \"http://localhost:8084\") },\n    externalDocs = @ExternalDocumentation(url = \"https://github.com/quarkusio/quarkus-workshops\", description = \"All the Quarkus workshops\")\n)\npublic class VillainApplication extends Application {\n    // Empty body\n}\n</code></pre>\n<p>Go back to the Swagger UI and refresh again. At the top of the document, you can see the version and the global API documentation.</p>"},{"location":"Super-Heroes-Workshop/#customized-contract","title":"Customized Contract","text":"<pre><code>openapi: 3.0.3\ninfo:\n    title: Villain API\n    description: This API allows CRUD operations on a villain\n    contact:\n        name: Quarkus\n        url: https://github.com/quarkusio\n    version: \"1.0\"\nexternalDocs:\n    description: All the Quarkus workshops\n    url: https://github.com/quarkusio/quarkus-workshops\nservers:\n    -   url: http://localhost:8084\ntags:\n    -   name: villains\npaths:\n    /api/villains:\n        get:\n            tags:\n                - villains\n            summary: Returns all the villains from the database\n            responses:\n                \"200\":\n                    description: OK\n                    content:\n                        application/json:\n                            schema:\n                                type: array\n                                items:\n                                    $ref: '#/components/schemas/Villain'\n        put:\n            tags:\n                - villains\n            summary: Updates an exiting  villain\n            requestBody:\n                content:\n                    application/json:\n                        schema:\n                            $ref: '#/components/schemas/Villain'\n            responses:\n                \"200\":\n                    description: The updated villain\n                    content:\n                        application/json:\n                            schema:\n                                $ref: '#/components/schemas/Villain'\n        post:\n            tags:\n                - villains\n            summary: Creates a valid villain\n            requestBody:\n                content:\n                    application/json:\n                        schema:\n                            $ref: '#/components/schemas/Villain'\n            responses:\n                \"201\":\n                    description: The URI of the created villain\n                    content:\n                        application/json:\n                            schema:\n                                format: uri\n                                type: string\n    /api/villains/hello:\n        get:\n            tags:\n                - villains\n            responses:\n                \"200\":\n                    description: OK\n                    content:\n                        text/plain:\n                            schema:\n                                type: string\n    /api/villains/random:\n        get:\n            tags:\n                - villains\n            summary: Returns a random villain\n            responses:\n                \"200\":\n                    description: OK\n                    content:\n                        application/json:\n                            schema:\n                                $ref: '#/components/schemas/Villain'\n    /api/villains/{id}:\n        get:\n            tags:\n                - villains\n            summary: Returns a villain for a given identifier\n            parameters:\n                -   name: id\n                    in: path\n                    required: true\n                    schema:\n                        format: int64\n                        type: integer\n            responses:\n                \"200\":\n                    description: OK\n                    content:\n                        application/json:\n                            schema:\n                                $ref: '#/components/schemas/Villain'\n                \"204\":\n                    description: The villain is not found for a given identifier\n        delete:\n            tags:\n                - villains\n            summary: Deletes an exiting villain\n            parameters:\n                -   name: id\n                    in: path\n                    required: true\n                    schema:\n                        format: int64\n                        type: integer\n            responses:\n                \"204\":\n                    description: No Content\ncomponents:\n    schemas:\n        Villain:\n            required:\n                - name\n                - level\n            type: object\n            properties:\n                id:\n                    format: int64\n                    type: integer\n                name:\n                    maxLength: 50\n                    minLength: 3\n                    type: string\n                otherName:\n                    type: string\n                level:\n                    format: int32\n                    minimum: 1\n                    type: integer\n                picture:\n                    type: string\n                powers:\n                    type: string\n    securitySchemes:\n        SecurityScheme:\n            type: http\n            description: Authentication\n            scheme: basic\n</code></pre>\n<p>You can expose or exchange this contract to the API consumers, so they now what to expect when using your API.</p>"},{"location":"Super-Heroes-Workshop/#openapi-tests-in-villainresourcetest","title":"OpenAPI Tests in VillainResourceTest","text":"<p>Let\u2019s add an extra test method in <code>VillainResourceTest</code> ensuring that the OpenAPI specification is packaged with the application:</p>\n<pre><code>@Test\nvoid shouldPingOpenAPI() {\n    given().header(ACCEPT, JSON).when().get(\"/q/openapi\").then().statusCode(OK.getStatusCode());\n}\n</code></pre>\n<p>Run the test:</p>\n<ul>\n<li>\n<p>From the dev mode, or</p>\n</li>\n<li>\n<p>By executing the test using <code>./mvnw test</code>.</p>\n</li>\n</ul>\n\n<p>In the previous chapter, you had a quick peek at Quarkus and how you can build HTTP / REST-based applications with it. But that was just the beginning; Quarkus can do a lot more, which is the purpose of this chapter. In this chapter, you are going to see:</p>\n<ul>\n<li>\n<p>What\u2019s Quarkus? and how does it change the Java landscape</p>\n</li>\n<li>\n<p>What are the main Quarkus idea, and how it helps in the cloud native world</p>\n</li>\n<li>\n<p>The Quarkus build process, in other words, the secret sauce number 1</p>\n</li>\n<li>\n<p>The Quarkus reactive nature, in other words, the secret sauce number 2</p>\n</li>\n<li>\n<p>Some Quarkus features such as the application lifecycle support</p>\n</li>\n<li>\n<p>How you can use Quarkus to generate native executable</p>\n</li>\n</ul>"},{"location":"Super-Heroes-Workshop/#whats-quarkus","title":"What\u2019s Quarkus?","text":"<p>Java was born more than 25 years ago. The world 25 years ago was quite different. The software industry has gone through several revolutions over these two decades. Java has always been able to reinvent itself to stay relevant.</p>\n<p>But a new revolution is happening. While for years, most applications were running on huge machines, with lots of CPU and memory, they are now running on the Cloud, in constrained environments, in containers, where the resources are shared. Density is the new optimization: crank as many mini-apps (or microservices) as possible per node. And scale by adding more instances of an app instead of a more powerful single instance.</p>\n<p>The Java ergonomics, designed 20 years ago, do not fit well in this new environment. Java applications were designed to run 24/7 for months, even years. The JIT is optimizing the execution over time; the GC manages the memory efficiently\u2026 But all these features have a cost, and the memory required to run Java applications and startup times are showstoppers when you deploy 20 or 50 microservices instead of one application. The issue is not the JVM itself; it\u2019s also the Java ecosystem that needs to be reinvented.</p>\n<p>That\u2019s where Quarkus, and other projects, enter the game. Quarkus uses a build time principle. During the build of the application, tasks that usually happen at runtime are executed at build time.</p>\n<p></p>\n<p>Thus, when the application runs, everything has been pre-computed, and all the annotation scanning, XML parsing, and so on won\u2019t be executed anymore. It has two direct benefits: startup time (a lot faster) and memory consumption (a lot lower).</p>\n<p></p>\n<p>So, as depicted in the figure above, Quarkus does bring an infrastructure for frameworks to embrace build time metadata discovery (like annotations), replace proxies with generated classes, pre-configure most frameworks, and handle dependency injection at build time.</p>\n<p>Also, during the build, Quarkus detects which class needs to be accessed by reflection at runtime, boots framework at build time to record the result, and generally offers a lot of GraalVM optimization for free (or cheap at least). Indeed, thanks to all this metadata, Quarkus can configure native compilers such as the GraalVM compiler to generate a native executable for your Java application. Thanks to an aggressive dead-code elimination, the final executable is smaller, faster to start, and uses a ridiculously small amount of memory.</p>\n<p></p>\n<p>Quarkus does not stop there. As you have seen in the previous chapter, it proposes a stellar developer experience. It also unifies reactive and imperative to let you decide how you want to handle I/O. It allows implementing both REST and event-driven applications using a consistent model. To do this, Quarkus is based on a reactive core allowing high concurrency and reducing memory consumption.</p>\n<p>Quarkus detects if your method can be called on the I/O thread and follows the reactive execution model; or if your method must be called on a worker thread and follows the imperative execution model.</p>\n<p>Ok, but enough talking, time to see this in action.</p>"},{"location":"Super-Heroes-Workshop/#quarkus-augmentation","title":"Quarkus Augmentation","text":"<p>Let\u2019s demystify all this.</p>\n<p>So far, you have developed the super-villains microservice. This microservice is relatively simple. It still has database access, ORM support, transaction, JSON serialization, and deserialization.</p>\n<p>Let\u2019s now package this application using: <code>mvnw package</code></p>\n<p>In the log, you can see actions happening during what Quarkus calls the augmentation phase.</p>\n<pre><code>[INFO] --- quarkus-maven-plugin:3.9.1:build (default) @ rest-villains ---\n[INFO] [org.jboss.threads] JBoss Threads version 3.4.2.Final\n[INFO] [org.hibernate.Version] HHH000412: Hibernate ORM core version 5.5.7.Final\n[INFO] [io.quarkus.deployment.QuarkusAugmentor] Quarkus augmentation completed in 1932ms\n</code></pre>\n<p>In this log, you can observe the build principle. Typically, about Hibernate, it saves from having to:</p>\n<ol>\n<li>\n<p>embed an XML parser at runtime,</p>\n</li>\n<li>\n<p>Do the actual parsing,</p>\n</li>\n<li>\n<p>Configure Hibernate based on the content of the file.</p>\n</li>\n</ol>\n<p>With Quarkus, at runtime, almost everything is already configured. Only runtime configuration properties are applied at startup (such as database URLs).</p>\n<p>Also, during this augmentation, Java classes are generated or extended. Remember the <code>Villain</code> Panache entity. The class is extended during the augmentation. If you run <code>javap --class-path target/quarkus-app/quarkus/transformed-bytecode.jar io.quarkus.workshop.superheroes.villain.Villain</code>, you can see methods prefixed with <code>$$</code> added to the class.</p>\n<p>Each extension can combine build time and run time. The following figure presents some of the extensions you already used, but there are a lot more. We are going to learn more about extensions later in this workshop and even build one. What\u2019s important to understand for now is that the magic is packaged into extension, and every time you add a <code>quarkus-</code> dependency to your <code>pom.xml</code> file, you enable an extension.</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#application-lifecycle","title":"Application Lifecycle","text":"<p>Now that you know how Quarkus is structured let\u2019s continue using various extensions. You often need to execute custom actions when the application starts and clean up everything when the application stops. In this module, we will display a banner in the logs once the Villain microservice has started.</p>"},{"location":"Super-Heroes-Workshop/#directory-structure_3","title":"Directory Structure","text":"<p>In this section, we will add an extra class (<code>VillainApplicationLifeCycle</code>) to handle the Villain API lifecycle. You will end up with the following directory structure:</p>\n<p></p>\n<p>When our application starts, the logs are dull and lack a banner (any decent application must have a banner nowadays).</p>\n<p>So the first thing that you need to do is to go to the following website and pick up your favorite \"Villain API\" text banner.</p>\n<p>Create a new class named <code>VillainApplicationLifeCycle</code> (or pick another name, the name does not matter) in the <code>io.quarkus.workshop.superheroes.villain</code> package, and copy your banner, so you end up with something like the following:</p>\n<pre><code>package io.quarkus.workshop.superheroes.villain;\n\nimport io.quarkus.runtime.ShutdownEvent;\nimport io.quarkus.runtime.StartupEvent;\nimport io.quarkus.runtime.configuration.ConfigUtils;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.event.Observes;\nimport org.jboss.logging.Logger;\n\n@ApplicationScoped\npublic class VillainApplicationLifeCycle {\n\n    private static final Logger LOGGER = Logger.getLogger(VillainApplicationLifeCycle.class);\n\n    void onStart(@Observes StartupEvent ev) {\n        LOGGER.info(\" __     ___ _ _       _             _    ____ ___ \");\n        LOGGER.info(\" \\\\ \\\\   / (_) | | __ _(_)_ __       / \\\\  |  _ \\\\_ _|\");\n        LOGGER.info(\"  \\\\ \\\\ / /| | | |/ _` | | '_ \\\\     / _ \\\\ | |_) | | \");\n        LOGGER.info(\"   \\\\ V / | | | | (_| | | | | |   / ___ \\\\|  __/| | \");\n        LOGGER.info(\"    \\\\_/  |_|_|_|\\\\__,_|_|_| |_|  /_/   \\\\_\\\\_|  |___|\");\n    }\n\n    void onStop(@Observes ShutdownEvent ev) {\n        LOGGER.info(\"The application VILLAIN is stopping...\");\n    }\n}\n</code></pre>\n<p>Thanks to the CDI <code>@Observes</code>, the <code>VillainApplicationLifeCycle</code> is invoked. On startup with the <code>StartupEvent</code> so it can execute code (here, displaying the banner) when the application is starting</p>\n<p>Run the application with: <code>./mvnw quarkus:dev</code>, the banner is printed to the console. When the application is stopped, the second log message is printed.</p>\n<p>The method is called by ArC, the dependency injection framework used by Quarkus. Arc embraces the build-time principle, meaning that injection happens at build time. In addition, Arc can detect and remove unused beans at runtime, saving memory.</p>\n<p>With the application running in dev mode, open your browser to http://localhost:8084/q/dev/. In the ArC widget, you can see the number of beans that have been removed (\"Removed Beans\"), and if you click on the link, see the list. If you click on the \"Observers\" link, you will see the two methods we added. In the \"Fired Events\" view, you can see which event has been fired and when.</p>"},{"location":"Super-Heroes-Workshop/#configuration-profiles","title":"Configuration Profiles","text":"<p>Quarkus supports the notion of configuration profiles. These allow you to have multiple configurations in the same file and select between them via a profile name.</p>\n<p>Quarkus has three profiles by default, although it is possible to use as many as you like. The default profiles are:</p>\n<ul>\n<li>\n<p><code>dev</code> - Activated when in development mode (i.e. <code>quarkus:dev</code>)</p>\n</li>\n<li>\n<p><code>test</code> - Activated when running tests</p>\n</li>\n<li>\n<p><code>prod</code> - The default profile when not running in development or test mode</p>\n</li>\n</ul>\n<p>Let\u2019s change the <code>VillainApplicationLifeCycle</code> so it displays the current profile.</p>\n<p>For that, just add a log invoking <code>ConfigUtils.getProfiles()</code> in the <code>onStart()</code> method:</p>\n<pre><code>LOGGER.info(\"The application VILLAIN is starting with profile \" + ConfigUtils.getProfiles());\n</code></pre>\n<p>If not already done, you need to add the following import statement: <code>import io.quarkus.runtime.configuration.ConfigUtils;</code></p>\n\n<p>In the <code>application.properties</code> file, you can prefix a property with the profile. For example, we did add the <code>%test.level.multiplier=1</code> property in the previous chapter. It indicates that the property <code>level.multiplier</code> is set to 1 in the <code>test</code> profile.</p>\n<p>Now, you will get the <code>dev</code> profile enabled if you start your application in dev mode with <code>./mvnw compile quarkus:dev</code>. If you start the tests, the <code>test</code> profile is enabled (the <code>multiplier</code> is set to 1).</p>\n<p>You can also create your own profiles, and activate them with the <code>quarkus.profile</code> property. For example, to use a profile called <code>foo</code>, package your application with <code>./mvnw package</code>, and start it with <code>java -Dquarkus.profile=foo -jar target/quarkus-app/quarkus-run.jar</code>. You will see that the <code>foo</code> profile is enabled. As not overridden, the <code>level.multiplier</code> property has the value 0.5.</p>\n<p>Profiles are handy to customize the configuration per environment. We are going to see an example of such customization in the next section.</p>"},{"location":"Super-Heroes-Workshop/#reactive","title":"Reactive","text":"<p>Quarkus combines the build time principle with a reactive core. The combination of these two characteristics improves the application concurrency and makes use of resources more efficiently. In this chapter, we will see the counterpart of the Villain microservice: the Hero microservice! Instead of the imperative approach used for the villains, we will use reactive programming and Hibernate Reactive. The logic of the microservice is the same.</p>\n<p></p>\n<p>In the following sections, you will learn:</p>\n<ul>\n<li>\n<p>How to create a new reactive Quarkus application</p>\n</li>\n<li>\n<p>How to implement REST API using JAX-RS and the RESTEasy Reactive extension using a reactive development model</p>\n</li>\n<li>\n<p>How to access your database using Hibernate Reactive with Panache</p>\n</li>\n<li>\n<p>How to use transactions the reactive way</p>\n</li>\n</ul>\nThis service is exposed on the port 8083."},{"location":"Super-Heroes-Workshop/#why-reactive","title":"Why reactive?","text":"<p>\"Reactive\" is a set of principles to build better distributed systems. By following these principles, you create more elastic and resilient systems.</p>\n<p>One of the central aspects of being reactive is about using non-blocking I/O to handle remote interactions efficiently. With a few threads, your application can handle many concurrent I/Os. A consequence of such usage is the need to implement applications that do not block these threads. There are multiple approaches to do so, such as callbacks, co-routines, and reactive programming.</p>\n<p>Quarkus encourages users to use Mutiny, an intuitive and event-driven reactive programming library. In this section, we will cover the basics of Mutiny and implement an entirely reactive microservice.</p>"},{"location":"Super-Heroes-Workshop/#hero-microservice","title":"Hero Microservice","text":"<p>New microservice, new project!</p>\n<p>The easiest way to create this new Quarkus project is to use the Quarkus Maven plugin. Open a terminal and run the following command under the <code>quarkus-workshop-super-heroes/super-heroes</code> directory</p>\n<pre><code>./mvnw io.quarkus:quarkus-maven-plugin:3.9.1:create   -\"DplatformVersion=3.9.1\" -\"DprojectGroupId=io.quarkus.workshop.super-heroes\"  -\"DprojectArtifactId=rest-heroes\" -DclassName=\"io.quarkus.workshop.superheroes.hero.HeroResource\" -Dpath=\"api/heroes\"   -Dextensions=\"rest-jackson,quarkus-hibernate-validator,quarkus-smallrye-openapi,quarkus-hibernate-reactive-panache,quarkus-reactive-pg-client\"\n</code></pre>\n<p>As you can see, we can select multiple extensions during the project creation:</p>\n<ul>\n<li>\n<p><code>rest-jackson</code> provides RESTEasy Reactive and the ability to map JSON objects,</p>\n</li>\n<li>\n<p><code>quarkus-hibernate-validator</code> provides the Hibernate Validator support,</p>\n</li>\n<li>\n<p><code>quarkus-smallrye-openapi</code> provides the OpenAPI descriptor support and the Swagger UI in the dev console,</p>\n</li>\n<li>\n<p><code>quarkus-hibernate-reactive-panache</code> provides Panache entity supports using Hibernate Reactive, an ORM using reactive database drivers,</p>\n</li>\n<li>\n<p><code>quarkus-reactive-pg-client</code> provides the reactive database driver used by Hibernate Reactive to interact with PostGreSQL databases.</p>\n</li>\n</ul>\n<p>If you want your IDE to manage this new Maven project, you can declare it in the parent POM by adding this new module in the <code>&lt;modules&gt;</code> section:</p>\n<pre><code>&lt;module&gt;super-heroes/rest-heroes&lt;/module&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#directory-structure_4","title":"Directory Structure","text":"<p>At the end of this chapter, you will end up with the following directory structure:</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#the-hero-entity","title":"The Hero entity","text":"<p>Let\u2019s start with the <code>Hero</code> entity class.</p>\n<p>Create the <code>io.quarkus.workshop.superheroes.hero.Hero</code> class in the created project with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.hero;\n\nimport io.quarkus.hibernate.reactive.panache.PanacheEntity;\nimport io.smallrye.mutiny.Uni;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\nimport java.util.Random;\n\n@Entity\npublic class Hero extends PanacheEntity {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    public String name;\n\n    public String otherName;\n\n    @NotNull\n    @Min(1)\n    public int level;\n    public String picture;\n\n    @Column(columnDefinition = \"TEXT\")\n    public String powers;\n\n    public static Uni&lt;Hero&gt; findRandom() {\n        Random random = new Random();\n        return count()\n            .map(count -&gt; random.nextInt(count.intValue()))\n            .chain(randomHero -&gt; findAll().page(randomHero, 1)\n                .firstResult());\n    }\n\n    @Override\n    public String toString() {\n        return \"Hero{\" +\n            \"id=\" + id +\n            \", name='\" + name + '\\'' +\n            \", otherName='\" + otherName + '\\'' +\n            \", level=\" + level +\n            \", picture='\" + picture + '\\'' +\n            \", powers='\" + powers + '\\'' +\n            '}';\n    }\n}\n</code></pre>\n<p>First, note that we are extending <code>io.quarkus.hibernate.reactive.panache.PanacheEntity</code>. It\u2019s the reactive variant of <code>import io.quarkus.hibernate.orm.panache.PanacheEntity</code>. As a consequence, methods are asynchronous, and instead of returning an object, they return asynchronous structure that will let you know when the object is ready to be consumed.</p>\n<p>The field part is the same as for the Villain. The <code>toString</code> method is also equivalent.</p>\n<p>The major difference is the <code>findRandom</code> method. Instead of returning a <code>Hero</code>, it returns a <code>Uni&lt;Hero</code>. A <code>Uni</code> represents an asynchronous action. Unlike with the imperative development model, we cannot block the thread waiting for the result. Here, we need to register a continuation invoked when the result is available. During that time, the thread is released and can be used to handle another request.</p>\n<p>Let\u2019s split the <code>findRandom</code> method to better understand what\u2019s going on:</p>\n<ol>\n<li>\n<p><code>count()</code> returns a <code>Uni&lt;Long&gt;</code> with the number of heroes stored in the database,</p>\n</li>\n<li>\n<p>when this count is retrieved from the database, it transforms the result into a random number,</p>\n</li>\n<li>\n<p>when this is computed, it chains the processing with another asynchronous action which retrieve the hero located at the random index.</p>\n</li>\n</ol>\n<p>As a consequence this method returns a <code>Uni&lt;Hero&gt;</code>. The consumer will need to register a continuation to receive the <code>Hero</code>.</p>"},{"location":"Super-Heroes-Workshop/#uni-api-in-2-minutes","title":"Uni API in 2 minutes","text":"<p>Uni comes from Mutiny, an intuitive, event-driven reactive programming library.</p>\n<p>There are a few method to understand to use <code>Uni</code>:</p>\n<ul>\n<li>\n<p><code>map</code> : transforms (synchronously) an item when this item becomes available.</p>\n</li>\n<li>\n<p><code>chain</code>: transforms an item, when it become available, into another <code>Uni</code>. The outcome will be the outcome of the produced <code>Uni</code>.</p>\n</li>\n<li>\n<p><code>replaceWith</code>: replaces an item with something else.</p>\n</li>\n<li>\n<p><code>invoke</code>: invokes the method when the item becomes available. It does not modify the item.</p>\n</li>\n</ul>\n<code>Uni</code> is lazy. To trigger the computation you need to subscribe to it. However, most of the time, Quarkus handles the subscription for us."},{"location":"Super-Heroes-Workshop/#the-hero-resource","title":"The Hero Resource","text":"<p>Unlike the <code>VillainResource</code>, the <code>HeroResource</code> uses the reactive development model. It returns asynchronous structures (<code>Uni</code>).</p>\n<p>Open the <code>HeroResource</code> and update the content to be:</p>\n<pre><code>package io.quarkus.workshop.superheroes.hero;\n\nimport io.quarkus.hibernate.reactive.panache.common.WithTransaction;\nimport io.smallrye.mutiny.Uni;\nimport org.eclipse.microprofile.openapi.annotations.Operation;\nimport org.eclipse.microprofile.openapi.annotations.enums.SchemaType;\nimport org.eclipse.microprofile.openapi.annotations.media.Content;\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\nimport org.eclipse.microprofile.openapi.annotations.responses.APIResponse;\nimport org.eclipse.microprofile.openapi.annotations.tags.Tag;\nimport org.jboss.logging.Logger;\nimport org.jboss.resteasy.reactive.RestPath;\nimport org.jboss.resteasy.reactive.RestResponse;\n\n\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\n\nimport java.net.URI;\nimport java.util.List;\n\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\n\n@Path(\"/api/heroes\")\n@Tag(name = \"heroes\")\npublic class HeroResource {\n\n    Logger logger;\n\n    public HeroResource(Logger logger) {\n        this.logger = logger;\n    }\n\n    @Operation(summary = \"Returns a random hero\")\n    @GET\n    @Path(\"/random\")\n    @APIResponse(responseCode = \"200\", content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Hero.class, required = true)))\n    public Uni&lt;RestResponse&lt;Hero&gt;&gt; getRandomHero() {\n        return Hero.findRandom()\n            .onItem().ifNotNull().transform(h -&gt; {\n                this.logger.debugf(\"Found random hero: %s\", h);\n                return RestResponse.ok(h);\n            })\n            .onItem().ifNull().continueWith(() -&gt; {\n                this.logger.debug(\"No random villain found\");\n                return RestResponse.notFound();\n            });\n    }\n\n    @Operation(summary = \"Returns all the heroes from the database\")\n    @GET\n    @APIResponse(responseCode = \"200\", content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Hero.class, type = SchemaType.ARRAY)))\n    public Uni&lt;List&lt;Hero&gt;&gt; getAllHeroes() {\n        return Hero.listAll();\n    }\n\n    @Operation(summary = \"Returns a hero for a given identifier\")\n    @GET\n    @Path(\"/{id}\")\n    @APIResponse(responseCode = \"200\", content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Hero.class)))\n    @APIResponse(responseCode = \"204\", description = \"The hero is not found for a given identifier\")\n    public Uni&lt;RestResponse&lt;Hero&gt;&gt; getHero(@RestPath Long id) {\n        return Hero.&lt;Hero&gt;findById(id)\n            .map(hero -&gt; {\n                if (hero != null) {\n                    return RestResponse.ok(hero);\n                }\n                logger.debugf(\"No Hero found with id %d\", id);\n                return RestResponse.noContent();\n            });\n    }\n\n    @Operation(summary = \"Creates a valid hero\")\n    @POST\n    @APIResponse(responseCode = \"201\", description = \"The URI of the created hero\", content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = URI.class)))\n    @WithTransaction\n    public Uni&lt;RestResponse&lt;URI&gt;&gt; createHero(@Valid Hero hero, @Context UriInfo uriInfo) {\n        return hero.&lt;Hero&gt;persist()\n            .map(h -&gt; {\n                UriBuilder builder = uriInfo.getAbsolutePathBuilder().path(Long.toString(h.id));\n                logger.debug(\"New Hero created with URI \" + builder.build().toString());\n                return RestResponse.created(builder.build());\n            });\n    }\n\n    @Operation(summary = \"Updates an exiting hero\")\n    @PUT\n    @APIResponse(responseCode = \"200\", description = \"The updated hero\", content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Hero.class)))\n    @WithTransaction\n    public Uni&lt;Hero&gt; updateHero(@Valid Hero hero) {\n        return Hero.&lt;Hero&gt;findById(hero.id)\n            .map(retrieved -&gt; {\n                retrieved.name = hero.name;\n                retrieved.otherName = hero.otherName;\n                retrieved.level = hero.level;\n                retrieved.picture = hero.picture;\n                retrieved.powers = hero.powers;\n                return retrieved;\n            })\n            .map(h -&gt; {\n                logger.debugf(\"Hero updated with new valued %s\", h);\n                return h;\n            });\n\n    }\n\n    @Operation(summary = \"Deletes an exiting hero\")\n    @DELETE\n    @Path(\"/{id}\")\n    @APIResponse(responseCode = \"204\")\n    @WithTransaction\n    public Uni&lt;RestResponse&lt;Void&gt;&gt; deleteHero(@RestPath Long id) {\n        return Hero.deleteById(id)\n            .invoke(() -&gt; logger.debugf(\"Hero deleted with %d\", id))\n            .replaceWith(RestResponse.noContent());\n    }\n\n    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello Hero Resource\";\n    }\n}\n</code></pre>\n<p>The resource implements the same HTTP API as the villain counterpart. It does not use a transactional service, but uses Panache method directly.</p>\n<p>As you can see, instead of returning the result directly, it returns <code>Uni&lt;T&gt;</code>. Quarkus retrieves the <code>Uni</code> and waits for the outcome to be available before writing the response. During that time, it can handle other requests.</p>\n<p>Notice also the <code>@WithTransaction</code>, which is the reactive variant of <code>@Transactional</code>.</p>"},{"location":"Super-Heroes-Workshop/#configuring-the-reactive-access-to-the-database","title":"Configuring the reactive access to the database","text":"<p>Configuring the reactive access to the database is relatively similar to configuring the JDBC url.</p>\n<p>Open the <code>application.properties</code> file and add:</p>\n<pre><code>## HTTP configuration\nquarkus.http.port=8083\n\n## Custom banner file path\nquarkus.banner.path=banner.txt\n\n# drop and create the database at startup (use `update` to only update the schema)\nquarkus.hibernate-orm.database.generation=drop-and-create\n\n%prod.quarkus.datasource.username=superman\n%prod.quarkus.datasource.password=superman\n%prod.quarkus.datasource.reactive.url=postgresql://localhost:5432/heroes_database\n%prod.quarkus.hibernate-orm.sql-load-script=import.sql\n</code></pre>\n<p>The prod profile contains the <code>%prod.quarkus.datasource.reactive.url</code> which configure the access to the database.</p>\n<p>We also set the port to be 8083.</p>"},{"location":"Super-Heroes-Workshop/#importing-heroes","title":"Importing heroes","text":"<p>Create the <code>src/main/resources/import.sql</code> and copy the content from import.sql.</p>\n<pre><code>ALTER SEQUENCE hero_seq RESTART WITH 50;\n\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Chewbacca', '', 'https://www.superherodb.com/pictures2/portraits/10/050/10466.jpg',\n        'Agility, Longevity, Marksmanship, Natural Weapons, Stealth, Super Strength, Weapons Master', 5);\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Angel Salvadore', 'Angel Salvadore Bohusk',\n        'https://www.superherodb.com/pictures2/portraits/10/050/1406.jpg',\n        'Animal Attributes, Animal Oriented Powers, Flight, Regeneration, Toxin and Disease Control', 4);\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Bill Harken', '', 'https://www.superherodb.com/pictures2/portraits/10/050/1527.jpg',\n        'Super Speed, Super Strength, Toxin and Disease Resistance', 6);\n...\n</code></pre>"},{"location":"Super-Heroes-Workshop/#testing-the-heroes","title":"Testing the heroes","text":"<p>Time for some tests! Open the <code>io.quarkus.workshop.superheroes.hero.HeroResourceTest</code> class and copy the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.hero;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.common.mapper.TypeRef;\nimport org.hamcrest.core.Is;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport static io.restassured.RestAssured.get;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.MediaType.TEXT_PLAIN;\nimport static jakarta.ws.rs.core.Response.Status.BAD_REQUEST;\nimport static jakarta.ws.rs.core.Response.Status.CREATED;\nimport static jakarta.ws.rs.core.Response.Status.NO_CONTENT;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n@QuarkusTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class HeroResourceTest {\n\n    private static final String JSON = \"application/json;charset=UTF-8\";\n\n    private static final String DEFAULT_NAME = \"Super Baguette\";\n    private static final String UPDATED_NAME = \"Super Baguette (updated)\";\n    private static final String DEFAULT_OTHER_NAME = \"Super Baguette Tradition\";\n    private static final String UPDATED_OTHER_NAME = \"Super Baguette Tradition (updated)\";\n    private static final String DEFAULT_PICTURE = \"super_baguette.png\";\n    private static final String UPDATED_PICTURE = \"super_baguette_updated.png\";\n    private static final String DEFAULT_POWERS = \"eats baguette really quickly\";\n    private static final String UPDATED_POWERS = \"eats baguette really quickly (updated)\";\n    private static final int DEFAULT_LEVEL = 42;\n    private static final int UPDATED_LEVEL = 43;\n\n    private static final int NB_HEROES = 941;\n    private static String heroId;\n\n    @Test\n    void shouldPingOpenAPI() {\n        given()\n            .header(ACCEPT, APPLICATION_JSON)\n            .when()\n            .get(\"/q/openapi\")\n            .then()\n            .statusCode(OK.getStatusCode());\n    }\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n            .header(ACCEPT, TEXT_PLAIN)\n            .when()\n            .get(\"/api/heroes/hello\")\n            .then()\n            .statusCode(200)\n            .body(is(\"Hello Hero Resource\"));\n    }\n\n    @Test\n    void shouldNotGetUnknownHero() {\n        Long randomId = new Random().nextLong();\n        given()\n            .pathParam(\"id\", randomId)\n            .when()\n            .get(\"/api/heroes/{id}\")\n            .then()\n            .statusCode(NO_CONTENT.getStatusCode());\n    }\n\n    @Test\n    void shouldGetRandomHero() {\n        given()\n            .when()\n            .get(\"/api/heroes/random\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON);\n    }\n\n    @Test\n    void shouldNotAddInvalidItem() {\n        Hero hero = new Hero();\n        hero.name = null;\n        hero.otherName = DEFAULT_OTHER_NAME;\n        hero.picture = DEFAULT_PICTURE;\n        hero.powers = DEFAULT_POWERS;\n        hero.level = 0;\n\n        given()\n            .body(hero)\n            .header(CONTENT_TYPE, APPLICATION_JSON)\n            .header(ACCEPT, APPLICATION_JSON)\n            .when()\n            .post(\"/api/heroes\")\n            .then()\n            .statusCode(BAD_REQUEST.getStatusCode());\n    }\n\n    @Test\n    @Order(1)\n    void shouldGetInitialItems() {\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                                              .statusCode(OK.getStatusCode())\n                                              .contentType(APPLICATION_JSON)\n                                              .extract()\n                                              .body()\n                                              .as(getHeroTypeRef());\n        assertEquals(NB_HEROES, heroes.size());\n    }\n\n    @Test\n    @Order(2)\n    void shouldAddAnItem() {\n        Hero hero = new Hero();\n        hero.name = DEFAULT_NAME;\n        hero.otherName = DEFAULT_OTHER_NAME;\n        hero.picture = DEFAULT_PICTURE;\n        hero.powers = DEFAULT_POWERS;\n        hero.level = DEFAULT_LEVEL;\n\n        String location = given()\n            .body(hero)\n            .header(CONTENT_TYPE, APPLICATION_JSON)\n            .header(ACCEPT, APPLICATION_JSON)\n            .when()\n            .post(\"/api/heroes\")\n            .then()\n            .statusCode(CREATED.getStatusCode())\n            .extract()\n            .header(\"Location\");\n        assertTrue(location.contains(\"/api/heroes\"));\n\n        // Stores the id\n        String[] segments = location.split(\"/\");\n        heroId = segments[segments.length - 1];\n        assertNotNull(heroId);\n\n        given()\n            .pathParam(\"id\", heroId)\n            .when()\n            .get(\"/api/heroes/{id}\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .body(\"name\", Is.is(DEFAULT_NAME))\n            .body(\"otherName\", Is.is(DEFAULT_OTHER_NAME))\n            .body(\"level\", Is.is(DEFAULT_LEVEL))\n            .body(\"picture\", Is.is(DEFAULT_PICTURE))\n            .body(\"powers\", Is.is(DEFAULT_POWERS));\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                                              .statusCode(OK.getStatusCode())\n                                              .extract()\n                                              .body()\n                                              .as(getHeroTypeRef());\n        assertEquals(NB_HEROES + 1, heroes.size());\n    }\n\n    @Test\n    @Order(3)\n    void shouldUpdateAnItem() {\n        Hero hero = new Hero();\n        hero.id = Long.valueOf(heroId);\n        hero.name = UPDATED_NAME;\n        hero.otherName = UPDATED_OTHER_NAME;\n        hero.picture = UPDATED_PICTURE;\n        hero.powers = UPDATED_POWERS;\n        hero.level = UPDATED_LEVEL;\n\n        given()\n            .body(hero)\n            .header(CONTENT_TYPE, APPLICATION_JSON)\n            .header(ACCEPT, APPLICATION_JSON)\n            .when()\n            .put(\"/api/heroes\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .body(\"name\", Is.is(UPDATED_NAME))\n            .body(\"otherName\", Is.is(UPDATED_OTHER_NAME))\n            .body(\"level\", Is.is(UPDATED_LEVEL))\n            .body(\"picture\", Is.is(UPDATED_PICTURE))\n            .body(\"powers\", Is.is(UPDATED_POWERS));\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                                              .statusCode(OK.getStatusCode())\n                                              .contentType(APPLICATION_JSON)\n                                              .extract()\n                                              .body()\n                                              .as(getHeroTypeRef());\n        assertEquals(NB_HEROES + 1, heroes.size());\n    }\n\n    @Test\n    @Order(4)\n    void shouldRemoveAnItem() {\n        given()\n            .pathParam(\"id\", heroId)\n            .when()\n            .delete(\"/api/heroes/{id}\")\n            .then()\n            .statusCode(NO_CONTENT.getStatusCode());\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                                              .statusCode(OK.getStatusCode())\n                                              .contentType(APPLICATION_JSON)\n                                              .extract()\n                                              .body()\n                                              .as(getHeroTypeRef());\n        assertEquals(NB_HEROES, heroes.size());\n    }\n\n    private TypeRef&lt;List&lt;Hero&gt;&gt; getHeroTypeRef() {\n        return new TypeRef&lt;List&lt;Hero&gt;&gt;() {\n            // Kept empty on purpose\n        };\n    }\n}\n</code></pre>\n<p>The tests are very similar to the ones from the villain service.</p>"},{"location":"Super-Heroes-Workshop/#running-testing-and-packaging-the-application","title":"Running, Testing and Packaging the Application","text":"<p>First, make sure the tests pass by executing the command <code>./mvnw test</code> (or from your IDE).</p>\n<p>Now that the tests are green, we are ready to run our application.</p>\n<p>Use <code>./mvnw quarkus:dev</code> to start it. Once the application is started, create a new hero with the following cUrl command:</p>\n<pre><code>curl -X POST -d  '{\"level\":2, \"name\":\"Super level\", \"powers\":\"leaping\"}'  -H \"Content-Type: application/json\" http://localhost:8083/api/heroes -v\n</code></pre>\n<p>Thanks to the verbose mode (<code>-v</code>) you should see a similar output:</p>\n<pre><code>&lt; HTTP/1.1 201 Created\n&lt; Location: http://localhost:8083/api/heroes/952\n</code></pre>\n<p>The cUrl command returns the location of the newly created hero. Take this URL and do an HTTP GET on it.</p>\n<p>The example shows a newly created Hero with id <code>952</code>. But this id could be different on your machine. Just make sure to use the correct id in the next command.</p>\n\n<pre><code>curl http://localhost:8083/api/heroes/952 | jq\n</code></pre>\n<pre><code>{\n  \"id\": 952,\n  \"name\": \"Super level\",\n  \"otherName\": null,\n  \"level\": 2,\n  \"picture\": null,\n  \"powers\": \"leaping\"\n}\n</code></pre>\n<p>Then, build the application using: <code>./mvnw package</code>, and run the application using <code>java -jar target/quarkus-app/quarkus-run.jar</code>. Open your browser and go to http://localhost:8083/api/heroes.</p>"},{"location":"Super-Heroes-Workshop/#from-microservice-to-microservices","title":"From Microservice to Microservices","text":"<p>So far we\u2019ve built two microservices: the villains and heroes microservices. In the following sections you will develop an extra microservice: a fight microservice where heroes and villains fight. We will also add a React front-end, so we can fight graphically. But as you can notice in the diagram below, these microservices still not communicate with each other. You will have to wait the next chapter for that ;o)</p>\n<p></p>\n<p>Each microservice is developed in its own directory.</p>\n<p></p>\n<p>In the following sections, you will:</p>\n<ul>\n<li>\n<p>Create a new Quarkus application</p>\n</li>\n<li>\n<p>Implement REST API using JAX-RS</p>\n</li>\n<li>\n<p>Access your database using Hibernate ORM with Panache</p>\n</li>\n<li>\n<p>Use transactions</p>\n</li>\n</ul>\nThis service is exposed on the port 8082."},{"location":"Super-Heroes-Workshop/#fight-microservice","title":"Fight Microservice","text":"<p>Ok, let\u2019s develop another microservice. We have a REST API that returns a random Hero. Another REST API that returns a random Villain\u2026 we need a new REST API that invokes those two, gets one random hero and one random villain and makes them fight. Let\u2019s call it the Fight API.</p>\nThis microservice uses the imperative development model but use reactive extensions."},{"location":"Super-Heroes-Workshop/#bootstrapping-the-fight-rest-endpoint","title":"Bootstrapping the Fight REST Endpoint","text":"<p>Like for the Hero and Villain API, the easiest way to create this new Quarkus project is to use a Maven archetype. Under the <code>quarkus-workshop-super-heroes/super-heroes</code> root directory where you have all your code.</p>\n<p>Open a terminal and run the following command:</p>\n<pre><code>./mvnw io.quarkus:quarkus-maven-plugin:3.9.1:create -\"DplatformVersion=3.9.1\" -\"DprojectGroupId=io.quarkus.workshop.super-heroes\" -\"DprojectArtifactId=rest-fights\" -DclassName=\"io.quarkus.workshop.superheroes.fight.FightResource\" -Dpath=\"api/fights\"  -Dextensions=\"jdbc-postgresql,hibernate-orm-panache,hibernate-validator,quarkus-rest-jackson,smallrye-openapi,kafka\"\n</code></pre>\n<p>If you open the <code>pom.xml</code> file, you will see that the following extensions have been imported:</p>\n<ul>\n<li>\n<p><code>io.quarkus:quarkus-hibernate-orm-panache</code></p>\n</li>\n<li>\n<p><code>io.quarkus:quarkus-hibernate-validator</code></p>\n</li>\n<li>\n<p><code>io.quarkus:quarkus-smallrye-openapi</code></p>\n</li>\n<li>\n<p><code>io.quarkus:quarkus-messaging-kafka</code></p>\n</li>\n<li>\n<p><code>io.quarkus:quarkus-rest-jackson</code></p>\n</li>\n<li>\n<p><code>io.quarkus:quarkus-jdbc-postgresql</code></p>\n</li>\n</ul>\n<p>You can see that beyond the extensions we have used so far, we added the Kafka support which uses Eclipse MicroProfile Reactive Messaging. Stay tuned.</p>\n<p>The Quarkus Maven plugin has generated some code that we won\u2019t be using. You can delete the Java classes <code>MyReactiveMessagingApplication</code> and <code>MyReactiveMessagingApplicationTest</code>.</p>\n<p>If you want your IDE to manage this new Maven project, you can declare it in the parent POM by adding this new module in the <code>&lt;modules&gt;</code> section:</p>\n<pre><code>&lt;module&gt;super-heroes/rest-fights&lt;/module&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#directory-structure_5","title":"Directory Structure","text":"<p>At the end you should have the following directory structure:</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#fight-entity","title":"Fight Entity","text":"<p>A fight is between a hero and a villain. Each time there is a fight, there is a winner and a loser. So the <code>Fight</code> entity is there to store all these fights.</p>\n<p>Create the <code>io.quarkus.workshop.superheroes.fight.Fight</code> class with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight;\n\nimport io.quarkus.hibernate.orm.panache.PanacheEntity;\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.validation.constraints.NotNull;\n\nimport java.time.Instant;\n\n@Entity\n@Schema(description = \"Each fight has a winner and a loser\")\npublic class Fight extends PanacheEntity {\n\n    @NotNull\n    public Instant fightDate;\n    @NotNull\n    public String winnerName;\n    @NotNull\n    public int winnerLevel;\n    @NotNull\n    @Column(columnDefinition = \"TEXT\")\n    public String winnerPowers;\n    @NotNull\n    public String winnerPicture;\n    @NotNull\n    public String loserName;\n    @NotNull\n    public int loserLevel;\n    @NotNull\n    @Column(columnDefinition = \"TEXT\")\n    public String loserPowers;\n    @NotNull\n    public String loserPicture;\n    @NotNull\n    public String winnerTeam;\n    @NotNull\n    public String loserTeam;\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#fighters-bean","title":"Fighters Bean","text":"<p>Now comes a trick. The Fight REST API will ultimately invoke the Hero and Villain APIs (next sections) to get two random fighters. The <code>Fighters</code> class has one <code>Hero</code> and one <code>Villain</code>. Notice that <code>Fighters</code> is not an entity, it is not persisted in the database, just marshalled and unmarshalled to JSon.</p>\n<p>Create the <code>io.quarkus.workshop.superheroes.fight.Fighters</code> class, with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight;\n\nimport io.quarkus.workshop.superheroes.fight.client.Hero;\nimport io.quarkus.workshop.superheroes.fight.client.Villain;\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\n\nimport jakarta.validation.constraints.NotNull;\n\n@Schema(description = \"A fight between one hero and one villain\")\npublic class Fighters {\n\n    @NotNull\n    public Hero hero;\n    @NotNull\n    public Villain villain;\n\n}\n</code></pre>\n<p>It does not compile because it needs a <code>Hero</code> class and a <code>Villain</code> class. The Fight REST API is just interested in the hero\u2019s name, level, picture and powers (not the other name as described in the Hero API).</p>\n<p>So create the <code>Hero</code> bean looks like this (notice the <code>client</code> subpackage):</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\n\nimport jakarta.validation.constraints.NotNull;\n\n@Schema(description = \"The hero fighting against the villain\")\npublic class Hero {\n\n    @NotNull\n    public String name;\n    @NotNull\n    public int level;\n    @NotNull\n    public String picture;\n    public String powers;\n\n}\n</code></pre>\n<p>Also create the <code>Villain</code> counterpart (also in the <code>client</code> subpackage):</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\n\nimport jakarta.validation.constraints.NotNull;\n\n@Schema(description = \"The villain fighting against the hero\")\npublic class Villain {\n\n    @NotNull\n    public String name;\n    @NotNull\n    public int level;\n    @NotNull\n    public String picture;\n    public String powers;\n\n}\n</code></pre>\n<p>So, these classes are just used to map the results from the <code>Hero</code> and <code>Villain</code> microservices.</p>"},{"location":"Super-Heroes-Workshop/#fightservice-transactional-service","title":"FightService Transactional Service","text":"<p>Now, let\u2019s create a <code>FightService</code> class that orchestrate the fights.</p>\n<p>Create the <code>io.quarkus.workshop.superheroes.fight.FightService</code> class with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.transaction.Transactional;\n\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Random;\n\nimport static jakarta.transaction.Transactional.TxType.REQUIRED;\nimport static jakarta.transaction.Transactional.TxType.SUPPORTS;\n\n@ApplicationScoped\n@Transactional(SUPPORTS)\npublic class FightService {\n\n    @Inject Logger logger;\n\n    private final Random random = new Random();\n\n    public List&lt;Fight&gt; findAllFights() {\n        return Fight.listAll();\n    }\n\n    public Fight findFightById(Long id) {\n        return Fight.findById(id);\n    }\n\n    public Fighters findRandomFighters() {\n        // Will be implemented later\n        return null;\n    }\n\n    @Transactional(REQUIRED)\n    public Fight persistFight(Fighters fighters) {\n        // Amazingly fancy logic to determine the winner...\n        Fight fight;\n\n        int heroAdjust = random.nextInt(20);\n        int villainAdjust = random.nextInt(20);\n\n        if ((fighters.hero.level + heroAdjust)\n            &gt; (fighters.villain.level + villainAdjust)) {\n            fight = heroWon(fighters);\n        } else if (fighters.hero.level &lt; fighters.villain.level) {\n            fight = villainWon(fighters);\n        } else {\n            fight = random.nextBoolean() ? heroWon(fighters) : villainWon(fighters);\n        }\n\n        fight.fightDate = Instant.now();\n        fight.persist();\n\n        return fight;\n    }\n\n    private Fight heroWon(Fighters fighters) {\n        logger.info(\"Yes, Hero won :o)\");\n        Fight fight = new Fight();\n        fight.winnerName = fighters.hero.name;\n        fight.winnerPicture = fighters.hero.picture;\n        fight.winnerLevel = fighters.hero.level;\n        fight.winnerPowers = fighters.hero.powers;\n        fight.loserName = fighters.villain.name;\n        fight.loserPicture = fighters.villain.picture;\n        fight.loserLevel = fighters.villain.level;\n        fight.loserPowers = fighters.villain.powers;\n        fight.winnerTeam = \"heroes\";\n        fight.loserTeam = \"villains\";\n        return fight;\n    }\n\n    private Fight villainWon(Fighters fighters) {\n        logger.info(\"Gee, Villain won :o(\");\n        Fight fight = new Fight();\n        fight.winnerName = fighters.villain.name;\n        fight.winnerPicture = fighters.villain.picture;\n        fight.winnerLevel = fighters.villain.level;\n        fight.winnerPowers = fighters.villain.powers;\n        fight.loserName = fighters.hero.name;\n        fight.loserPicture = fighters.hero.picture;\n        fight.loserLevel = fighters.hero.level;\n        fight.loserPowers = fighters.hero.powers;\n        fight.winnerTeam = \"villains\";\n        fight.loserTeam = \"heroes\";\n        return fight;\n    }\n\n}\n</code></pre>\n<p>Notice the <code>persistFight</code> method. This method is the one creating a fight between a hero and a villain. As you can see the algorithm to determine the winner is a bit random (even though it uses the levels). If you are not happy about the way the fight operates, choose your own winning algorithm ;o)</p>\n<p>For now, the <code>Fighters findRandomFighters()</code> method returns null. Later, this method will invoke the Hello and Villain API to get a random Hero and random Villain.</p>"},{"location":"Super-Heroes-Workshop/#fightresource-endpoint","title":"FightResource Endpoint","text":"<p>To expose a REST API we also need a <code>FightResource</code> (with OpenAPI annotations of course).</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight;\n\nimport jakarta.ws.rs.*;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\nimport org.jboss.logging.Logger;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.core.UriInfo;\n\nimport java.util.List;\n\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.MediaType.TEXT_PLAIN;\n\n@Path(\"/api/fights\")\n@Produces(APPLICATION_JSON)\n@ApplicationScoped\npublic class FightResource {\n\n    @Inject\n    Logger logger;\n\n    @Inject\n    FightService service;\n\n\n    @GET\n    @Path(\"/randomfighters\")\n    public Response getRandomFighters() {\n        Fighters fighters = service.findRandomFighters();\n        logger.debug(\"Get random fighters \" + fighters);\n        return Response.ok(fighters).build();\n    }\n\n    @GET\n    public Response getAllFights() {\n        List&lt;Fight&gt; fights = service.findAllFights();\n        logger.debug(\"Total number of fights \" + fights);\n        return Response.ok(fights).build();\n    }\n\n    @GET\n    @Path(\"/{id}\")\n    public Response getFight(Long id) {\n        Fight fight = service.findFightById(id);\n        if (fight != null) {\n            logger.debug(\"Found fight \" + fight);\n            return Response.ok(fight).build();\n        } else {\n            logger.debug(\"No fight found with id \" + id);\n            return Response.noContent().build();\n        }\n    }\n\n    @POST\n    public Fight fight(@Valid Fighters fighters, UriInfo uriInfo) {\n        return service.persistFight(fighters);\n    }\n\n    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello Fight Resource\";\n    }\n\n}\n</code></pre>\n<p>The OpenAPI annotations have been omitted to keep the service focused on the task. Feel free to add them if you want complete OpenAPI descriptors.</p><p>Notice that most of the REST endpoints that you\u2019ve seen so far produce or consume JSON. JSON being the default media type in Quarkus, we could have omitted the <code>@Produces</code> or <code>@Consume</code> annotation.</p>"},{"location":"Super-Heroes-Workshop/#adding-data_1","title":"Adding Data","text":"<p>To load some SQL statements when Hibernate ORM starts, create the <code>src/main/resources/import.sql</code> file with the following content:</p>\n<pre><code>ALTER SEQUENCE fight_seq RESTART WITH 50;\n\nINSERT INTO fight(id, fightDate, winnerName, winnerLevel, winnerPicture, winnerPowers, loserName, loserLevel, loserPicture, loserPowers, winnerTeam, loserTeam)\nVALUES (nextval('fight_seq'), current_timestamp,\n        'Chewbacca', 5, 'https://www.superherodb.com/pictures2/portraits/10/050/10466.jpg', 'Agility, Longevity, Marksmanship, Natural Weapons, Stealth, Super Strength, Weapons Master',\n        'Buuccolo', 3, 'https://www.superherodb.com/pictures2/portraits/10/050/15355.jpg', 'Accelerated Healing, Adaptation, Agility, Flight, Immortality, Intelligence, Invulnerability, Reflexes, Self-Sustenance, Size Changing, Spatial Awareness, Stamina, Stealth, Super Breath, Super Speed, Super Strength, Teleportation',\n        'heroes', 'villains');\nINSERT INTO fight(id, fightDate, winnerName, winnerLevel, winnerPicture, winnerPowers, loserName, loserLevel, loserPicture, loserPowers, winnerTeam, loserTeam)\nVALUES (nextval('fight_seq'), current_timestamp,\n        'Galadriel', 10, 'https://www.superherodb.com/pictures2/portraits/10/050/11796.jpg', 'Danger Sense, Immortality, Intelligence, Invisibility, Magic, Precognition, Telekinesis, Telepathy',\n        'Darth Vader', 8, 'https://www.superherodb.com/pictures2/portraits/10/050/10444.jpg', 'Accelerated Healing, Agility, Astral Projection, Cloaking, Danger Sense, Durability, Electrokinesis, Energy Blasts, Enhanced Hearing, Enhanced Senses, Force Fields, Hypnokinesis, Illusions, Intelligence, Jump, Light Control, Marksmanship, Precognition, Psionic Powers, Reflexes, Stealth, Super Speed, Telekinesis, Telepathy, The Force, Weapons Master',\n        'heroes', 'villains');\nINSERT INTO fight(id, fightDate, winnerName, winnerLevel, winnerPicture, winnerPowers, loserName, loserLevel, loserPicture, loserPowers, winnerTeam, loserTeam)\nVALUES (nextval('fight_seq'), current_timestamp,\n        'Annihilus', 23, 'https://www.superherodb.com/pictures2/portraits/10/050/1307.jpg', 'Agility, Durability, Flight, Reflexes, Stamina, Super Speed, Super Strength',\n        'Shikamaru', 1, 'https://www.superherodb.com/pictures2/portraits/10/050/11742.jpg', 'Adaptation, Agility, Element Control, Fire Control, Intelligence, Jump, Marksmanship, Possession, Reflexes, Shapeshifting, Stamina, Stealth, Telekinesis, Wallcrawling, Weapon-based Powers, Weapons Master',\n        'villains', 'heroes');\n</code></pre>"},{"location":"Super-Heroes-Workshop/#configuration","title":"Configuration","text":"<p>As usual, we need to configure the application.</p>\n<p>In the <code>application.properties</code> file add:</p>\n<pre><code>## HTTP configuration\nquarkus.http.port=8082\n\n## Custom banner file path\nquarkus.banner.path=banner.txt\n\n## drop and create the database at startup (use `update` to only update the schema)\nquarkus.hibernate-orm.database.generation=drop-and-create\n\n## Logging configuration\nquarkus.log.console.enable=true\nquarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n\nquarkus.log.console.level=DEBUG\n\n## Production configuration\n%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/fights_database\n%prod.quarkus.datasource.db-kind=postgresql\n%prod.quarkus.datasource.username=superfight\n%prod.quarkus.datasource.password=superfight\n%prod.quarkus.hibernate-orm.sql-load-script=import.sql\n%prod.quarkus.log.console.level=INFO\n%prod.quarkus.hibernate-orm.database.generation=update\n\n\n\n## Kafka configuration\n</code></pre>\n<p>Note that the fight service uses the port <code>8082</code>.</p>"},{"location":"Super-Heroes-Workshop/#fightresourcetest-test-class","title":"FightResourceTest Test Class","text":"<p>We need to test our REST API.</p>\n<p>For that, copy the following <code>FightResourceTest</code> class under the <code>src/test/java/io/quarkus/workshop/superheroes/fight</code> directory.</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.quarkus.workshop.superheroes.fight.client.Hero;\nimport io.quarkus.workshop.superheroes.fight.client.Villain;\nimport io.restassured.common.mapper.TypeRef;\nimport org.hamcrest.core.Is;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\nimport java.util.List;\n\nimport java.util.Random;\nimport static io.restassured.RestAssured.get;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.Response.Status.*;\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n@QuarkusTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class FightResourceTest {\n\n    private static final String DEFAULT_WINNER_NAME = \"Super Baguette\";\n    private static final String DEFAULT_WINNER_PICTURE = \"super_baguette.png\";\n    private static final int DEFAULT_WINNER_LEVEL = 42;\n    private static final String DEFAULT_WINNER_POWERS = \"Eats baguette in less than a second\";\n    private static final String DEFAULT_LOSER_NAME = \"Super Chocolatine\";\n    private static final String DEFAULT_LOSER_PICTURE = \"super_chocolatine.png\";\n    private static final int DEFAULT_LOSER_LEVEL = 6;\n    private static final String DEFAULT_LOSER_POWERS = \"Transforms chocolatine into pain au chocolat\";\n\n    private static final int NB_FIGHTS = 3;\n    private static String fightId;\n\n    @Test\n    void shouldPingOpenAPI() {\n        given()\n            .header(ACCEPT, APPLICATION_JSON)\n            .when().get(\"/q/openapi\")\n            .then()\n            .statusCode(OK.getStatusCode());\n    }\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n            .when().get(\"/api/fights/hello\")\n            .then()\n            .statusCode(200)\n            .body(is(\"Hello Fight Resource\"));\n    }\n\n    @Test\n    void shouldNotGetUnknownFight() {\n        Long randomId = new Random().nextLong();\n        given()\n            .pathParam(\"id\", randomId)\n            .when().get(\"/api/fights/{id}\")\n            .then()\n            .statusCode(NO_CONTENT.getStatusCode());\n    }\n\n    @Test\n    void shouldNotAddInvalidItem() {\n        Fighters fighters = new Fighters();\n        fighters.hero = null;\n        fighters.villain = null;\n\n        given()\n            .body(fighters)\n            .header(CONTENT_TYPE, APPLICATION_JSON)\n            .header(ACCEPT, APPLICATION_JSON)\n            .when()\n            .post(\"/api/fights\")\n            .then()\n            .statusCode(BAD_REQUEST.getStatusCode());\n    }\n\n    @Test\n    @Order(1)\n    void shouldGetInitialItems() {\n        List&lt;Fight&gt; fights = get(\"/api/fights\").then()\n            .statusCode(OK.getStatusCode())\n            .extract().body().as(getFightTypeRef());\n        assertEquals(NB_FIGHTS, fights.size());\n    }\n\n    @Test\n    @Order(2)\n    void shouldAddAnItem() {\n        Hero hero = new Hero();\n        hero.name = DEFAULT_WINNER_NAME;\n        hero.picture = DEFAULT_WINNER_PICTURE;\n        hero.level = DEFAULT_WINNER_LEVEL;\n        hero.powers = DEFAULT_WINNER_POWERS;\n        Villain villain = new Villain();\n        villain.name = DEFAULT_LOSER_NAME;\n        villain.picture = DEFAULT_LOSER_PICTURE;\n        villain.level = DEFAULT_LOSER_LEVEL;\n        villain.powers = DEFAULT_LOSER_POWERS;\n        Fighters fighters = new Fighters();\n        fighters.hero = hero;\n        fighters.villain = villain;\n\n        fightId = given()\n            .body(fighters)\n            .header(CONTENT_TYPE, APPLICATION_JSON)\n            .header(ACCEPT, APPLICATION_JSON)\n            .when()\n            .post(\"/api/fights\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .body(containsString(\"winner\"), containsString(\"loser\"))\n            .extract().body().jsonPath().getString(\"id\");\n\n        assertNotNull(fightId);\n\n        given()\n            .pathParam(\"id\", fightId)\n            .when().get(\"/api/fights/{id}\")\n            .then()\n            .statusCode(OK.getStatusCode())\n            .contentType(APPLICATION_JSON)\n            .body(\"winnerName\", Is.is(DEFAULT_WINNER_NAME))\n            .body(\"winnerPicture\", Is.is(DEFAULT_WINNER_PICTURE))\n            .body(\"winnerLevel\", Is.is(DEFAULT_WINNER_LEVEL))\n            .body(\"winnerPowers\", Is.is(DEFAULT_WINNER_POWERS))\n            .body(\"loserName\", Is.is(DEFAULT_LOSER_NAME))\n            .body(\"loserPicture\", Is.is(DEFAULT_LOSER_PICTURE))\n            .body(\"loserLevel\", Is.is(DEFAULT_LOSER_LEVEL))\n            .body(\"loserPowers\", Is.is(DEFAULT_LOSER_POWERS))\n            .body(\"fightDate\", Is.is(notNullValue()));\n\n        List&lt;Fight&gt; fights = get(\"/api/fights\").then()\n            .statusCode(OK.getStatusCode())\n            .extract().body().as(getFightTypeRef());\n        assertEquals(NB_FIGHTS + 1, fights.size());\n    }\n\n    private TypeRef&lt;List&lt;Fight&gt;&gt; getFightTypeRef() {\n        return new TypeRef&lt;List&lt;Fight&gt;&gt;() {\n            // Kept empty on purpose\n        };\n    }\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#running-testing-and-packaging-the-application_1","title":"Running, Testing and Packaging the Application","text":"<p>First, delete the generated <code>FightResourceIT</code> native test class, as we won\u2019t run native tests. Then, make sure the tests pass by executing the command <code>./mvnw test</code> (or from your IDE). Quarkus automatically starts the PostGreSQL database.</p>\n<p>Now that the tests are green, we are ready to run our application. Use <code>./mvnw quarkus:dev</code> to start it (notice that there is no banner yet, it will come later). Once the application is started, just check that it returns the fights from the database with the following cURL command:</p>\n<pre><code>curl http://localhost:8082/api/fights\n</code></pre>"},{"location":"Super-Heroes-Workshop/#user-interface","title":"User Interface","text":"<p>Now that we have the three main microservices, time to have a decent user interface to start fighting. The purpose of this workshop is not to develop a web interface and learn yet another web framework. This time you will just execute another Quarkus instance with an already React application. We will be using Quinoa to handle building and serving the React application.</p>"},{"location":"Super-Heroes-Workshop/#quinoa","title":"Quinoa?","text":"<p>Quinoa is a Quarkus extension which eases the development of single page apps or web components. It lets you live code the backend and frontend together with close to no configuration. It also helps with both packaging and serving, and if you want it to, abstracts away <code>npm</code>.</p>\n<p>When enabled in development mode, Quinoa will start the UI live coding server provided by the target framework and forward relevant requests to it. In production mode, Quinoa will run the build and process the generated files to serve them at runtime.</p>\n<p>Quinoa is framework-agnostic, and works with React, Angular, Vue, Lit, and others, alongside other Quarkus services (REST, GraphQL, Security, Events, etc).</p>"},{"location":"Super-Heroes-Workshop/#the-web-application","title":"The Web Application","text":"<p>Navigate to the <code>super-heroes/ui-super-heroes</code> directory. It contains the code of the application.</p>\n<p>The React application is in <code>src/main/webui</code>. Being a React application, you will find a <code>package.json</code> file which defines all the needed dependencies. All the React code (graphical components, model, services) is located under <code>src/main/webui/src/app</code>.</p>"},{"location":"Super-Heroes-Workshop/#running-the-web-application","title":"Running the Web Application","text":"<p>We don\u2019t need to worry too much about the React code.</p>\n<p>From the <code>ui-super-heroes</code> directory, use <code>./mvnw quarkus:dev</code> to start the web application.</p>\n<p>Be sure you have the hero, villain and fights microservices running (dev mode is enough).</p>\n<p>If you don\u2019t have Node installed, Quinoa will install it during the start process (under the <code>.quinoa</code> directory).</p>\n<pre><code>INFO  [com.git.eir.mav.plu.fro.lib.NodeInstaller] (build-40) Installing node version v16.16.0\nINFO  [com.git.eir.mav.plu.fro.lib.NodeInstaller] (build-40) Extracting NPM\nINFO  [com.git.eir.mav.plu.fro.lib.NodeInstaller] (build-40) Installed node locally.\n</code></pre>\n<p>You should see console output like the following</p>\n<pre><code>2023-05-18 14:22:02,745 INFO  [io.qua.qui.dep.ForwardedDevProcessor] (build-5) Quinoa package manager live coding is up and running on port: 3000 (in 18118ms)\n2023-05-18 14:22:02,749 INFO  [io.qua.qui.dep.ForwardedDevProcessor] (build-40) Quinoa is forwarding unhandled requests to port: 3000\n__  ____  __  _____   ___  __ ____  ______\n --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\\n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n2023-05-18 14:22:03,237 INFO  [io.quarkus] (Quarkus Main Thread) ui-super-heroes 1.0.0-SNAPSHOT on JVM (powered by Quarkus 3.9.1) started in 24.765s. Listening on: http://localhost:8080\n</code></pre>\n<p>Once the application is started, go to http://localhost:8080 (8080 is the default Quarkus port as we didn\u2019t change it in the <code>application.properties</code> this time). It should display a main web page. There won\u2019t be much content yet, because we need to fix a few things and add some more implementation.</p>\n<p></p>\n<p>If you want, you can visit http://localhost:3000 (the usual React port) to confirm that Quinoa is forwarding what\u2019s on port 3000 to port 8080. The version of the application on http://localhost:3000 will always stay disappointingly blank, because it\u2019s looking for its config on the wrong port. So don\u2019t use that one!</p>\n<p>You might want to create a fuller Quarkus BFF for the UI, and use something like Stork for service discovery. However, that\u2019s beyond the scope of this workshop!</p>"},{"location":"Super-Heroes-Workshop/#live-coding-the-ui","title":"Live coding the UI","text":"<p>Live coding works for the javascript parts of the application, just as it does for the Java ones.</p>\n<p>Open <code>src/main/webui/src/app/app.component.html</code> and edit the text, perhaps by adding 'Hello there' into the welcome message. Check localhost:8080, and your new content should appear. (It may take a moment or two for the refresh to trigger.)</p>\n<p>You can also change the javascript code. For example, try updating the text in <code>src/main/webui/src/app/app.component.ts</code>.</p>"},{"location":"Super-Heroes-Workshop/#cors","title":"CORS","text":"<p>Cross-origin resource sharing (CORS) is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served. So when we want our heroes and villains to fight, we actually cross several origins: we go from localhost:8080 (the UI) to localhost:8082 (Fight API) which invokes localhost:8083 (Hero) and localhost:8084 (Villain). If you look at the console of your Browser you should see something similar to this:</p>\n<p></p>\n<p>Quarkus comes with a CORS filter which intercepts all incoming HTTP requests. It can be enabled in the Quarkus configuration file:</p>\n<p>If the filter is enabled and an HTTP request is identified as cross-origin, the CORS policy and headers defined using the following properties will be applied before passing the request on to its actual target (servlet, JAX-RS resource, etc.):</p>\n\n\n\nProperty\nDescription\n\n\n\n\n<code>quarkus.http.cors.origins</code>\nThe comma-separated list of origins allowed for CORS. The filter allows any origin if this is not set.\n\n\n<code>quarkus.http.cors.methods</code>\nThe comma-separated list of HTTP methods allowed for CORS. The filter allows any method if this is not set.\n\n\n<code>quarkus.http.cors.headers</code>\nThe comma-separated list of HTTP headers allowed for CORS. The filter allows any header if this is not set.\n\n\n<code>quarkus.http.cors.exposed-headers</code>\nThe comma-separated list of HTTP headers exposed in CORS.\n\n\n<code>quarkus.http.cors.access-control-max-age</code>\nThe duration indicating how long the results of a pre-flight request can be cached. This value will be returned in a Access-Control-Max-Age response header.\n\n\n\n<p>So make sure you set the following properties on the:</p>\n<ul>\n<li>\n<p>Fight microservice,</p>\n</li>\n<li>\n<p>Hero microservice,</p>\n</li>\n<li>\n<p>Villain microservice</p>\n</li>\n</ul>\n<pre><code>quarkus.http.cors=true\nquarkus.http.cors.origins=/.*/\n</code></pre>\n<p>But, even with this, the UI is still not working. The CORS errors are gone, so that\u2019s a good step, but we forgot something else:</p>\n<p></p>\n<p>Remember the function to retrieve random fighters. We are currently returning <code>null</code>. Let\u2019s move to the next session to see how we can implement this method.</p>"},{"location":"Super-Heroes-Workshop/#http-communication-fault-tolerance","title":"HTTP communication &amp; Fault Tolerance","text":"<p>So far we\u2019ve built one Fight microservice which need to invoke the Hero and Villain microservices. In the following sections you will develop this invocation thanks to the MicroProfile REST Client. We will also deal with fault tolerance thanks to timeouts and circuit breaker.</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#rest-client","title":"REST Client","text":"<p>This chapter explains how to use the MicroProfile REST Client in order to interact with REST APIs with very little effort.</p>"},{"location":"Super-Heroes-Workshop/#directory-structure_6","title":"Directory Structure","text":"<p>Remember the structure of the Fight microservice:</p>\n<p></p>\n<p>We are going to rework the:</p>\n<ul>\n<li>\n<p><code>FightService</code> class</p>\n</li>\n<li>\n<p><code>FightResourceTest</code> class</p>\n</li>\n<li>\n<p><code>application.properties</code></p>\n</li>\n</ul>"},{"location":"Super-Heroes-Workshop/#installing-the-reactive-rest-client-dependency","title":"Installing the Reactive REST Client Dependency","text":"<p>To install the Reactive REST Client dependency, just run the following command in the Fight microservice:</p>\n<pre><code>./mvnw quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-rest-client-jackson\"\n</code></pre>\n<p>This will add the following dependency in the <code>pom.xml</code> file:</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-rest-client-jackson&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>This dependency imports both the reactive rest client implementation and the JSON mapping support (which uses Jackson).</p>"},{"location":"Super-Heroes-Workshop/#fightservice-invoking-external-microservices","title":"FightService Invoking External Microservices","text":"<p>Remember that in the previous sections we left the <code>FightService.findRandomFighters()</code> method returns <code>null</code>. We have to fix this. What we actually want is to invoke both the Hero and Villain APIs, asking for a random hero and a random villain.</p>\n<p>For that, replace the <code>findRandomFighters</code> method with the following code to the <code>FightService</code> class:</p>\n<pre><code>@RestClient HeroProxy heroProxy;\n@RestClient VillainProxy villainProxy;\n\n// ...\n\nFighters findRandomFighters() {\n    Hero hero = findRandomHero();\n    Villain villain = findRandomVillain();\n    Fighters fighters = new Fighters();\n    fighters.hero = hero;\n    fighters.villain = villain;\n    return fighters;\n}\n\nVillain findRandomVillain() {\n    return villainProxy.findRandomVillain();\n}\n\nHero findRandomHero() {\n   return heroProxy.findRandomHero();\n}\n</code></pre>\n<p>Note the Rest client injection. They use the <code>@RestClient</code> qualifier, i.e. a bean selector. With Quarkus, when you use a qualifier, you can omit <code>@Inject</code>.</p>\n<p>If not done automatically by your IDE, add the following import statement: <code>import org.eclipse.microprofile.rest.client.inject.RestClient;</code></p>"},{"location":"Super-Heroes-Workshop/#creating-the-interfaces","title":"Creating the Interfaces","text":"<p>Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations.</p>\n<p>In our case both interfaces should be created under the <code>client</code> subpackage and have the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\nimport org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\n\n@Path(\"/api/heroes\")\n@Produces(MediaType.APPLICATION_JSON)\n@RegisterRestClient(configKey = \"hero\")\npublic interface HeroProxy {\n\n    @GET\n    @Path(\"/random\")\n    Hero findRandomHero();\n}\n</code></pre>\n<p>The <code>findRandomHero</code> method gives our code the ability to query a random hero from the Hero REST API. The client will handle all the networking and marshalling leaving our code clean of such technical details.</p>\n<p>The purpose of the annotations in the code above is the following:</p>\n<ul>\n<li>\n<p><code>@RegisterRestClient</code> allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client</p>\n</li>\n<li>\n<p><code>@Path</code> and <code>@GET</code> are the standard JAX-RS annotations used to define how to access the service</p>\n</li>\n<li>\n<p><code>@Produces</code> defines the expected content-type</p>\n</li>\n</ul>\n<p>The <code>VillainProxy</code> is very similar and looks like this:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\nimport org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\n\n@Path(\"/api/villains\")\n@Produces(MediaType.APPLICATION_JSON)\n@RegisterRestClient(configKey = \"villain\")\npublic interface VillainProxy {\n\n    @GET\n    @Path(\"/random\")\n    Villain findRandomVillain();\n}\n</code></pre>\n<p>Once created, go back to the <code>FightService</code> class and add the following import statements:</p>\n<pre><code>import io.quarkus.workshop.superheroes.fight.client.HeroProxy;\nimport io.quarkus.workshop.superheroes.fight.client.VillainProxy;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#configuring-rest-client-invocation","title":"Configuring REST Client Invocation","text":"<p>In order to determine the base URL to which REST calls will be made, the REST Client uses configuration from <code>application.properties</code>. The name of the property needs to follow a certain convention which is best displayed in the following code:</p>\n<pre><code>quarkus.rest-client.hero.url=http://localhost:8083\nquarkus.rest-client.villain.url=http://localhost:8084\n</code></pre>\n<p>Having this configuration means that all requests performed using <code>HeroProxy</code> will use http://localhost:8083 as the base URL. Using this configuration, calling the <code>findRandomHero</code> method of <code>HeroProxy</code> would result in an HTTP GET request being made to http://localhost:8083/api/heroes/random.</p>\n<p>Now, go back in the UI and refresh, you should see some pictures!</p>"},{"location":"Super-Heroes-Workshop/#updating-the-test-with-mock-support","title":"Updating the Test with Mock Support","text":"<p>But, now we have another problem. To run the tests of the Fight API we need the Hero and Villain REST APIs to be up and running. To avoid this, we need to Mock the <code>HeroProxy</code> and <code>VillainProxy</code> interfaces.</p>\n<p>Quarkus supports the use of mock objects using the CDI <code>@Alternative</code> mechanism</p>\n<p>To use this simply override the bean you wish to mock with a class in the <code>src/test/java</code> directory, and put the <code>@Alternative</code> and <code>@Priority(1)</code> annotations on the bean. Alternatively, a convenient <code>io.quarkus.test.Mock</code> stereotype annotation could be used. This built-in stereotype declares <code>@Alternative</code>, <code>@Priority(1)</code> and <code>@Dependent</code>.</p>"},{"location":"Super-Heroes-Workshop/#mocking-a-villain-service","title":"Mocking a Villain service","text":"<p>So, to mock the <code>VillainProxy</code> interface we just need to implement the following <code>MockVillainProxy</code> class (under the <code>client</code> subpackage under <code>src/test/java/io/quarkus/workshop/superheroes/fight</code>):</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\nimport io.quarkus.test.Mock;\nimport org.eclipse.microprofile.rest.client.inject.RestClient;\n\nimport jakarta.enterprise.context.ApplicationScoped;\n\n@Mock\n@ApplicationScoped\n@RestClient\npublic class MockVillainProxy implements VillainProxy {\n\n    @Override\n    public Villain findRandomVillain() {\n        return DefaultTestVillain.INSTANCE;\n    }\n}\n</code></pre>\n<p>We are using some common classes for the test data. They don\u2019t exist yet, so the IDE will complain! Let your IDE\u2019s quick fix create the classes for you, or create them manually (under the <code>client</code> subpackage under <code>src/test/java/io/quarkus/workshop/superheroes/fight</code>), and then fill in the following contents:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\npublic class DefaultTestVillain extends Villain {\n    public static final String DEFAULT_VILLAIN_NAME = \"Super Chocolatine\";\n    public static final String DEFAULT_VILLAIN_PICTURE = \"super_chocolatine.png\";\n    public static final String DEFAULT_VILLAIN_POWERS = \"does not eat pain au chocolat\";\n    public static final int DEFAULT_VILLAIN_LEVEL = 42;\n\n    public static final DefaultTestVillain INSTANCE = new DefaultTestVillain();\n\n    private DefaultTestVillain() {\n        this.name = DEFAULT_VILLAIN_NAME;\n        this.picture = DEFAULT_VILLAIN_PICTURE;\n        this.powers = DEFAULT_VILLAIN_POWERS;\n        this.level = DEFAULT_VILLAIN_LEVEL;\n    }\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#mocking-a-hero-service","title":"Mocking a Hero service","text":"<p>We could create a <code>@Mock</code> for the <code>HeroProxy</code>, as we did for the Villain, but there are some drawbacks to using <code>@Mock</code>:</p>\n<ul>\n<li>\n<p>Any class defined by <code>@Mock</code> is global in scope, and can\u2019t be isolated to individual tests. That can result in unwanted cross-talk between tests.</p>\n</li>\n<li>\n<p>Because of how the mock is defined, it\u2019s also harder to use Mockito to generate the mock instance.</p>\n</li>\n</ul>\n<p>Let\u2019s try a different approach.</p>\n<p>We\u2019ll still want a class which holds test data for the hero. Create the following under the <code>client</code> subpackage:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\npublic class DefaultTestHero extends Hero {\n    public static final String DEFAULT_HERO_NAME = \"Super Baguette\";\n    public static final String DEFAULT_HERO_PICTURE = \"super_baguette.png\";\n    public static final String DEFAULT_HERO_POWERS = \"eats baguette really quickly\";\n    public static final int DEFAULT_HERO_LEVEL = 42;\n\n    public static final DefaultTestHero INSTANCE = new DefaultTestHero();\n\n    private DefaultTestHero() {\n        this.name = DEFAULT_HERO_NAME;\n        this.picture = DEFAULT_HERO_PICTURE;\n        this.powers = DEFAULT_HERO_POWERS;\n        this.level = DEFAULT_HERO_LEVEL;\n    }\n}\n</code></pre>\n<p>Add the extended Quarkus Mockito support to the <code>fight</code> service\u2019s <code>pom.xml</code>:</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-junit5-mockito&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Now we can add the following to the top of the <code>FightResourceTest</code>:</p>\n<pre><code>@InjectMock\n@RestClient\nHeroProxy heroProxy;\n\n@BeforeEach\npublic void setup() {\n    when(heroProxy.findRandomHero()).thenReturn(DefaultTestHero.INSTANCE);\n}\n</code></pre>\n<p>The <code>when</code> call is a static import of <code>Mockito.when</code>. The <code>@InjectMock</code> annotation results in a mock being created and made available in test methods of the test class. Importantly, other test classes are not affected by this.</p>\n<pre><code>import io.quarkus.test.InjectMock;\nimport static org.mockito.Mockito.when;\nimport org.eclipse.microprofile.rest.client.inject.RestClient;\n</code></pre>\n<p>Finally, edit the <code>FightResourceTest</code> and add the following method:</p>\n<pre><code>@Test\nvoid shouldGetRandomFighters() {\n    Fighters fighters = given()\n        .when()\n        .get(\"/api/fights/randomfighters\")\n        .then()\n        .statusCode(OK.getStatusCode())\n        .contentType(APPLICATION_JSON)\n        .extract()\n        .as(Fighters.class);\n\n    Hero hero = fighters.hero;\n    assertEquals(hero.name, DefaultTestHero.DEFAULT_HERO_NAME);\n    assertEquals(hero.picture, DefaultTestHero.DEFAULT_HERO_PICTURE);\n    assertEquals(hero.level, DefaultTestHero.DEFAULT_HERO_LEVEL);\n    assertEquals(hero.powers, DefaultTestHero.DEFAULT_HERO_POWERS);\n\n    Villain villain = fighters.villain;\n    assertEquals(villain.name, DefaultTestVillain.DEFAULT_VILLAIN_NAME);\n    assertEquals(villain.picture, DefaultTestVillain.DEFAULT_VILLAIN_PICTURE);\n    assertEquals(villain.level, DefaultTestVillain.DEFAULT_VILLAIN_LEVEL);\n    assertEquals(villain.powers, DefaultTestVillain.DEFAULT_VILLAIN_POWERS);\n}\n</code></pre>\n<p>Now, run the test from the dev mode, or from your IDE. You can shutdown the hero and villain services to verify that the tests still pass.</p>\n<p>Time to play. Start the Hero, Villain and Fight microservices as well as the user interface (using <code>./mvnw quarkus:dev</code> on each project) and select random fighters.</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#fallbacks","title":"Fallbacks","text":"<p>So now you\u2019ve been playing this great Super Heroes Fight for a few hours\u2026 and you kill the Hero REST API. What happens? Well, the Fight REST API cannot invoke the Hero API anymore and breaks with the following exception:</p>\n<pre><code>Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:8083\nCaused by: java.net.ConnectException: Connection refused\n        at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)\n        at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777)\n        at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:330)\n        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:707)\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\n        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)\n        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n        at java.base/java.lang.Thread.run(Thread.java:829)\n</code></pre>\n<p>One of the challenges brought by the distributed nature of microservices is that communication with external systems is inherently unreliable. This increases demand on resiliency of applications. To simplify making more resilient applications, Quarkus contains an implementation of the MicroProfile Fault Tolerance specification</p>"},{"location":"Super-Heroes-Workshop/#installing-the-fault-tolerance-dependency","title":"Installing the Fault Tolerance Dependency","text":"<p>To install the MicroProfile Fault Tolerance dependency, just run the following command in the Fight microservice:</p>\n<pre><code>./mvnw quarkus:add-extension -Dextensions=\"smallrye-fault-tolerance\"\n</code></pre>\n<p>This will add the following dependency in the <code>pom.xml</code> file:</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-smallrye-fault-tolerance&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#adding-fallbacks","title":"Adding Fallbacks","text":"<p>Let\u2019s make our find random fighters feature better by providing a fallback way of getting a dummy hero or villain in case of failure.</p>\n<p>For that, add two fallback methods to the <code>FightService</code> and a <code>@Fallback</code> annotation to both <code>findRandomHero</code> and <code>findRandomVillain</code> methods as follows:</p>\n<pre><code>@Fallback(fallbackMethod = \"fallbackRandomHero\")\nHero findRandomHero() {\n    return heroProxy.findRandomHero();\n}\n\n@Fallback(fallbackMethod = \"fallbackRandomVillain\")\nVillain findRandomVillain() {\n    return villainProxy.findRandomVillain();\n}\n\npublic Hero fallbackRandomHero() {\n    logger.warn(\"Falling back on Hero\");\n    Hero hero = new Hero();\n    hero.name = \"Fallback hero\";\n    hero.picture = \"https://dummyimage.com/240x320/1e8fff/ffffff&amp;amp;text=Fallback+Hero\";\n    hero.powers = \"Fallback hero powers\";\n    hero.level = 1;\n    return hero;\n}\n\npublic Villain fallbackRandomVillain() {\n    logger.warn(\"Falling back on Villain\");\n    Villain villain = new Villain();\n    villain.name = \"Fallback villain\";\n    villain.picture = \"https://dummyimage.com/240x320/b22222/ffffff&amp;amp;text=Fallback+Villain\";\n    villain.powers = \"Fallback villain powers\";\n    villain.level = 42;\n    return villain;\n}\n</code></pre>\n<p>Also add the <code>import org.eclipse.microprofile.faulttolerance.Fallback;</code> statement.</p>"},{"location":"Super-Heroes-Workshop/#running-the-application_1","title":"Running the Application","text":"<p>Now we are ready to run our application and test the fallbacks.</p>\n<p>For that, kill the Hero (and/or the Villain API) and start playing again. You should see the following:</p>\n<p></p>\n<p>Restart the Hero REST API\u2026 and keep on playing. Super-heroes are back to the fight!</p>"},{"location":"Super-Heroes-Workshop/#timeout","title":"Timeout","text":"<p>Sometimes invoking a REST API can take a long time. In fact, the more microservices invoke other microservices, the more network latency you can have. And what happens when a HTTP request takes long? Well, it hangs. On your browser you can see the request pending if you turn on the dev tools and look at what\u2019s the network is doing.</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#adding-timeouts","title":"Adding Timeouts","text":"<p>Getting random fighters can take longer than expected.</p>\n<p>To simulate a long-running process, add the following code to the <code>FightResource</code>:</p>\n<pre><code>@ConfigProperty(name = \"process.milliseconds\", defaultValue = \"0\")\nlong tooManyMilliseconds;\n\nprivate void veryLongProcess() {\n    try {\n        Thread.sleep(tooManyMilliseconds);\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n    }\n}\n\n@GET\n@Path(\"/randomfighters\")\n@Timeout(500) // &lt;-- Added\npublic Response getRandomFighters() {\n    veryLongProcess(); // &lt;-- Added\n    Fighters fighters = service.findRandomFighters();\n    logger.debug(\"Get random fighters \" + fighters);\n    return Response.ok(fighters).build();\n}\n</code></pre>\n<p>Don\u2019t forget to add the following import:</p><pre><code>import org.eclipse.microprofile.config.inject.ConfigProperty;\nimport org.eclipse.microprofile.faulttolerance.Timeout;</code></pre>\n\n<p>Let\u2019s say we\u2019ve added some new functionality in the <code>veryLongProcess</code> method. When the process is really too long and the system is overloaded, we would rather time out.</p>\n<p>Note that the timeout was configured to 500 ms, and a <code>Thread.sleep</code> was introduced and can be configured in the <code>application.properties</code>. If we set the property to a higher value than the timeout, let\u2019s say 10.000, then the request should be interrupted.</p>\n<pre><code>process.milliseconds=10000\n</code></pre>"},{"location":"Super-Heroes-Workshop/#running-the-application_2","title":"Running the Application","text":"<p>Now that you have set the number of waiting milliseconds to 10.000, run the application and start fighting again. You should see the following:</p>\n<pre><code>18:40:48 ERROR [or.jb.re.re.co.co.AbstractResteasyReactiveContext] (executor-thread-0) Request failed: org.eclipse.microprofile.faulttolerance.exceptions.TimeoutException: Timeout[io.quarkus.workshop.superheroes.fight.FightResource#getRandomFighters] timed out\n        at io.smallrye.faulttolerance.core.timeout.Timeout.timeoutException(Timeout.java:91)\n        at io.smallrye.faulttolerance.core.timeout.Timeout.doApply(Timeout.java:78)\n        at io.smallrye.faulttolerance.core.timeout.Timeout.apply(Timeout.java:30)\n...\n</code></pre>\n<p>Before going further, set the <code>process.milliseconds</code> to 0.</p>"},{"location":"Super-Heroes-Workshop/#contract-testing","title":"Contract testing","text":"<p>Let\u2019s look at what we\u2019ve done so far. We have been doing some (some) test-driven development, we have several microservices, and they\u2019re even talking to each other. We have fault tolerance for when services go down.</p>\n<p>Clearly, we have an invincible application. Right? Right?</p>\n<p>In your IDE, have a look to see how many instances of a class called <code>Hero</code> you have. There should be two. This is by design; one for the consumer of the service, and one for the provider.</p>\n<p>The two classes are different, with the provider class having a lot more code in it. However, the fields in the two classes should be roughly the same.</p>\n<p>What happens if we do some refactoring?</p>\n<p>In the <code>rest-heroes</code> project, let\u2019s do some searching and replacing. (We do search and replace so we catch both Java and SQL in our refactoring.) Change \"level\" to \"maturity\". Make sure to only do search within the rest-heroes directory. (Normally this project would be in its own repository, but we\u2019ve grouped everything together into one repository for convenience.)</p>\n<p>Check all of your tests. The heroes, villains, and fights tests should all be running clean. A successful refactoring!</p>\n<p>Now visit the UI at http://localhost:8080/. What\u2019s going on? The hero\u2019s level is always 0. Why didn\u2019t the tests catch this?</p>\n<p>Although we changed the provider of an API, no one told the consumer that the API had changed. The unit tests were (correctly) isolated in scope, so they didn\u2019t catch the cross-service misunderstanding.</p>\n<p>Feel free to reverse the change now, rather than patching up the service consumer.</p>\n<p>This was a slightly contrived example, but uncaught API changes are a common cause of breaks, especially early in project development, before APIs have been locked down. Tools like OpenAPI validation can catch syntax changes, but they will not catch semantic changes. (What if we\u2019d changed the level to be normalised against the best fighter, or count down from 100?)</p>\n<p>This is where contract testing comes in. Contract testing is a lightweight way of validating that a service\u2019s consumer and provider have the same understanding about what the service does.</p>\n<p>There are several contract testing tools available. The Red Hat App Development Consulting team have an excellent tutorial describing contract first development and a polyglot OpenAPI-based stack for contract testing.</p>\n<p>We will be using an all-in-one tool called Pact, which is also polyglot, and enables consumer-driven contract testing. The Pact team have a good overview of the advantages and disadvantages of schema-based testing (such as validation based on an OpenAPI spec) and consumer-driven contract testing.</p>"},{"location":"Super-Heroes-Workshop/#consumer-tests","title":"Consumer tests","text":"<p>Pact is a consumer-driven contract testing framework, which means that we begin by writing tests for the API consumer.</p>"},{"location":"Super-Heroes-Workshop/#writing-the-first-contract-test","title":"Writing the first contract test","text":"<p>Add the Pact Quarkus extension to the <code>pom.xml</code> of the Fights service:</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkiverse.pact&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-pact-consumer&lt;/artifactId&gt;\n    &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>The Pact framework will stand up a server which listens on a port. To avoid port conflicts between the real services and the Pact stubs, let\u2019s use a different port for the contract instances. Open the fight service\u2019s <code>application.properties</code> and add the following</p>\n<pre><code>%test.quarkus.rest-client.hero.url=http://localhost:8093\n</code></pre>\n<p>The <code>%test</code> scopes the updated property to only apply in the test mode.</p>\n<p>Create a class called <code>FightResourceConsumerTest.java</code>.</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight;\n\nimport au.com.dius.pact.consumer.dsl.PactDslWithProvider;\nimport au.com.dius.pact.consumer.junit5.PactConsumerTestExt;\nimport au.com.dius.pact.consumer.junit5.PactTestFor;\nimport au.com.dius.pact.core.model.PactSpecVersion;\nimport au.com.dius.pact.core.model.V4Pact;\nimport au.com.dius.pact.core.model.annotations.Pact;\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.quarkus.workshop.superheroes.fight.client.DefaultTestHero;\nimport io.quarkus.workshop.superheroes.fight.client.DefaultTestVillain;\nimport io.quarkus.workshop.superheroes.fight.client.Hero;\nimport io.quarkus.workshop.superheroes.fight.client.Villain;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\nimport jakarta.ws.rs.HttpMethod;\nimport jakarta.ws.rs.core.HttpHeaders;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.core.Response.Status;\nimport java.util.Map;\n\nimport static au.com.dius.pact.consumer.dsl.LambdaDsl.newJsonBody;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n@QuarkusTest\n@ExtendWith(PactConsumerTestExt.class)\n@PactTestFor(\n    providerName = \"rest-heroes\",\n    pactVersion = PactSpecVersion.V4,\n    hostInterface = \"localhost\",\n    // Hard-code the Pact MockServer to what we defined in application.properties\n    // I don't like it but couldn't figure out any other way without using dynamic config\n    port = \"8093\"\n)\npublic class FightResourceConsumerTest {\n\n    private static final String HERO_API_BASE_URI = \"/api/heroes\";\n    private static final String HERO_RANDOM_URI = HERO_API_BASE_URI + \"/random\";\n\n    @Pact(consumer = \"rest-fights\")\n    public V4Pact randomHeroFoundPact(PactDslWithProvider builder) {\n        return builder\n            .uponReceiving(\"A request for a random hero\")\n            .path(HERO_RANDOM_URI)\n            .method(HttpMethod.GET)\n            .headers(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON)\n            .willRespondWith()\n            .status(Response.Status.OK.getStatusCode())\n            .headers(Map.of(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON))\n            .body(newJsonBody(body -&gt;\n                    body\n                        .stringType(\"name\", DefaultTestHero.DEFAULT_HERO_NAME)\n                        .integerType(\"level\", DefaultTestHero.DEFAULT_HERO_LEVEL)\n                        .stringType(\"picture\", DefaultTestHero.DEFAULT_HERO_PICTURE)\n                ).build()\n            )\n            .toPact(V4Pact.class);\n    }\n\n    @Test\n    void randomHeroFound() {\n    }\n}\n</code></pre>\n<p>Here we are setting up a test to run with Pact and telling Pact what ports it should stand up the mock server on. We also define how the mock should behave.</p>\n<p>Run the build, using <code>./mvnw verify</code> or <code>./mvnw quarkus:dev</code>. You should see a failure. What\u2019s happened? The <code>randomHeroFound</code> test didn\u2019t have any assertions, so how could there be a failure? Pact is doing some validation for us. We have defined a mock, but nothing is exercising it. That might mean our code doesn\u2019t do what we think it does, so Pact flags it as an error.</p>\n<p>Let\u2019s fill in the dummy test method with something more substantial. Replace the <code>randomHeroFound</code> test with the following. You\u2019ll notice this is very similar to the one in <code>FightResourceTest</code>; you could even copy and paste from that class.</p>\n<pre><code>@Test\n@PactTestFor(pactMethod = \"randomHeroFoundPact\")\nvoid randomHeroFound() {\n    Fighters fighters = given()\n        .when()\n        .get(\"/api/fights/randomfighters\")\n        .then()\n        .statusCode(OK.getStatusCode())\n        .contentType(APPLICATION_JSON)\n        .extract()\n        .as(Fighters.class);\n\n    Hero hero = fighters.hero;\n    assertEquals(hero.name, DefaultTestHero.DEFAULT_HERO_NAME);\n    assertEquals(hero.picture, DefaultTestHero.DEFAULT_HERO_PICTURE);\n    assertEquals(hero.level, DefaultTestHero.DEFAULT_HERO_LEVEL);\n\n    // We're really trying to test the fighter, so we want to make sure it still passes back\n    // a villain\n    Villain villain = fighters.villain;\n    assertEquals(villain.name, DefaultTestVillain.DEFAULT_VILLAIN_NAME);\n    assertEquals(villain.picture, DefaultTestVillain.DEFAULT_VILLAIN_PICTURE);\n    assertEquals(villain.level, DefaultTestVillain.DEFAULT_VILLAIN_LEVEL);\n}\n</code></pre>\n<p>Run the tests. They should all pass.</p>\n<p>Note that we\u2019re only setting up contracts for heroes here. If we were to make contracts for getting villains, the test would fail. Can you think why that might be?</p>\n<p>When we use Pact, the Pact framework stands up a server which acts as a mock. Remember that we defined a global <code>@Mock</code> for the <code>VillainProxy</code>. Because <code>@Mocks</code> are global, that mock would be used instead of the Pact mock service we want the class under test to be talking to. This is an example of why a local <code>@InjectMock</code> is often preferable to a global <code>@Mock</code>.</p>"},{"location":"Super-Heroes-Workshop/#the-contract","title":"The contract","text":"<p>Look in <code>target/pacts</code>. You should find a json contract, <code>rest-fights-rest-heroes.json</code>. Inspect it to see how the contents of the <code>@Pact</code> method have been turned into json.</p>\n<p>What we want to be testing when we use Pact in our tests is the behaviour of our own code. Here, although we check the value of the hero fields, we\u2019re trying to make sure that the fights service is doing the right thing. Our expectation for the fights service is pretty low: it just has to pass through what it gets from the heroes service.</p>\n<p>This test is just on the edge of falling into a common Pact anti-pattern, testing the mock. We do not need to do detailed validation of what comes back from the pact server, because it\u2019s a mock that we define.</p>\n\n<p>A more interesting contract test would exercise some of the more complex fights functionality, while using the mock we\u2019ve defined. Can you write one? (You might also need to define a villain pact.)</p>\n<p>If you get stuck, you can look at the consumer contract tests in the source repo for inspiration.</p>"},{"location":"Super-Heroes-Workshop/#provider-tests","title":"Provider tests","text":"<p>So far, we\u2019ve done good work and set up tests for the fight service, to extend our testing of the fight service, and also encode its expectations for the hero service into a json contract.</p>\n<p>The next step is to make sure the Hero service actually produces what the contract says it should!</p>"},{"location":"Super-Heroes-Workshop/#sharing-the-contract","title":"Sharing the contract","text":"<p>There are a few possibilities for sharing the contract. A self-hosted or managed pact broker can host all of the contracts, as well as providing extra services such as metrics about when tests were run and compatibility dashboards.</p>\n<p>Alternatively, some teams check the json contract into the provider\u2019s source control after a successful run. Note that Pact is consumer-driven contract system; the consumer has responsibility for defining the contract, and therefore also has responsibility for sharing it.</p>\n<p>The simplest sharing mechanism is copying on a filesystem, so that\u2019s what we\u2019ll do. From the fights service, copy the contract to the heroes service.</p>\n<pre><code>mkdir -p ../rest-heroes/src/test/resources\ncp -r target/pacts ../rest-heroes/src/test/resources\n</code></pre>"},{"location":"Super-Heroes-Workshop/#writing-the-test","title":"Writing the test","text":"<p>The great thing about the provider Pact tests is that the provider doesn\u2019t have to do much. The Pact framework will generate a test for each expectation in the contract and run them, based on just a small amount of boilerplate code:</p>\n<pre><code>@TestTemplate\n@ExtendWith(PactVerificationInvocationContextProvider.class)\nvoid pactVerificationTestTemplate(PactVerificationContext context) {\n    context.verifyInteraction();\n}\n</code></pre>\n<p>(No need to put that snippet anywhere yet, we will see how it fits into a test class in a moment.)</p>\n<p>Add the Pact dependency to the heroes service <code>pom.xml</code>:</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkiverse.pact&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-pact-provider&lt;/artifactId&gt;\n    &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-panache-mock&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>We also add the Panache Mock dependency, which allows us to which allows use Mockito to mock all provided static methods. That will come in handy at various points in the provider testing.</p>\n<p>Create a <code>io/quarkus/workshop/superheroes/hero/HeroContractVerificationTest.java</code> class in the <code>rest-heroes</code> project. It doesn\u2019t need to do much except tell Pact what port the Hero provider is listening on, and create a JUnit test template, which will be expanded into the full set of tests needed to verify the contract.</p>\n<pre><code>@QuarkusTest\n@Provider(\"rest-heroes\")\n@PactFolder(\"pacts\")\npublic class HeroContractVerificationTest {\n    @ConfigProperty(name = \"quarkus.http.test-port\")\n    int quarkusPort;\n\n\n    @BeforeEach\n    void beforeEach(PactVerificationContext context) {\n        context.setTarget(new HttpTestTarget(\"localhost\", this.quarkusPort));\n    }\n\n    @TestTemplate\n    @ExtendWith(PactVerificationInvocationContextProvider.class)\n    void pactVerificationTestTemplate(PactVerificationContext context) {\n        context.verifyInteraction();\n    }\n}\n</code></pre>\n<p>When you run the tests they should pass.</p>"},{"location":"Super-Heroes-Workshop/#states","title":"States","text":"<p>One of the advantages of Pact over simpler contract verification methods, such as OpenAPI syntax-checking, is that a pact can include a range of expected responses, depending on what was passed in, and external state.</p>\n<p>This allows for a richer set of checks. For example, it can exercise more interesting logic on the consumer side, and it can act as a proper functional test for the provider.</p>\n<p>Let\u2019s exercise some error-handling. What happens if no heroes can be found? In that case, we expect that the heroes server will return a 404. Let\u2019s get that into the contract, and exercise the fight service\u2019s error handling.</p>\n<p>Add a new pact. We use the <code>given()</code> to identify the state.</p>\n<pre><code>@Pact(consumer = \"rest-fights\")\npublic V4Pact randomHeroNotFoundPact(PactDslWithProvider builder) {\n    return builder\n        .given(\"No random hero found\")\n        .uponReceiving(\"A request for a random hero\")\n        .path(HERO_RANDOM_URI)\n        .method(HttpMethod.GET)\n        .headers(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON)\n        .willRespondWith()\n        .status(Status.NOT_FOUND.getStatusCode())\n        .toPact(V4Pact.class);\n}\n</code></pre>\n<p>Then, we can define another test method, which exercises our service, given this unhappy state. If the hero service returns 404, we want to check that the fallback instances we defined earlier are used. We also want to check that things work as normal for the villain part of the response.</p>\n<pre><code>@Test\n@PactTestFor(pactMethod = \"randomHeroNotFoundPact\")\nvoid shouldGetRandomFighters() {\n    Fighters fighters = given()\n        .when()\n        .get(\"/api/fights/randomfighters\")\n        .then()\n        .statusCode(OK.getStatusCode())\n        .contentType(APPLICATION_JSON)\n        .extract()\n        .as(Fighters.class);\n\n    Hero hero = fighters.hero;\n\n    assertEquals(hero.name, \"Fallback hero\");\n    assertEquals(hero.picture,\n        \"https://dummyimage.com/240x320/1e8fff/ffffff&amp;amp;text=Fallback+Hero\");\n    assertEquals(hero.level, 1);\n}\n</code></pre>\n<p>Run the tests. They should pass. Then copy them to the hero service, using <code>cp -r target/pacts ../rest-heroes/src/test/resources</code>. In the hero service, the tests will fail, because we haven\u2019t told Pact how to handle the new state.</p>\n<p>We would normally do that with a <code>@State</code> annotation. However, for boring JUnit classloading reasons, we don\u2019t have access to the CDI context in the <code>@State</code> method, so we\u2019ll work around it by handling the state in the <code>@BeforeEach</code>.</p>\n<pre><code>private static final String NO_HERO_FOUND_STATE = \"No random hero found\";\n\n@BeforeEach\nvoid beforeEach(PactVerificationContext context) {\n    context.setTarget(new HttpTestTarget(\"localhost\", this.quarkusPort));\n\n    // We have to do this here because the CDI context isn't available\n    // in the @State method below\n    var noHeroState = Optional.ofNullable(context.getInteraction()\n                                                 .getProviderStates())\n                              .orElseGet(List::of)\n                              .stream()\n                              .filter(\n                                  state -&gt; NO_HERO_FOUND_STATE.equals(state.getName()))\n                              .count() &gt; 0;\n\n    if (noHeroState) {\n        PanacheMock.mock(Hero.class);\n        Mockito.when(Hero.findRandom()).thenReturn(Uni.createFrom()\n                                              .nullItem());\n\n    }\n}\n\n\n@State(NO_HERO_FOUND_STATE)\npublic void clearData() throws NoSuchMethodException, InvocationTargetException,\n    IllegalAccessException {\n    // Already handled in beforeEach\n    // See https://github.com/quarkusio/quarkus/issues/22611\n}\n</code></pre>\n<p>What\u2019s going on? The consumer expects a 404 if there are no heroes, but the provider is returning a 204. The reasoning from the consumer is that if a caller asks for a resource the server doesn\u2019t have, it should be a 404, the same way if a user types in an invalid URL into the browser. This is a more pure interpretation of REST than what was inplemented by the <code>HeroResource</code>.</p>\n<p>There are arguments for both 404 (not found) and 204 (no content). Feel free to debate with your neighbour about which you prefer \u2013 but it doesn\u2019t really matter which is correct. What matters is that the provider and consumer had different preferences. If the provider returns 204 rather than 404, the fallback logic on the provider (as implemented) is not triggered. (You can try this out for yourself by changing the contract in the <code>FightResourceConsumerTest</code>.)</p>\n<p>At this point, the consumer and provider need to have a conversation to decide whether the expectations or implementation should be updated. To make the fallback logic simplest, we will update the provider. Edit the <code>HeroResource</code> and update the <code>getRandomHero</code> method to explicitly handle the null case.</p>\n<pre><code>@Operation(summary = \"Returns a random hero\")\n@GET\n@Path(\"/random\")\n@APIResponse(responseCode = \"200\", content = @Content(mediaType = APPLICATION_JSON, schema = @Schema(implementation = Hero.class, required = true)))\npublic Uni&lt;RestResponse&lt;Hero&gt;&gt; getRandomHero() {\n    return Hero.findRandom()\n        .onItem().ifNotNull().transform(h -&gt; {\n            this.logger.debugf(\"Found random hero: %s\", h);\n            return RestResponse.ok(h);\n        })\n        .onItem().ifNull().continueWith(() -&gt; {\n            this.logger.debug(\"No random villain found\");\n            return RestResponse.notFound();\n        });\n}\n</code></pre>\n<p>The tests should now pass.</p>"},{"location":"Super-Heroes-Workshop/#artificial-intelligence","title":"Artificial Intelligence","text":"<p>On one side we have superheroes, and on the other side we have super villains. What happens when they fight? Let\u2019s ask an AI to narrate the fight!</p>\n<p>In this section we will introduce a new microservice that will use AI to narrate the fight between a superhero and a super villain. It will use the Semantic Kernel API to generate the text invoking OpenAI or Azure OpenAI (you choose).</p>\n<p></p>\n<p>In the following sections, you will learn:</p>\n<ul>\n<li>\n<p>What is Semantic Kernel?</p>\n</li>\n<li>\n<p>How to invoke OpenAI or Azure OpenAI GPT model using Semantic Kernel</p>\n</li>\n<li>\n<p>How to create an OpenAI Plugin (a.k.a Skill) to narrate a fight</p>\n</li>\n</ul>\nThis service is exposed on the port 8086."},{"location":"Super-Heroes-Workshop/#whats-semantic-kernel","title":"What\u2019s Semantic Kernel?","text":"<p>Semantic Kernel is an open-source SDK that lets you easily combine AI services like OpenAI, Azure OpenAI, and Hugging Face with conventional programming languages like C#, Python or Java. By doing so, you can create AI apps that combine the best of both worlds: the deterministic nature of conventional programming and the semantic aspect of AI.</p>\n<p></p>\n<p>Semantic Kernel has been engineered to allow developers to flexibly integrate AI services into their existing apps. To do so, Semantic Kernel provides a set of connectors that make it easy to add memories and models. In this way, Semantic Kernel is able to add a simulated \"brain\" to your app.</p>\n<p>Additionally, Semantic Kernel makes it easy to add skills to your applications with AI plugins that allow you to interact with the real world. These plugins are composed of prompts and native functions that can respond to triggers and perform actions. In this way, plugins are like the \"body\" of your AI app.</p>"},{"location":"Super-Heroes-Workshop/#narration-microservice","title":"Narration Microservice","text":"<p>Let\u2019s create a new microservice that will use Semantic Kernel to narrate the fight between a superhero and a super villain. New microservice, new project!</p>\n<p>As before, the easiest way to create this new Quarkus project is to use the Quarkus Maven plugin (you can also go to https://code.quarkus.io if you prefer). Open a terminal and run the following command under the <code>quarkus-workshop-super-heroes/super-heroes</code> directory:</p>\n<pre><code>./mvnw io.quarkus:quarkus-maven-plugin:3.9.1:create    -\"DplatformVersion=3.9.1\" -\"DprojectGroupId=io.quarkus.workshop.super-heroes\"   -\"DprojectArtifactId=rest-narration\"    -DclassName=\"io.quarkus.workshop.superheroes.narration.NarrationResource\"    -Dpath=\"api/narration\"   -Dextensions=\"resteasy-jackson,quarkus-smallrye-openapi,quarkus-smallrye-fault-tolerance\"\n</code></pre>\n<p>This microservice needs less dependencies than the previous ones:</p>\n<ul>\n<li>\n<p><code>resteasy-jackson</code> provides RESTEasy Reactive and the ability to map JSON objects,</p>\n</li>\n<li>\n<p><code>quarkus-smallrye-openapi</code> provides the OpenAPI descriptor support and the Swagger UI in the dev console,</p>\n</li>\n<li>\n<p><code>quarkus-smallrye-fault-tolerance</code> provides the MicroProfile Fault Tolerance dependency so we can fallback in case OpenAI/Azure OpenAI does not respond.</p>\n</li>\n</ul>\n<p>If you want your IDE to manage this new Maven project, you can declare it in the parent POM by adding this new module in the <code>&lt;modules&gt;</code> section:</p>\n<pre><code>&lt;module&gt;super-heroes/rest-narration&lt;/module&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#directory-structure_7","title":"Directory Structure","text":"<p>At the end of this chapter, you will end up with the following directory structure (notice the <code>NarrationSkill</code> directory under <code>src/main/resources</code>):</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#add-the-semantic-kernel-dependencies","title":"Add the Semantic Kernel dependencies","text":"<p>Once the project is created, you need to add the Semantic Kernel dependencies. Semantic Kernel is available on Maven Central. It has a BOM (Bill of Materials) that you can import in your project and then add the dependencies you need. Add the following XML in the <code>rest-narration/pom.xml</code> file:</p>\n<pre><code>  &lt;properties&gt;\n    &lt;!-- ... --&gt;\n    &lt;semantic-kernel.version&gt;0.2.11-alpha&lt;/semantic-kernel.version&gt;\n  &lt;/properties&gt;\n  &lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n      &lt;!-- ... --&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;com.microsoft.semantic-kernel&lt;/groupId&gt;\n        &lt;artifactId&gt;semantickernel-bom&lt;/artifactId&gt;\n        &lt;version&gt;${semantic-kernel.version}&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n        &lt;scope&gt;import&lt;/scope&gt;\n      &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n  &lt;/dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;!-- ... --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.microsoft.semantic-kernel&lt;/groupId&gt;\n      &lt;artifactId&gt;semantickernel-core&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.microsoft.semantic-kernel&lt;/groupId&gt;\n      &lt;artifactId&gt;semantickernel-settings-loader&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.microsoft.semantic-kernel&lt;/groupId&gt;\n      &lt;artifactId&gt;semantickernel-connectors-ai-openai&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#the-fight-bean","title":"The Fight bean","text":"<p>Let\u2019s start with the <code>Fight</code> class. The fight is what is going to be narrated by the microservice and ultimately sent by the Fight microservice.</p>\n<p>Create the <code>io.quarkus.workshop.superheroes.narration.Fight</code> class in the created project with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.narration;\n\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\n\n@Schema(description = \"The fight that is narrated\")\npublic class Fight {\n\n    public String winnerName;\n    public int winnerLevel;\n    public String winnerPowers;\n    public String loserName;\n    public int loserLevel;\n    public String loserPowers;\n    public String winnerTeam;\n    public String loserTeam;\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#the-narration-rest-resource","title":"The Narration REST Resource","text":"<p>The <code>NarrationResource</code> only has one HTTP POST method to create a new narration. Given a fight, it will invoke the <code>NarrationService</code> to return a fight narration.</p>\n<p>Open the generated <code>io.quarkus.workshop.superheroes.narration.NarrationResource</code> and update the content to be:</p>\n<pre><code>package io.quarkus.workshop.superheroes.narration;\n\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.*;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport org.eclipse.microprofile.openapi.annotations.tags.Tag;\n\n/**\n * JAX-RS API endpoints with &lt;code&gt;/api/narration&lt;/code&gt; as the base URI for all endpoints\n */\n\n@Path(\"/api/narration\")\n@Produces(MediaType.TEXT_PLAIN)\n@Consumes(MediaType.APPLICATION_JSON)\n@Tag(name = \"narration\")\npublic class NarrationResource {\n\n    @Inject\n    NarrationService service;\n\n    @POST\n    public Response narrate(Fight fight) throws Exception {\n        String narration = service.narrate(fight);\n        return Response.status(Response.Status.CREATED).entity(narration).build();\n    }\n\n    @GET\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello Narration Resource\";\n    }\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#the-semantic-kernel-narration-service","title":"The Semantic Kernel Narration service","text":"<p>Now it\u2019s time to implement the <code>NarrationService</code> that will use the Semantic Kernel to generate the narration. First of all, let\u2019s create an interface that will be implemented by the <code>SemanticKernelNarrationService</code> but could also be implemented by other AI frameworks: Create the <code>io.quarkus.workshop.superheroes.narration.NarrationService</code> interface in the created project with the following content:</p>\n<p>Open the <code>NarrationResource</code> and update the content to be:</p>\n<pre><code>package io.quarkus.workshop.superheroes.narration;\n\npublic interface NarrationService {\n    String narrate(Fight fight) throws Exception;\n}\n</code></pre>\n<p>Then, create the <code>io.quarkus.workshop.superheroes.narration.SemanticKernelNarrationService</code> that implements the <code>NarrationService</code> interface. This class has the following methods:</p>\n<ul>\n<li>\n<p><code>narrate</code>: the main method that will use the Semantic Kernel to generate the narration</p>\n</li>\n<li>\n<p><code>fallbackNarrate</code>: the fallback method that will be invoked if the <code>narrate</code> method fails (due to a timeout for example)</p>\n</li>\n<li>\n<p><code>getClient</code>: a method that returns the Semantic Kernel client configured by the <code>conf.properties</code> file</p>\n</li>\n</ul>\n<pre><code>package io.quarkus.workshop.superheroes.narration;\n\nimport com.azure.ai.openai.OpenAIAsyncClient;\nimport com.microsoft.semantickernel.Kernel;\nimport com.microsoft.semantickernel.SKBuilders;\nimport com.microsoft.semantickernel.connectors.ai.openai.util.OpenAIClientProvider;\nimport com.microsoft.semantickernel.exceptions.ConfigurationException;\nimport com.microsoft.semantickernel.orchestration.SKContext;\nimport com.microsoft.semantickernel.skilldefinition.ReadOnlyFunctionCollection;\nimport com.microsoft.semantickernel.textcompletion.CompletionSKFunction;\nimport com.microsoft.semantickernel.textcompletion.TextCompletion;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport org.eclipse.microprofile.faulttolerance.Fallback;\nimport org.eclipse.microprofile.faulttolerance.Timeout;\nimport org.jboss.logging.Logger;\nimport reactor.core.publisher.Mono;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Properties;\n\n@ApplicationScoped\npublic class SemanticKernelNarrationService implements NarrationService {\n\n    @Inject\n    Logger logger;\n\n    @Override\n    @Fallback(fallbackMethod = \"fallbackNarrate\")\n    @Timeout(30_000)\n    public String narrate(Fight fight) throws Exception {\n\n        // Creates an Azure OpenAI client\n        OpenAIAsyncClient client = getClient();\n\n        // Creates an instance of the TextCompletion service\n        TextCompletion textCompletion = SKBuilders.chatCompletion().withOpenAIClient(client).withModelId(\"gpt35turbo\").build();\n\n        // Instantiates the Kernel\n        Kernel kernel = SKBuilders.kernel().withDefaultAIService(textCompletion).build();\n\n        // Registers skills\n        ReadOnlyFunctionCollection skill = kernel.importSkillFromResources(\"\", \"NarrationSkill\", \"NarrateFight\");\n        CompletionSKFunction fightFunction = skill.getFunction(\"NarrateFight\", CompletionSKFunction.class);\n\n        // Ask to narrate a fight\n        SKContext fightContext = SKBuilders.context().build();\n        fightContext.setVariable(\"winner_team\", fight.winnerTeam);\n        fightContext.setVariable(\"winner_name\", fight.winnerName);\n        fightContext.setVariable(\"winner_powers\", fight.winnerPowers);\n        fightContext.setVariable(\"winner_level\", String.valueOf(fight.winnerLevel));\n        fightContext.setVariable(\"loser_team\", fight.loserTeam);\n        fightContext.setVariable(\"loser_name\", fight.loserName);\n        fightContext.setVariable(\"loser_powers\", fight.loserPowers);\n        fightContext.setVariable(\"loser_level\", String.valueOf(fight.loserLevel));\n        Mono&lt;SKContext&gt; result = fightFunction.invokeAsync(fightContext);\n\n        String narration = result.block().getResult();\n        logger.info(\"The narration for the fight is: \" + narration);\n\n        return narration;\n    }\n\n    public String fallbackNarrate(Fight fight) {\n        logger.warn(\"Falling back on Narration\");\n        return \"\"\"\n            High above a bustling city, a symbol of hope and justice soared through the sky, while chaos reigned below, with malevolent laughter echoing through the streets.\n            With unwavering determination, the figure swiftly descended, effortlessly evading explosive attacks, closing the gap, and delivering a decisive blow that silenced the wicked laughter.\n\n            In the end, the battle concluded with a clear victory for the forces of good, as their commitment to peace triumphed over the chaos and villainy that had threatened the city.\n            The people knew that their protector had once again ensured their safety.\n            \"\"\";\n    }\n\n    private OpenAIAsyncClient getClient() throws ConfigurationException {\n        String propertiesFile = \"conf.properties\";\n\n        try (InputStream is = this.getClass().getClassLoader().getResourceAsStream(propertiesFile)) {\n\n            Properties properties = new Properties();\n            properties.load(is);\n\n            OpenAIClientProvider provider = new OpenAIClientProvider((Map) properties, null);\n\n            return provider.getAsyncClient();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#the-narration-skill","title":"The Narration skill","text":"<p>With skills, you can encapsulate AI capabilities into a single unit of functionality. Semantic Kernel skills implement the OpenAI Plugin specification also known as \"skills\". To narrate a fight, we need to create a <code>NarrateFight</code> function. For that, you need to create a set of directories unders <code>rest-narration/src/main/resources/NarrationSkill/NarrateFight</code>.</p>\n<p>Under the <code>NarrationSkill/NarrateFight</code> directory, create the following files:</p>\n<ul>\n<li>\n<p><code>skprompt.txt</code>: the prompt that will be sent to OpenAI/Azure OpenAI</p>\n</li>\n<li>\n<p><code>config.json</code>: the configuration of the skill</p>\n</li>\n</ul>\n<p>Under <code>src/main/resources/NarrationSkill/NarrateFight/</code>, create the <code>skprompt.txt</code> file with the following content. Notice that the prompt uses expression language to get the fight data (e.g., <code>{{$winner_name}}</code>).</p>\n<pre><code>ACT LIKE YOU WERE A MARVEL COMICS WRITTER, EXPERT IN ALL SORTS OF SUPER HEROES AND SUPER VILLAINS.\nNARRATE THE FIGHT BETWEEN A SUPER HERO AND A SUPER VILLAIN.\nDURING THE NARRATION DON'T REPEAT \"super hero\" OR \"super villain\" WE KNOW WHO IS WHO.\nWRITE 4 PARAGRAPHS MAXIMUM.\n\nTHE NARRATION MUST BE:\n- G RATED\n- WORKPLACE/FAMILY SAFE\nNO SEXISM, RACISM OR OTHER BIAS/BIGOTRY\n\nBE CREATIVE.\n\nHERE IS THE DATA YOU WILL USE FOR THE WINNER:\n\n+++++\nname:   {{$winner_name}}\npowers: {{$winner_powers}}\nlevel:  {{$winner_level}}\n+++++\n\nHERE IS THE DATA YOU WILL USE FOR THE LOSER:\n\n+++++\nname:   {{$loser_name}}\npowers: {{$loser_powers}}\nlevel:  {{$loser_level}}\n+++++\n\nHERE IS THE DATA YOU WILL USE FOR THE FIGHT:\n\n+++++\n{{$winner_name}} WHO IS A {{$winner_team}} HAS WON THE FIGHT AGAINST {{$loser_name}} WHO IS A {{$loser_team}}.\n+++++\n</code></pre>\n<p>Under <code>src/main/resources/NarrationSkill/NarrateFight/</code>, create the <code>config.json</code> file with the following content:</p>\n<pre><code>{\n    \"schema\": 1,\n    \"description\": \"Narrates the fight between a Super Hero and a Super Villain using a single prompt\",\n    \"type\": \"completion\",\n    \"completion\": {\n        \"max_tokens\": 1000,\n        \"temperature\": 0.9,\n        \"top_p\": 0.0,\n        \"presence_penalty\": 0.0,\n        \"frequency_penalty\": 0.0\n    },\n    \"input\": {\n        \"parameters\": [\n            {\n                \"name\": \"winner_name\",\n                \"description\": \"The name of the winner\",\n                \"defaultValue\": \"Darth Vader\"\n            },\n            {\n                \"name\": \"winner_powers\",\n                \"description\": \"The comma separated list of powers of the winner\",\n                \"defaultValue\": \"Accelerated Healing, Agility, Astral Projection, Cloaking, Danger Sense, Durability, Electrokinesis, Energy Blasts, Enhanced Hearing, Enhanced Senses, Force Fields, Hypnokinesis, Illusions, Intelligence, Jump, Light Control, Marksmanship, Precognition, Psionic Powers, Reflexes, Stealth, Super Speed, Telekinesis, Telepathy, The Force, Weapons Master\"\n            },\n            {\n                \"name\": \"winner_level\",\n                \"description\": \"A number representing the level of the winner\",\n                \"defaultValue\": \"13\"\n            },\n            {\n                \"name\": \"loser_name\",\n                \"description\": \"The name of the loser\",\n                \"defaultValue\": \"Chewbacca\"\n            },\n            {\n                \"name\": \"loser_powers\",\n                \"description\": \"The comma separated list of powers of the loser\",\n                \"defaultValue\": \"Agility, Longevity, Marksmanship, Natural Weapons, Stealth, Super Strength, Weapons Master\"\n            },\n            {\n                \"name\": \"loser_level\",\n                \"description\": \"A number representing the level of the loser\",\n                \"defaultValue\": \"5\"\n            },\n            {\n                \"name\": \"winner_team\",\n                \"description\": \"The team winning. Can be either 'heroes' or 'villains'\",\n                \"defaultValue\": \"villains\"\n            },\n            {\n                \"name\": \"loser_team\",\n                \"description\": \"The team winning. Can be either 'heroes' or 'villains'\",\n                \"defaultValue\": \"heroes\"\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#configuring-openaiazure-openai-access","title":"Configuring OpenAI/Azure OpenAI access","text":"<p>Configuring the OpenAI/Azure OpenAI access is made thanks to the <code>conf.properties</code>. Depending if you have previously chosen OpenAI or Azure OpenAI, you either need to use the <code>client.openai</code> or <code>client.azureopenai</code> configuration keys.</p>\n<p>Make sure that you have previously either created an Azure AI or OpenAI subscription. </p>\n\n<p>If you use OpenAI, create the <code>rest-narration/src/main/resources/conf.properties</code> file and add the following configuration:</p>\n<pre><code>client.openai.key=\nclient.openai.organizationid=\n</code></pre>\n<p>For Azure OpenAI, use the following configuration in the <code>rest-narration/src/main/resources/conf.properties</code> file:</p>\n<pre><code>client.azureopenai.key=\nclient.azureopenai.endpoint=\nclient.azureopenai.deploymentname=\n</code></pre>\n<p>We also set the port of the Narration microservice to be 8086. And to have a better view of what\u2019s happening behind the scene with Semantic Kernel, we can increase the log level. Just add the following configuration to the Quarkus <code>application.properties</code> file:</p>\n<pre><code>## HTTP configuration\nquarkus.http.port=8086\n\n## Custom banner file path\nquarkus.banner.path=banner.txt\n\n## CORS\nquarkus.http.cors=true\nquarkus.http.cors.origins=*\n## Logging configuration\nquarkus.log.category.\"com.microsoft.semantickernel\".level=DEBUG\n</code></pre>"},{"location":"Super-Heroes-Workshop/#testing-the-narration-microservice","title":"Testing the Narration Microservice","text":"<p>Time for some tests! But before creating the test class, we need to add the Mockito dependency to the project. That\u2019s because we want to mock the Semantic Kernel client.</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-junit5-mockito&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Open the <code>io.quarkus.workshop.superheroes.narration.NarrationResourceTest</code> class and copy the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.narration;\n\nimport io.quarkus.test.InjectMock;\nimport io.quarkus.test.junit.QuarkusTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.MediaType.TEXT_PLAIN;\nimport static jakarta.ws.rs.core.Response.Status.CREATED;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.hamcrest.CoreMatchers.is;\n\n@QuarkusTest\npublic class NarrationResourceTest {\n\n    private static final String HERO_NAME = \"Super Baguette\";\n    private static final int HERO_LEVEL = 42;\n    private static final String HERO_POWERS = \"Eats baguette in less than a second\";\n    private static final String VILLAIN_NAME = \"Super Chocolatine\";\n    private static final int VILLAIN_LEVEL = 43;\n    private static final String VILLAIN_POWERS = \"Transforms chocolatine into pain au chocolat\";\n\n    @InjectMock\n    NarrationService narrationService;\n\n    private static Fight getFight() {\n        Fight fight = new Fight();\n        fight.winnerName = VILLAIN_NAME;\n        fight.winnerLevel = VILLAIN_LEVEL;\n        fight.winnerPowers = VILLAIN_POWERS;\n        fight.loserName = HERO_NAME;\n        fight.loserLevel = HERO_LEVEL;\n        fight.loserPowers = HERO_POWERS;\n        fight.winnerTeam = \"villains\";\n        fight.loserTeam = \"heroes\";\n        return fight;\n    }\n\n    @BeforeEach\n    public void setup() throws Exception {\n        Mockito.when(narrationService.narrate(getFight())).thenReturn(\"Lorem ipsum dolor sit amet\");\n    }\n\n    @Test\n    void shouldPingOpenAPI() {\n        given()\n            .header(ACCEPT, APPLICATION_JSON)\n            .when().get(\"/q/openapi\")\n            .then()\n            .statusCode(OK.getStatusCode());\n    }\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n            .when().get(\"/api/narration/hello\")\n            .then()\n            .statusCode(200)\n            .body(is(\"Hello Narration Resource\"));\n    }\n\n    @Test\n    void shouldNarrateAFight() {\n        given().log().all()\n            .body(getFight())\n            .header(CONTENT_TYPE, APPLICATION_JSON)\n            .header(ACCEPT, TEXT_PLAIN)\n            .when()\n            .post(\"/api/narration\")\n            .then()\n            .statusCode(CREATED.getStatusCode());\n//            .body(startsWith(\"Lorem ipsum dolor sit amet\"));\n    }\n}\n</code></pre>\n<p>Make sure the tests pass by executing the command <code>./mvnw test</code> (or from your IDE).</p>"},{"location":"Super-Heroes-Workshop/#running-the-narration-microservice","title":"Running the Narration Microservice","text":"<p>Now that the tests are green, we are ready to run our Narration microservice.</p>\n<p>Use <code>./mvnw quarkus:dev</code> to start it. Once the Narration microservice is started, create a new narration with the following cUrl command:</p>\n<pre><code>curl -X POST -d  '{\"winnerName\":\"Super winner\", \"winnerLevel\":42, \"winnerPowers\":\"jumping\", \"loserName\":\"Super loser\", \"loserLevel\":2, \"loserPowers\":\"leaping\", \"winnerTeam\":\"heroes\", \"loserTeam\":\"villains\" }'  -H \"Content-Type: application/json\" http://localhost:8086/api/narration -v\n</code></pre>\n<p>You should get something similar to the following response:</p>\n<pre><code>&lt; HTTP/1.1 201 Created\n&lt; Content-Type: text/plain;charset=UTF-8\n\nThe battle between the towering Chewbacca and the dark and menacing Darth Vader was one for the ages. Chewbacca's incredible strength and agility were no match for Vader's mastery of the Force and his arsenal of weapons. The two clashed in a flurry of blows and energy blasts, each trying to gain the upper hand.\n\nDespite Chewbacca's valiant efforts, it was clear that Vader was the superior fighter. His precognition and danger sense allowed him to anticipate every move Chewbacca made, and his energy blasts and electrokinesis were devastating. In the end, Vader emerged victorious, leaving Chewbacca battered and defeated.\n</code></pre>\n<p>The cUrl command returns the narration of the fight as <code>text/plain</code>.</p>"},{"location":"Super-Heroes-Workshop/#invoking-the-narration-microservice-from-the-fight-microservice","title":"Invoking the Narration Microservice from the Fight Microservice","text":"<p>Now that we have a narration microservice up and running, we can invoke it from the fight microservice.</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#adding-narration-to-the-fight-microservice","title":"Adding narration to the Fight Microservice","text":"<p>We now need to add a new endpoint to the Fight microservice to invoke the Narration microservice. Because it uses a remote call, we need to use the <code>@RegisterRestClient</code> annotation to register the <code>NarrationProxy</code> as a REST client.</p>\n<p>Go back to the <code>io.quarkus.workshop.superheroes.fight.FightResource</code> class and add the new <code>narrateFight</code> method:</p>\n<pre><code>@POST\n@Path(\"/narrate\")\n@Consumes(APPLICATION_JSON)\n@Produces(TEXT_PLAIN)\npublic Response narrateFight(@Valid Fight fight) {\n    logger.debug(\"Narrate the fight \" + fight);\n    String narration = service.narrateFight(fight);\n    return Response.status(Response.Status.CREATED).entity(narration).build();\n\n}\n</code></pre>\n<p>The <code>FightResource</code> invokes a new method of the <code>FightService</code>. Add the following method to the <code>io.quarkus.workshop.superheroes.fight.FightService</code> class and make sure to inject the <code>NarrationProxy</code>:</p>\n<pre><code>@RestClient\nNarrationProxy narrationProxy;\n\npublic String narrateFight(Fight fight) {\n    return narrationProxy.narrate(fight);\n}\n</code></pre>\n<p>Under the <code>client</code> package, where all the other proxies are already located, create a new <code>NarrationProxy</code> class:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\nimport io.quarkus.workshop.superheroes.fight.Fight;\nimport jakarta.ws.rs.Consumes;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n\n@Path(\"/api/narration\")\n@Produces(MediaType.TEXT_PLAIN)\n@Consumes(MediaType.APPLICATION_JSON)\n@RegisterRestClient(configKey = \"narration\")\npublic interface NarrationProxy {\n\n    @POST\n    String narrate(Fight fight);\n}\n</code></pre>\n<p>To link both microservices, we need to add the following configuration to the <code>rest-fights/src/main/resources/application.properties</code> file of the fight microservice:</p>\n<pre><code>quarkus.rest-client.narration.url=http://localhost:8086\n</code></pre>"},{"location":"Super-Heroes-Workshop/#test-and-mock-the-narration-microservice-invocation","title":"Test and mock the Narration microservice invocation","text":"<p>Like the other dependencies, the Narration microservice needs to be mocked so we can test the Fight microservice in isolation.</p>\n<p>Add the following <code>shouldNarrate</code> test to the <code>io.quarkus.workshop.superheroes.fight.FightResourceTest</code> class. And make sure you use the right imports:</p>\n<pre><code>import java.time.Instant;\nimport static jakarta.ws.rs.core.MediaType.TEXT_PLAIN;\n</code></pre>\n<pre><code>@Test\nvoid shouldNarrate() {\n    Fight fight = new Fight();\n    fight.fightDate = Instant.now();\n    fight.winnerName = DEFAULT_WINNER_NAME;\n    fight.winnerLevel = DEFAULT_WINNER_LEVEL;\n    fight.winnerPowers = DEFAULT_WINNER_POWERS;\n    fight.winnerPicture = DEFAULT_WINNER_PICTURE;\n    fight.loserName = DEFAULT_LOSER_NAME;\n    fight.loserLevel = DEFAULT_LOSER_LEVEL;\n    fight.loserPowers = DEFAULT_LOSER_POWERS;\n    fight.loserPicture = DEFAULT_LOSER_PICTURE;\n    fight.winnerTeam = \"villains\";\n    fight.loserTeam = \"heroes\";\n\n    given().body(fight)\n        .header(CONTENT_TYPE, APPLICATION_JSON)\n        .header(ACCEPT, TEXT_PLAIN)\n        .when()\n        .post(\"/api/fights/narrate\")\n        .then()\n        .statusCode(CREATED.getStatusCode())\n        .body(startsWith(\"Lorem ipsum dolor sit amet\"));\n}\n</code></pre>\n<p>Create the <code>io.quarkus.workshop.superheroes.fight.client.MockNarrationProxy</code> class and add the new <code>narrateFight</code> method:</p>\n<pre><code>package io.quarkus.workshop.superheroes.fight.client;\n\nimport io.quarkus.test.Mock;\nimport io.quarkus.workshop.superheroes.fight.Fight;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport org.eclipse.microprofile.rest.client.inject.RestClient;\n\n@Mock\n@ApplicationScoped\n@RestClient\npublic class MockNarrationProxy implements NarrationProxy {\n\n    @Override\n    public String narrate(Fight fight) {\n        return \"\"\"\n            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n            Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n            Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\n            Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n            \"\"\";\n    }\n}\n</code></pre>\n<p>Now execute <code>./mvnw test</code> and make sure that all the tests pass.</p>"},{"location":"Super-Heroes-Workshop/#running-testing-and-packaging-the-application_2","title":"Running, Testing and Packaging the Application","text":"<p>Time to run the entire application! For that, start all the microservices (Heroes, Villains, Fight and Narration) as well as the frontend. When all the microservices are started, access the frontend at http://localhost:8080 and click on the <code>Fight</code> button. The result of the fight is displayed, and below, you have a \"Narrate the fight\" button. Click on it, wait a few seconds (remember that the Narration microservice access a remote AI service that takes time) and the narration of the fight is displayed. Being Generative AI, you can click several times on the button and you will get different narrations.</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#event-driven-and-reactive-microservices","title":"Event-driven and Reactive microservices","text":"<p>So far, we have build microservices that all use HTTP to interact. However, HTTP has significant flaws, such as temporal coupling between the different microservices. If the service is not there or is slow, the caller is directly impacted. Also, it\u2019s hard to guess the capacity of the service you call; maybe you should not call it right now because this service is under heavy load.</p>\n<p>Fortunately, event-driven microservices are rising and avoid most of these issues. By using events (wrapped in messages), the different microservices enforce a looser coupling. Depending on the messaging protocol you use, it may handle durability (avoiding the temporal coupling) and back-pressure (avoiding the overload).</p>\n<p>In this section, we are going to see how Quarkus let you build event-driven microservices. More specially, you are going to see how to:</p>\n<ul>\n<li>\n<p>Send messages and process them</p>\n</li>\n<li>\n<p>Connect a Quarkus application to Apache Kafka</p>\n</li>\n<li>\n<p>Write Kafka records and read them</p>\n</li>\n<li>\n<p>Use reactive programming to compute statistics on the fly</p>\n</li>\n<li>\n<p>Send messages to the browser using web sockets</p>\n</li>\n</ul>\n<p>Quarkus uses MicroProfile Reactive Messaging to interact with Apache Kafka, and other messaging middleware (such as AMQP)</p>\n<p>In this chapter, we are going to use events as a way for microservices to interact. You are going to extend the current system with the <code>stats</code> group depicted on the next figure:</p>\n<p></p>\n<p>When the application persists a new fight, in the fight microservice, you are going to send it to a Kafka topic. These messages are read in the statistics microservice, processed, and the result is sent to a UI using web sockets.</p>\nThis service is exposed on the port 8085."},{"location":"Super-Heroes-Workshop/#sending-messages-to-kafka","title":"Sending Messages to Kafka","text":"<p>In this section, you are going to see how you can send messages to a Kafka topic</p>"},{"location":"Super-Heroes-Workshop/#directory-structure_8","title":"Directory Structure","text":"<p>In this section we are going to extend the Fight microservice. In the following tree, we are going to edit the marked classes</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#adding-the-reactive-messaging-dependency","title":"Adding the Reactive Messaging Dependency","text":"<p>The Kafka extension was already imported during the project creation. In doubt, you can run in the Fight microservice:</p>\n<pre><code>./mvnw quarkus:add-extension -Dextensions=\" io.quarkus:quarkus-messaging-kafka\"\n</code></pre>\n<p>The previous command adds the following dependency:</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-messaging-kafka&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>If not yet started, start the microservice using <code>./mvnw quarkus:dev</code>.</p>\n<p>Quarkus starts a Kafka broker automatically. You can check that by executing the <code>docker container ls</code> command.</p>"},{"location":"Super-Heroes-Workshop/#connecting-imperative-and-reactive-using-an-emitter","title":"Connecting Imperative and Reactive Using an Emitter","text":"<p>Now edit the <code>FightService</code> class. First, add the following field:</p>\n<pre><code>@Channel(\"fights\") Emitter&lt;Fight&gt; emitter;\n</code></pre>\n<p>You will also need to add the following imports:</p><pre><code>import org.eclipse.microprofile.reactive.messaging.Channel;\nimport org.eclipse.microprofile.reactive.messaging.Emitter;</code></pre>\n\n<p>This field is an emitter, and lets you send events or messages (here, we are sending fights) to the channel specified with the <code>@Channel</code> annotation. A channel is a virtual destination.</p>\n<p>In the <code>persistFight</code> method, add the following line just before the <code>return</code> statement:</p>\n<pre><code>emitter.send(fight).toCompletableFuture().join();\n</code></pre>\n<p>With this in place, every time the application persists a <code>fight</code>, it also sends the <code>fight</code> to the <code>fights</code> channel. You may wonder why we need <code>.toCompletableFuture().join()</code>. Sending a message to Kafka is an asynchronous operation, and we need to be sure that the fight is not accessed outside the transaction. Thus, we wait until Kafka confirms the reception before returning.</p>"},{"location":"Super-Heroes-Workshop/#connecting-to-kafka","title":"Connecting to Kafka","text":"<p>At this point, the serialized fights are sent to the <code>fights</code> channel. You need to connect this <code>channel</code> to a Kafka topic.</p>\n<p>For this, edit the <code>application.properties</code> file and add the following properties:</p>\n<pre><code>mp.messaging.outgoing.fights.connector=smallrye-kafka\nmp.messaging.outgoing.fights.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n</code></pre>\n<p>These properties are structured as follows:</p>\n<pre><code>mp.messaging.[incoming|outgoing].channel.attribute=value\n</code></pre>\n<p>For example, <code>mp.messaging.outgoing.fights.connector</code> configures the connector used for the <code>outgoing</code> channel <code>fights</code>.</p>\n<p>The <code>mp.messaging.outgoing.fights.value.serializer</code> configures the serializer used to write the message in Kafka. When omitted, the Kafka topic reuses the channel name (<code>fights</code>).</p>\n<p>Now, you have connected the fight microservice to Kafka, and you are sending new fights to the Kafka topic. Let\u2019s see how you can read these messages in the <code>stats</code> microservice.</p>"},{"location":"Super-Heroes-Workshop/#receiving-messages-from-kafka","title":"Receiving Messages from Kafka","text":"<p>In this section, you are going to see how you can receive messages from a Kafka topic. For this, you are going to create a new microservice, named <code>stats</code>. This microservice computes statistics based on the results of the fights. For example, it determines if villains win more battle than heroes, and who is the superhero or super-villain having won the most fights.</p>"},{"location":"Super-Heroes-Workshop/#directory-structure_9","title":"Directory Structure","text":"<p>In this section, we are going to develop the following structure:</p>\n<p></p>"},{"location":"Super-Heroes-Workshop/#bootstrapping-the-statistics-rest-endpoint","title":"Bootstrapping the Statistics REST Endpoint","text":"<p>Like for the other microservice, the easiest way to create this new Quarkus project is to use a Maven command. Under the <code>quarkus-workshop-super-heroes/super-heroes</code> root directory where you have all your code.</p>\n<p>Open a terminal and run the following command:</p>\n<pre><code>./mvnw io.quarkus:quarkus-maven-plugin:3.9.1:create    -\"DplatformVersion=3.9.1\" -\"DprojectGroupId=io.quarkus.workshop.super-heroes\" -\"DprojectArtifactId=event-statistics\" -DclassName=\"io.quarkus.workshop.superheroes.statistics.StatisticResource\"   -Dpath=\"api/stats\" -Dextensions=\"kafka, resteasy-jackson, websockets\"\n</code></pre>\n<p>If you want your IDE to manage this new Maven project, you can declare it in the parent POM by adding this new module in the <code>&lt;modules&gt;</code> section:</p>\n<pre><code>&lt;module&gt;super-heroes/event-statistics&lt;/module&gt;\n</code></pre>\n<p>Delete all the classes under the <code>io.quarkus.workshop.superheroes.statistics</code> package as well as the associated test classes. There are just examples.</p>"},{"location":"Super-Heroes-Workshop/#consuming-fight","title":"Consuming Fight","text":"<p>This service receives the <code>Fight</code> from the fight microservice. So, naturally, we need a fight class.</p>\n<p>Create the <code>io.quarkus.workshop.superheroes.statistics.Fight</code> class with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nimport java.time.Instant;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class Fight {\n\n    public Instant fightDate;\n    public String winnerName;\n    public int winnerLevel;\n    public String winnerPicture;\n    public String loserName;\n    public int loserLevel;\n    public String loserPicture;\n    public String winnerTeam;\n    public String loserTeam;\n}\n</code></pre>\n<p>We also need to a deserializer that will receive the Kafka record and create the <code>Fight</code> instances. Create the <code>io.quarkus.workshop.superheroes.statistics.FightDeserializer</code> class with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nimport io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n\npublic class FightDeserializer extends ObjectMapperDeserializer&lt;Fight&gt; {\n\n    public FightDeserializer() {\n        super(Fight.class);\n    }\n}\n</code></pre>"},{"location":"Super-Heroes-Workshop/#computing-statistics","title":"Computing Statistics","text":"<p>Now, create the <code>io.quarkus.workshop.superheroes.statistics.SuperStats</code> class with the following content. This class contains two methods annotated with <code>@Incoming</code> and <code>@Outgoing</code>, both consuming the <code>Fight</code> coming from Kafka.</p>\n<p>The <code>computeTeamStats</code> method transforms the fight stream into a stream of ratio indicating the amount of victories for heroes and villains. It calls <code>onItem().transform</code> method for each received fight. It sends the computed ratios on the channel <code>team-stats</code>.</p>\n<p>The <code>computeTopWinners</code> method uses more advanced reactive programming constructs such as <code>group</code> and <code>scan</code>:</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nimport io.smallrye.mutiny.Multi;\nimport org.eclipse.microprofile.reactive.messaging.Incoming;\nimport org.eclipse.microprofile.reactive.messaging.Outgoing;\nimport org.jboss.logging.Logger;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\n\n@ApplicationScoped\npublic class SuperStats {\n\n    @Inject\n    Logger logger;\n\n    private final Ranking topWinners = new Ranking(10);\n    private final TeamStats stats = new TeamStats();\n\n    @Incoming(\"fights\")\n    @Outgoing(\"team-stats\")\n    public Multi&lt;Double&gt; computeTeamStats(Multi&lt;Fight&gt; results) {\n        return results\n            .onItem().transform(stats::add)\n            .invoke(() -&gt; logger.info(\"Fight received. Computed the team statistics\"));\n    }\n\n    @Incoming(\"fights\")\n    @Outgoing(\"winner-stats\")\n    public Multi&lt;Iterable&lt;Score&gt;&gt; computeTopWinners(Multi&lt;Fight&gt; results) {\n        return results\n            .group().by(fight -&gt; fight.winnerName)\n            .onItem().transformToMultiAndMerge(group -&gt;\n                group\n                    .onItem().scan(Score::new, this::incrementScore))\n            .onItem().transform(topWinners::onNewScore)\n            .invoke(() -&gt; logger.info(\"Fight received. Computed the top winners\"));\n    }\n\n    private Score incrementScore(Score score, Fight fight) {\n        score.name = fight.winnerName;\n        score.score = score.score + 1;\n        return score;\n    }\n}\n</code></pre>\n<p>In addition, create the <code>io.quarkus.workshop.superheroes.statistics.Ranking</code>, <code>io.quarkus.workshop.superheroes.statistics.Score</code> and <code>io.quarkus.workshop.superheroes.statistics.TeamStats</code> classes with the following contents:</p>\n<p>Then, create the <code>Ranking</code> class, used to compute a floating top 10, with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\n\npublic class Ranking {\n\n    private final int max;\n\n    private final Comparator&lt;Score&gt; comparator = Comparator.comparingInt(s -&gt; -1 * s.score);\n\n    private final LinkedList&lt;Score&gt; top = new LinkedList&lt;&gt;();\n\n    public Ranking(int size) {\n        max = size;\n    }\n\n    public Iterable&lt;Score&gt; onNewScore(Score score) {\n        // Remove score if already present,\n        top.removeIf(s -&gt; s.name.equalsIgnoreCase(score.name));\n        // Add the score\n        top.add(score);\n        // Sort\n        top.sort(comparator);\n\n        // Drop on overflow\n        if (top.size() &gt; max) {\n            top.remove(top.getLast());\n        }\n\n        return Collections.unmodifiableList(top);\n    }\n}\n</code></pre>\n<p>The <code>Score</code> class is a simple structure storing the name of a hero or villain and its actual score, i.e. the number of won battles.</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nimport io.quarkus.runtime.annotations.RegisterForReflection;\n\n@RegisterForReflection\npublic class Score {\n    public String name;\n    public int score;\n\n    public Score() {\n        this.score = 0;\n    }\n}\n</code></pre>\n<p>The <code>TeamStats</code> class is an object keeping track of the number of battles won by heroes and villains.</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nclass TeamStats {\n\n    private int villains = 0;\n    private int heroes = 0;\n\n    double add(Fight result) {\n        if (result.winnerTeam.equalsIgnoreCase(\"heroes\")) {\n            heroes = heroes + 1;\n        } else {\n            villains = villains + 1;\n        }\n        return ((double) heroes / (heroes + villains));\n    }\n}\n</code></pre>\n<p>The <code>@RegisterForReflection</code> annotation instructs the native compilation to allow reflection access to the class. Without, the serialization/deserialization would not work when running the native executable.</p>"},{"location":"Super-Heroes-Workshop/#reading-messages-from-kafka","title":"Reading Messages from Kafka","text":"<p>It\u2019s now time to connect the <code>fights</code> channel with the Kafka topic.</p>\n<p>Edit the <code>application.properties</code> file and add the following content:</p>\n<pre><code>quarkus.http.port=8085\n\n## Custom banner file path\nquarkus.banner.path=banner.txt\n\n## Kafka configuration\nmp.messaging.incoming.fights.connector=smallrye-kafka\nmp.messaging.incoming.fights.auto.offset.reset=earliest\nmp.messaging.incoming.fights.broadcast=true\n</code></pre>\n<p>As for the writing side, it configures the Kafka connector. The <code>mp.messaging.incoming.fights.auto.offset.reset=earliest</code> property indicates that the topic is read from the earliest available record. Check the Kafka configuration to see all the available settings.</p>"},{"location":"Super-Heroes-Workshop/#sending-events-on-websockets","title":"Sending Events on WebSockets","text":"<p>At this point, you read the fights from Kafka and computes statistics. Actually, even if you start the application, nothing will happen as nobody consumes these statistics.</p>\n<p>In this section, we are going to consume these statistics and send them to two WebSockets. For this, we are going to add two classes and a simple presentation page:</p>\n<ul>\n<li>\n<p><code>TeamStatsWebSocket</code></p>\n</li>\n<li>\n<p><code>TopWinnerWebSocket</code></p>\n</li>\n<li>\n<p><code>index.html</code></p>\n</li>\n</ul>\n<p>Quarkus uses the JSR 356 providing an annotation-driven approach to implement WebSockets.</p>"},{"location":"Super-Heroes-Workshop/#the-teamstats-websocket","title":"The TeamStats WebSocket","text":"<p>Create the <code>io.quarkus.workshop.superheroes.statistics.TeamStatsWebSocket</code> class with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nimport io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.subscription.Cancellable;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport org.eclipse.microprofile.reactive.messaging.Channel;\nimport org.jboss.logging.Logger;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.websocket.OnClose;\nimport jakarta.websocket.OnOpen;\nimport jakarta.websocket.Session;\nimport jakarta.websocket.server.ServerEndpoint;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n@ServerEndpoint(\"/stats/team\")\n@ApplicationScoped\npublic class TeamStatsWebSocket {\n\n    @Channel(\"team-stats\")\n    Multi&lt;Double&gt; stream;\n\n    @Inject Logger logger;\n\n    private final List&lt;Session&gt; sessions = new CopyOnWriteArrayList&lt;&gt;();\n    private Cancellable cancellable;\n\n    @OnOpen\n    public void onOpen(Session session) {\n        sessions.add(session);\n    }\n\n    @OnClose\n    public void onClose(Session session) {\n        sessions.remove(session);\n    }\n\n    @PostConstruct\n    public void subscribe() {\n        cancellable = stream.subscribe()\n            .with(ratio -&gt; sessions.forEach(session -&gt; write(session, ratio)));\n    }\n\n    @PreDestroy\n    public void cleanup() {\n        cancellable.cancel();\n    }\n\n    private void write(Session session, double ratio) {\n        session.getAsyncRemote().sendText(Double.toString(ratio), result -&gt; {\n            if (result.getException() != null) {\n                logger.error(\"Unable to write message to web socket\", result.getException());\n            }\n        });\n    }\n}\n</code></pre>\n<p>This component is a WebSocket as specified by the <code>@ServerEndpoint(\"/stats/team\")</code> annotation. It handles the <code>/stats/team</code> WebSocket.</p>\n<p>When a client (like a browser) connects to the WebSocket, it keeps track of the session. This session is released when the client disconnects.</p>\n<p>The <code>TeamStatsWebSocket</code> also injects a <code>Multi</code> attached to the <code>team-stats</code> channel. After creation, the component subscribes to this stream and broadcasts the fights to the different clients connected to the web socket.</p>\n<p>The subscription is an essential part of the stream lifecycle. It indicates that someone is interested in the items transiting on the stream, and it triggers the emission. In this case, it triggers the connection to Kafka and starts receiving the messages from Kafka. Without it, items would not be emitted.</p>"},{"location":"Super-Heroes-Workshop/#the-topwinner-websocket","title":"The TopWinner WebSocket","text":"<p>The <code>io.quarkus.workshop.superheroes.statistics.TopWinnerWebSocket</code> follows the same pattern but subscribes to the <code>winner-stats</code> channel.</p>\n<p>Create the <code>io.quarkus.workshop.superheroes.statistics.TopWinnerWebSocket</code> with the following content:</p>\n<pre><code>package io.quarkus.workshop.superheroes.statistics;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.subscription.Cancellable;\nimport io.smallrye.mutiny.unchecked.Unchecked;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport org.eclipse.microprofile.reactive.messaging.Channel;\nimport org.jboss.logging.Logger;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.websocket.OnClose;\nimport jakarta.websocket.OnOpen;\nimport jakarta.websocket.Session;\nimport jakarta.websocket.server.ServerEndpoint;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n@ServerEndpoint(\"/stats/winners\")\n@ApplicationScoped\npublic class TopWinnerWebSocket {\n\n    @Inject ObjectMapper mapper;\n\n    @Inject Logger logger;\n\n    @Channel(\"winner-stats\")\n    Multi&lt;Iterable&lt;Score&gt;&gt; winners;\n\n    private final List&lt;Session&gt; sessions = new CopyOnWriteArrayList&lt;&gt;();\n    private Cancellable cancellable;\n\n    @OnOpen\n    public void onOpen(Session session) {\n        sessions.add(session);\n    }\n\n    @OnClose\n    public void onClose(Session session) {\n        sessions.remove(session);\n    }\n\n    @PostConstruct\n    public void subscribe() {\n        cancellable = winners\n            .map(Unchecked.function(scores -&gt; mapper.writeValueAsString(scores)))\n            .subscribe().with(serialized -&gt; sessions.forEach(session -&gt; write(session, serialized)));\n    }\n\n    @PreDestroy\n    public void cleanup() {\n        cancellable.cancel();\n    }\n\n    private void write(Session session, String serialized) {\n        session.getAsyncRemote().sendText(serialized, result -&gt; {\n            if (result.getException() != null) {\n                logger.error(\"Unable to write message to web socket\", result.getException());\n            }\n        });\n    }\n}\n</code></pre>\n<p>Because the items (top 10) need to be serialized, the <code>TopWinnerWebSocket</code> also use Jackson to transform the object into a serialized form.</p>"},{"location":"Super-Heroes-Workshop/#the-ui","title":"The UI","text":"<p>Finally, you need a UI to watch these live statistics.</p>\n<p>Replace the <code>META-INF/resources/index.html</code> file with the following content:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Super Battle Stats&lt;/title&gt;\n\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css\"&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css\"&gt;\n\n    &lt;style&gt;\n        .page-title {\n            font-size: xx-large;\n        }\n\n        .progress {\n            background-color: firebrick;\n        }\n\n        .progress-bar {\n            background: dodgerblue;\n        }\n\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=\"container\"&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;div class=\"col\"&gt;&lt;h1 class=\"page-title\"&gt;Super Stats&lt;/h1&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"container container-cards-pf\"&gt;\n    &lt;div class=\"row row-cards-pf\"&gt;\n        &lt;div class=\"col-xs-12 col-sm-6 col-md-4 col-lg-3\"&gt;\n            &lt;!-- Top winners --&gt;\n            &lt;div class=\"card-pf card-pf-view card-pf-view-select\"&gt;\n                &lt;h2 class=\"card-pf-title\"&gt;\n                    &lt;i class=\"fa fa-trophy\"&gt;&lt;/i&gt; Top Winner\n                &lt;/h2&gt;\n                &lt;div class=\"card-pf-body\"&gt;\n                    &lt;div id=\"top-winner\"&gt;\n\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"col-xs-12 col-sm-8 col-md-6 col-lg-6\"&gt;\n            &lt;!-- Top losers --&gt;\n            &lt;div class=\"card-pf card-pf-view card-pf-view-select\"&gt;\n                &lt;h2 class=\"card-pf-title\"&gt;\n                    &lt;i class=\"fa pficon-rebalance\"&gt;&lt;/i&gt; Heroes vs. Villains\n                &lt;/h2&gt;\n                &lt;div class=\"card-pf-body\"&gt;\n                    &lt;div class=\"progress-container progress-description-left progress-label-right\"&gt;\n                        &lt;div class=\"progress-description\"&gt;\n                            Heroes\n                        &lt;/div&gt;\n                        &lt;div class=\"progress\"&gt;\n                            &lt;div id=\"balance\" class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"50\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 50%;\"&gt;\n                                &lt;span&gt;Villains&lt;/span&gt;\n                            &lt;/div&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/js/patternfly.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.11/c3.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js\"&gt;&lt;/script&gt;\n\n&lt;script&gt;\n    $(document).ready(function() {\n        var host = window.location.host;\n        var protocol = (window.location.protocol == \"https:\") ? \"wss\" : \"ws\";\n\n        var top = new WebSocket(protocol + \"://\" + host + \"/stats/winners\");\n        top.onmessage = function (event) {\n            updateTop(event.data);\n        };\n        var team = new WebSocket(protocol + \"://\" + host + \"/stats/team\");\n        team.onmessage = function(event) {\n            console.log(event.data);\n            updateRatio(event.data);\n        };\n    });\n\n\n    function updateTop(scores) {\n        $(\"#top-winner\").children(\"p\").remove();\n        JSON.parse(scores).forEach(function(score) {\n            $(\"#top-winner\").append($(\"&lt;p&gt;\" + score.name + \" [\" + score.score + \"]&lt;/p&gt;\"))\n        });\n    }\n\n    function updateRatio(ratio) {\n        var percent = ratio * 100;\n        $(\"#balance\").attr(\"aria-valuenow\", ratio * 100).attr(\"style\", \"width: \" + percent + \"%;\");\n    }\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#running-the-application_3","title":"Running the Application","text":"<p>You are all set!</p>\n<p>Time to start the application using:</p>\n<p>Then, open <code>[http://localhost:8085](http://localhost:8085/)</code> in a new browser window. Trigger some fights, and you should see the live statistics moving.</p>\n<p></p>\n<p>Quarkus automatically reuse the Kafka broker from the fight service. So, make sure the fight service is started.</p>"},{"location":"Super-Heroes-Workshop/#building-native-executables","title":"Building Native Executables","text":"<p>Let\u2019s now produce native executables for our application. Thanks to its GraalVM integration, Quarkus can easily generate native executables. Just like Go, native executables don\u2019t need a VM to run; they contain the whole application, like an <code>.exe</code> file on Windows.</p>"},{"location":"Super-Heroes-Workshop/#building-native-executables-with-quarkus","title":"Building Native Executables with Quarkus","text":"<p>Having native executables for our microservices improves their startup time and produces a minimal disk footprint. This can be a big plus if your microservices run in a serverless environment where scaling from zero is important. The produced binary has everything to run the application, including the needed parts of the \"JVM\" (shrunk to be just enough to run the application), and the application itself.</p>\n<p>Choosing JVM execution vs. native executable execution depends on your application needs and environment.</p>\n\n<p>To be able to build native executables, you need GraalVM to be installed. And make sure you have the <code>GRAALVM_HOME</code> environment variable defined and pointing to where you installed GraalVM. Then, if you look at all the <code>pom.xml</code> files, you will find the following profile. This allows you to build a native executable just by invoking <code>./mvnw package -Pnative</code>.</p>\n<pre><code>&lt;profile&gt;\n    &lt;id&gt;native&lt;/id&gt;\n    &lt;activation&gt;\n        &lt;property&gt;\n            &lt;name&gt;native&lt;/name&gt;\n        &lt;/property&gt;\n    &lt;/activation&gt;\n    &lt;properties&gt;\n        &lt;skipITs&gt;false&lt;/skipITs&gt;\n        &lt;quarkus.package.type&gt;native&lt;/quarkus.package.type&gt;\n    &lt;/properties&gt;\n&lt;/profile&gt;\n</code></pre>"},{"location":"Super-Heroes-Workshop/#building-native-executables-for-our-microservices","title":"Building Native Executables for our Microservices","text":"<p>Let\u2019s create native executables for all our microservices. Well, maybe not all of them. Let\u2019s see.</p>\n<p>From the root <code>super-heroes</code> directory, run the following commands (to speed up the compilation you can also skip the tests by adding <code>-Dmaven.test.skip=true</code>):</p>\n<pre><code>./mvnw --file rest-fights/pom.xml package -Pnative\n./mvnw --file rest-heroes/pom.xml package -Pnative\n./mvnw --file rest-villains/pom.xml package -Pnative\n./mvnw --file ui-super-heroes/pom.xml package -Pnative\n./mvnw --file event-statistics/pom.xml package -Pnative\n</code></pre>\n<p>Creating a native executable requires a lot of memory and CPU. It also takes a few minutes, even for a simple application like the Villain microservice. Most of the time is spent during the dead code elimination, as it traverses the whole (closed) world.</p>\n\n<p>During the compilation of each microservice, you see a lot of information about the native compilation. Below is a summary of the output for that you will get.</p>\n<pre><code>===========================================================================================\nGraalVM Native Image: Generating 'rest-heroes-1.0.0-SNAPSHOT-runner' (executable)...\n===========================================================================================\n[1/8] Initializing...                                                      (24.3s @ 0.53GB)\n[2/8] Performing analysis...\n[3/8] Building universe...                                                  (6.9s @ 4.64GB)\n[4/8] Parsing methods...      [***]                                         (5.1s @ 2.80GB)\n[5/8] Inlining methods...     [***]                                         (2.1s @ 4.71GB)\n[6/8] Compiling methods...    [********]                                  (67.6s @ 10.11GB)\n[7/8] Layouting methods...    [***]                                         (9.4s @ 4.04GB)\n[8/8] Creating image...       [***]                                         (9.1s @ 5.41GB)\n</code></pre>\n<p>If you try to execute <code>./mvnw package -Pnative</code> in the Narration microservice, the compilation will fail. You will get something like this:</p>\n<pre><code>===========================================================================================\nGraalVM Native Image: Generating 'rest-narration-1.0.0-SNAPSHOT-runner' (executable)...\n===========================================================================================\n[1/8] Initializing...                                                      (24.3s @ 0.53GB)\n[2/8] Performing analysis...\nERROR [com.azu.cor.imp.jac.XmlMapperFactory] Failed to retrieve MethodHandles used to create XmlMapper. XML serialization won't be supported until 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml'\nERROR [com.azu.cor.imp.jac.ObjectMapperShim] Package versions: jackson-core=2.15.2, jackson-databind=2.15.2, jackson-dataformat-xml=unknown, jackson-datatype-jsr310=2.15.2\nError: Classes that should be initialized at run time got initialized during image building\n</code></pre>\n<p>That\u2019s because the Narration microservice uses external libraries that are not easily compilable with GraaVM. Not all libraries are compatible with GraalVM out of the box. Therefore, we will keep on running the Narration microservice in JVM mode, not in native mode.</p>\n<pre><code>./mvnw --file rest-narration/pom.xml clean package\n</code></pre>\n<p>Do you remember the <code>@RegisterForReflection</code> annotation that we used in the Statistics microservice? Well, this annotation instructs the native compilation to allow reflection access to the class. Without it, the serialization/deserialization would not work when running the native executable. This information is required when running the application as a native executable.</p>"},{"location":"Super-Heroes-Workshop/#running-the-application-in-native-mode","title":"Running the Application in Native mode","text":"<p>The native compilation takes a while. In addition to the regular files, the build also produces <code>target/xxx-yyy-1.0.0-SNAPSHOT-runner</code> files. Notice that there is no <code>.jar</code> file extension. It\u2019s just a binary file that you can execute directly like any other binary. Let\u2019s execute the entire application in native mode.</p>\n<p>Native mode is using the <code>prod</code> profile, meaning that the infrastructure needs to be up and running (<code>docker compose -f docker-compose.yaml up -d</code>). Then, from the root <code>super-heroes</code> directory, run the following commands (to speed up the compilation you can also skip the tests by adding <code>-Dmaven.test.skip=true</code>):</p>\n<pre><code>./rest-fights/target/rest-fights-1.0.0-SNAPSHOT-runner\n./rest-heroes/target/rest-heroes-1.0.0-SNAPSHOT-runner\n./rest-villains/target/rest-villains-1.0.0-SNAPSHOT-runner\n./ui-super-heroes/target/ui-super-heroes-1.0.0-SNAPSHOT-runner\n./event-statistics/target/event-statistics-1.0.0-SNAPSHOT-runner\n./rest-narration/target/quarkus-app/quarkus-run.jar\n</code></pre>"},{"location":"Super-Heroes-Workshop/#building-containers","title":"Building Containers","text":"<p>In this chapter we will build containers out of our Quarkus microservices and execute them locally thanks to Docker Compose. Thanks to Quarkus Cloud Native capabilities, we will be able to build and execute containers easily. We will also produce Linux 64 bits native executables and runs them in a container. The native compilation uses the OS and architecture of the host system.</p>"},{"location":"Super-Heroes-Workshop/#building-containers-with-quarkus","title":"Building Containers with Quarkus","text":"<p>When we bootstrapped our microservices with the Maven Quarkus plugin, a set of <code>Dockerfiles</code> have been generated under <code>src/main/docker</code>:</p>\n<ul>\n<li>\n<p><code>Dockerfile.jvm</code>: Dockerfile is used in order to build a container that runs the Quarkus application in JVM mode.</p>\n</li>\n<li>\n<p><code>Dockerfile.legacy-jar</code>: Deprecated Dockerfile building a container in JVM mode.</p>\n</li>\n<li>\n<p><code>Dockerfile.native</code>: Dockerfile is used in order to build a container that runs the Quarkus application in native (no JVM) mode.</p>\n</li>\n<li>\n<p><code>Dockerfile.native-micro</code>: Same as above but it uses a micro base image, tuned for Quarkus native executables.</p>\n</li>\n</ul>\n<p>Quarkus is able to build a container image automatically. It proposes multiple approaches to do so, but we recommend using jib. As you have guessed by now, using jib is as simple as adding a Quarkus extension to each project.</p>"},{"location":"Super-Heroes-Workshop/#building-containers-for-our-microservices-in-jvm-mode","title":"Building Containers for our Microservices in JVM Mode","text":"<p>The <code>Dockerfile.jvm</code> file is for running the application in JVM mode. It looks like this:</p>\n<pre><code>FROM registry.access.redhat.com/ubi8/openjdk-17:1.18\n\nENV LANGUAGE='en_US:en'\n\n\n# We make four distinct layers so if there are application changes the library layers can be re-used\nCOPY --chown=185 target/quarkus-app/lib/ /deployments/lib/\nCOPY --chown=185 target/quarkus-app/*.jar /deployments/\nCOPY --chown=185 target/quarkus-app/app/ /deployments/app/\nCOPY --chown=185 target/quarkus-app/quarkus/ /deployments/quarkus/\n\nEXPOSE 8080\nUSER 185\nENV JAVA_OPTS_APPEND=\"-Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss.logmanager.LogManager\"\nENV JAVA_APP_JAR=\"/deployments/quarkus-run.jar\"\n\nENTRYPOINT [ \"/opt/jboss/container/java/run/run-java.sh\" ]\n</code></pre>\n<p>To start using it, we first need to install the jib extension in all our projects.</p>\n<p>Add the <code>quarkus-container-image-jib</code> extension executing the following commands from the root <code>super-heroes</code> directory:</p>\n<pre><code>./mvnw --file rest-fights/pom.xml quarkus:add-extension -Dextensions=\"jib\"\n./mvnw --file rest-heroes/pom.xml quarkus:add-extension -Dextensions=\"jib\"\n./mvnw --file rest-villains/pom.xml quarkus:add-extension -Dextensions=\"jib\"\n./mvnw --file ui-super-heroes/pom.xml quarkus:add-extension -Dextensions=\"jib\"\n./mvnw --file event-statistics/pom.xml quarkus:add-extension -Dextensions=\"jib\"\n./mvnw --file rest-narration/pom.xml quarkus:add-extension -Dextensions=\"jib\"\n</code></pre>\n<p>It adds the following dependency to the <code>pom.xml</code> files:</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-container-image-jib&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Then, from the root <code>super-heroes</code> directory, execute the following commands to build the applications and create the container image (add <code>-Dmaven.test.skip=true</code> if you want to skip the tests):</p>\n<pre><code>./mvnw --file rest-fights/pom.xml clean package -Dquarkus.container-image.build=true\n./mvnw --file rest-heroes/pom.xml clean package -Dquarkus.container-image.build=true\n./mvnw --file rest-villains/pom.xml clean package -Dquarkus.container-image.build=true\n./mvnw --file ui-super-heroes/pom.xml clean package -Dquarkus.container-image.build=true\n./mvnw --file event-statistics/pom.xml clean package -Dquarkus.container-image.build=true\n./mvnw --file rest-narration/pom.xml clean package -Dquarkus.container-image.build=true\n</code></pre>\n<p>Check that you have all the Docker images installed locally:</p>\n<p>The output should look like this:</p>\n<pre><code>REPOSITORY                      TAG                  IMAGE ID       SIZE\n&lt;org&gt;/rest-fights             1.0.0-SNAPSHOT       adb8a546a66b   419MB\n&lt;org&gt;/rest-heroes             1.0.0-SNAPSHOT       d9e6ae6e3e23   402MB\n&lt;org&gt;/rest-villains           1.0.0-SNAPSHOT       60a5c813f59a   402MB\n&lt;org&gt;/ui-super-heroes         1.0.0-SNAPSHOT       82fce62c11a5   379MB\n&lt;org&gt;/event-statistics        1.0.0-SNAPSHOT       a5472c5bd576   395MB\n&lt;org&gt;/rest-narration          1.0.0-SNAPSHOT       fcfe334594f3   390MB\n</code></pre>"},{"location":"Super-Heroes-Workshop/#running-jvm-mode-containers-locally","title":"Running JVM Mode Containers Locally","text":"<p>Now that we have all our Docker images created, let\u2019s execute them all to be sure that everything is working.</p>\n<p>Under <code>super-heroes/infrastructure</code> you will find the <code>docker-compose-app-local.yaml</code> file. It declares all the needed infrastructure (databases, Kafka) as well as our microservices.</p>\n<p>In the <code>docker-compose-app-local.yaml</code> file, you need to update the <code>image</code> property of each microservice to match the name of the image you just built. For example, replace <code>quarkus/rest-villains</code> by <code>/rest-villains (&lt;`org`&gt; being your DockerHub / Quay.io username).\n\n<p>Execute it with:</p>\n<pre><code>docker compose -f docker-compose-app-local.yaml up\n</code></pre>\n<p>To know that all your containers are started, you can use the following command:</p>\n<pre><code>docker compose -f docker-compose-app-local.yaml ps\n</code></pre>\n<p>You should get something similar to the following list. Make sure all your containers are in running status:</p>\n<pre><code>NAME               IMAGE                                         STATUS         PORTS\nui-super-heroes    agoncal&lt;org/ui-super-heroes:1.0.0-SNAPSHOT    Up             0.0.0.0:8080-&gt;8080/tcp\nrest-fights        agoncal&lt;org/rest-fights:1.0.0-SNAPSHOT        Up             0.0.0.0:8082-&gt;8082/tcp\nrest-heroes        agoncal&lt;org/rest-heroes:1.0.0-SNAPSHOT        Up             0.0.0.0:8083-&gt;8083/tcp\nrest-villains      agoncal&lt;org/rest-villains:1.0.0-SNAPSHOT      Up             0.0.0.0:8084-&gt;8084/tcp\nevent-statistics   agoncal&lt;org/event-statistics:1.0.0-SNAPSHOT   Up             0.0.0.0:8085-&gt;8085/tcp\nrest-narration     agoncal&lt;org/rest-narration:1.0.0-SNAPSHOT     Up             0.0.0.0:8086-&gt;8086/tcp\nsuper-database     postgres:14                                   Up (healthy)   0.0.0.0:5432-&gt;5432/tcp\nsuper-kafka        quay.io/strimzi/kafka:0.28.0-kafka-3.1.0      Up             0.0.0.0:9092-&gt;9092/tcp\n</code></pre>\n<p>Once all the containers are started, you can:</p>\n<ul>\n<li>\n<p>Go to http://localhost:8080 to check the main UI</p>\n</li>\n<li>\n<p>Go to http://localhost:8085 to check the statistics UI</p>\n</li>\n<li>\n<p>curl http://localhost:8084/api/villains | jq</p>\n</li>\n<li>\n<p>curl http://localhost:8083/api/heroes | jq</p>\n</li>\n<li>\n<p>curl http://localhost:8082/api/fights/randomfighters | jq</p>\n</li>\n</ul>\n<p>Then, make sure you shut down the entire application with:</p>\n<pre><code>docker compose -f docker-compose-app-local.yaml down\n</code></pre>"},{"location":"Super-Heroes-Workshop/#building-containers-for-our-microservices-in-native-mode","title":"Building Containers for our Microservices in Native Mode","text":"<p>And\u2026 Linux Containers are \u2026 Linux. So before being able to build a container with our native executable, we need to produce compatible native executables. If you are using a Linux 64 bits machine, you are good to go. If not, Quarkus comes with a trick to produce these executable:</p>\n<p>The <code>Dockerfile.native</code> file is for running the application in native mode. It looks like this:</p>\n<pre><code>FROM registry.access.redhat.com/ubi8/ubi-minimal:8.9\nWORKDIR /work/\nRUN chown 1001 /work \\\n    &amp;amp;&amp;amp; chmod \"g+rwX\" /work \\\n    &amp;amp;&amp;amp; chown 1001:root /work\nCOPY --chown=1001:root target/*-runner /work/application\n\nEXPOSE 8080\nUSER 1001\n\nENTRYPOINT [\"./application\", \"-Dquarkus.http.host=0.0.0.0\"]\n</code></pre>\n<pre><code>./mvnw clean package -Pnative -Dquarkus.native.container-build=true -DskipTests\n</code></pre>\n<p>The <code>-Dquarkus.native.container-build=true</code> allows running the native compilation inside a container (provided by Quarkus). The result is a Linux 64 bits executable.</p>\n<p>Building a native executable takes time, CPU, and memory. It\u2019s even more accurate in the container. So, first, be sure that your container system has enough memory to build the executable. It requires at least 6Gb of memory, 8Gb is recommended.</p>\n\n<p>Execute the above command for all our microservices. We also copy the UI into the fight service, to simplify the process:</p>\n<pre><code>cd rest-hero\n./mvnw clean package -Pnative -Dquarkus.native.container-build=true -DskipTests\ncd ..\ncd rest-villains\n./mvnw clean package -Pnative -Dquarkus.native.container-build=true -DskipTests\ncd ..\ncd rest-fight\ncp -R ../ui-super-heroes/dist/* src/main/resources/META-INF/resources\n./mvnw clean package -Pnative -Dquarkus.native.container-build=true -DskipTests\ncd ..\ncd event-statistics\n./mvnw clean package -Pnative -Dquarkus.native.container-build=true -DskipTests\ncd ..\n</code></pre>"},{"location":"Super-Heroes-Workshop/#building-native-containers","title":"Building native containers","text":"<p>Now that we have the native executables, we can build containers. When you create projects, Quarkus generates two <code>Dockerfiles</code>:</p>\n<ol>\n<li>\n<p><code>Dockerfile.jvm</code> - A <code>Dockerfile</code> for running the application in JVM mode</p>\n</li>\n<li>\n<p><code>Dockerfile.native</code> - A <code>Dockerfile</code> for running the application in native mode</p>\n</li>\n</ol>\n<p>We are interested in this second file. Open one of these <code>Dockerfile.native</code> files:</p>\n<pre><code>FROM registry.access.redhat.com/ubi8/ubi-minimal\nWORKDIR /work/\nCOPY target/*-runner /work/application\nRUN chmod 775 /work\nEXPOSE 8080\nCMD [\"./application\", \"-Dquarkus.http.host=0.0.0.0\"]\n</code></pre>\n<p>It\u2019s a pretty straightforward <code>Dockerfile</code> taking a minimal base image and copying the generated native executable. It also exposes the port 8080. Wait, our microservices are not configured to run on the port 8080. We need to override this property as well as a few other such as the HTTP client endpoints, and database locations.</p>\n<p>To build the containers, use the following scripts:</p>\n<pre><code>export ORG=xxxx\ncd rest-hero\ndocker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-hero .\ncd ..\ncd rest-villains\ndocker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-villain .\ncd ..\ncd rest-fight\ndocker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-fight .\ncd ..\ncd event-statistics\ndocker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-stats .\ncd ..\n</code></pre>\n<p>Replace <code>ORG</code> with your DockerHub / Quay.io username.</p>"},{"location":"Super-Heroes-Workshop/#running-native-mode-containers-locally","title":"Running Native Mode Containers Locally","text":""},{"location":"Super-Heroes-Workshop/#building-a-container-running-a-native-executable","title":"Building a container running a native executable","text":"<p>We\u2019ve just created a container that embeds the Java application and a JVM. But you can also build and use the native executable. To do this, runs the following command:</p>\n<pre><code>./mvnw clean package -Dquarkus.container-image.build=true -Pnative -Dquarkus.native.container-build=true\n</code></pre>\n<p><code>-Dquarkus.native.container-build=true</code> is indicating that we need a Linux 64bits executable. This option is not required if you use Linux.</p>"},{"location":"Super-Heroes-Workshop/#deploying-with-kubernetes","title":"Deploying with Kubernetes","text":"<p>This chapter explores how you can deploy containerized Quarkus applications in Cloud platforms using Kubernetes. There are many different approaches to achieve these deployments. In this chapter, we are focusing on deploying our containers in Kubernetes.</p>"},{"location":"Super-Heroes-Workshop/#deploying-on-kubernetes","title":"Deploying on Kubernetes","text":"<p>This section is going to deploy our microservices on Kubernetes. It is required to have access to a Kubernetes or OpenShift cluster.</p>\n<p>To deploy your microservices, push the built container images to an image registry accessible by your cluster, such as Quay.io or DockerHub.</p>\n\n<p>We recommend using a specific namespace to deploy your system. In the following sections, we use the <code>quarkus-workshop</code> namespace.</p>"},{"location":"Super-Heroes-Workshop/#deploying-the-infrastructure","title":"Deploying the infrastructure","text":"<p>The first thing to deploy is the required infrastructure:</p>\n<ul>\n<li>\n<p>3 PostgreSQL instances</p>\n</li>\n<li>\n<p>Kafka brokers (3 brokers with 3 Zookeeper to follow the recommended approach)</p>\n</li>\n</ul>\n<p>There are many ways to deploy this infrastructure. Here, we are going to use two operators:</p>\n<ul>\n<li>\n<p>PostgreSQL Operator by Dev4Ddevs.com</p>\n</li>\n<li>\n<p>Strimzi Apache Kafka Operator by Red Hat</p>\n</li>\n</ul>\n<p>With these operators installed, you can create the required infrastructure with the following custom resource definition (CRD):</p>\n<pre><code>apiVersion: postgresql.dev4devs.com/v1alpha1\nkind: Database\nmetadata:\n    name: heroes-database\n    namespace: quarkus-workshop\nspec:\n    databaseCpu: 30m\n    databaseCpuLimit: 60m\n    databaseMemoryLimit: 512Mi\n    databaseMemoryRequest: 128Mi\n    databaseName: heroes-database\n    databaseNameKeyEnvVar: POSTGRESQL_DATABASE\n    databasePassword: superman\n    databasePasswordKeyEnvVar: POSTGRESQL_PASSWORD\n    databaseStorageRequest: 1Gi\n    databaseUser: superman\n    databaseUserKeyEnvVar: POSTGRESQL_USER\n    image: centos/postgresql-96-centos7\n    size: 1\n</code></pre>\n<p>This CRD creates the database for the Hero microservice. Duplicate this CRD for the fight and villain databases.</p>\n<p>For the Kafka broker, create the following CRD:</p>\n<pre><code>apiVersion: kafka.strimzi.io/v1beta1\nkind: Kafka\nmetadata:\n  name: my-kafka\n  namespace: quarkus-workshop\nspec:\n  kafka:\n    version: 2.3.0\n    replicas: 3\n    listeners:\n      plain: {}\n      tls: {}\n    config:\n      offsets.topic.replication.factor: 3\n      transaction.state.log.replication.factor: 3\n      transaction.state.log.min.isr: 2\n      log.message.format.version: '2.3'\n    storage:\n      type: ephemeral\n  zookeeper:\n    replicas: 3\n    storage:\n      type: ephemeral\n  entityOperator:\n    topicOperator: {}\n    userOperator: {}\n</code></pre>\n<p>This CRD creates the brokers and the Zookeeper instances.</p>\n<p>It\u2019s also recommended to create the topic.</p>\n<p>For this, create the following CRD:</p>\n<pre><code>apiVersion: kafka.strimzi.io/v1beta1\nkind: KafkaTopic\nmetadata:\n  name: fights\n  labels:\n    strimzi.io/cluster: my-kafka\n  namespace: quarkus-workshop\nspec:\n  partitions: 1\n  replicas: 3\n  config:\n    retention.ms: 604800000\n    segment.bytes: 1073741824\n</code></pre>\n<p>Once everything is created, you should have the following resources:</p>\n<pre><code>$ kubectl get database\nNAME                AGE\nfights-database     16h\nheroes-database     16h\nvillains-database   16h\n\n$ kubectl get kafka\nNAME       DESIRED KAFKA REPLICAS   DESIRED ZK REPLICAS\nmy-kafka   3\n</code></pre>"},{"location":"Super-Heroes-Workshop/#deploying-the-hero-villain-microservices","title":"Deploying the Hero &amp; Villain microservices","text":"<p>Now that the infrastructure is in place, we can deploy our microservices. Let\u2019s start with the hero and villain microservices.</p>\n<p>For each, we need to override the port and data source URL.</p>\n<p>Create a config map with the following content:</p>\n<p>Listing 1. config-hero.yaml</p>\n<pre><code>apiVersion: v1\ndata:\n    port: \"8080\"\n    database: \"jdbc:postgresql://heroes-database:5432/heroes-database\"\nkind: ConfigMap\nmetadata:\n    name: hero-config\n</code></pre>\n<p>Do the same for the villain microservice. Then, apply these resources:</p>\n<pre><code>$ kubectl apply -f config-hero.yaml\n$ kubectl apply -f config-villain.yaml\n</code></pre>\n<p>Once the config maps are created, we can deploy the microservices.</p>\n<p>Create a <code>deployment-hero.yaml</code> file with the following content:</p>\n<pre><code>apiVersion: \"v1\"\nkind: \"List\"\nitems:\n    - apiVersion: \"v1\"\n      kind: \"Service\"\n      metadata:\n          labels:\n              app: \"quarkus-workshop-hero\"\n              version: \"01\"\n              group: \"$ORG\"\n          name: \"quarkus-workshop-hero\"\n      spec:\n          ports:\n              - name: \"http\"\n                port: 8080\n                targetPort: 8080\n          selector:\n              app: \"quarkus-workshop-hero\"\n              version: \"01\"\n              group: \"$ORG\"\n          type: \"ClusterIP\"\n    - apiVersion: \"apps/v1\"\n      kind: \"Deployment\"\n      metadata:\n          labels:\n              app: \"quarkus-workshop-hero\"\n              version: \"01\"\n              group: \"$ORG\"\n          name: \"quarkus-workshop-hero\"\n      spec:\n          replicas: 1\n          selector:\n              matchLabels:\n                  app: \"quarkus-workshop-hero\"\n                  version: \"01\"\n                  group: \"$ORG\"\n          template:\n              metadata:\n                  labels:\n                      app: \"quarkus-workshop-hero\"\n                      version: \"01\"\n                      group: \"$ORG\"\n              spec:\n                  containers:\n                      - image: \"$ORG/quarkus-workshop-hero:latest\"\n                        imagePullPolicy: \"IfNotPresent\"\n                        name: \"quarkus-workshop-hero\"\n                        ports:\n                            - containerPort: 8080\n                              name: \"http\"\n                              protocol: \"TCP\"\n                        env:\n                            - name: \"KUBERNETES_NAMESPACE\"\n                              valueFrom:\n                                  fieldRef:\n                                      fieldPath: \"metadata.namespace\"\n\n                            - name: QUARKUS_DATASOURCE_URL\n                              valueFrom:\n                                  configMapKeyRef:\n                                      name: hero-config\n                                      key: database\n\n                            - name: QUARKUS_HTTP_PORT\n                              valueFrom:\n                                  configMapKeyRef:\n                                      name: hero-config\n                                      key: port\n</code></pre>\n<p>This descriptor declares:</p>\n<ol>\n<li>\n<p>A service to expose the HTTP endpoint</p>\n</li>\n<li>\n<p>A deployment that instantiates the application</p>\n</li>\n</ol>\n<p>The deployment declares one container using the container image we built earlier. It also overrides the configuration for the HTTP port and database URL.</p>\n<p>Don\u2019t forget to create the equivalent files for the villain microservice.</p>\n<p>Then, deploy the microservice with:</p>\n<pre><code>$ kubectl apply -f deployment-hero.yaml\n$ kubectl apply -f deployment-villain.yaml\n</code></pre>"},{"location":"Super-Heroes-Workshop/#deploying-the-fight-microservice","title":"Deploying the Fight microservice","text":"<p>Follow the same approach for the fight microservice. Note that there are more properties to configure from the config map:</p>\n<ul>\n<li>\n<p>The location of the hero and villain microservice</p>\n</li>\n<li>\n<p>The location of the Kafka broker</p>\n</li>\n</ul>\n<p>Once everything is configured and deployed, your system is now running on Kubernetes.</p>"},{"location":"Super-Heroes-Workshop/#from-container-to-kubernetes","title":"From Container to Kubernetes","text":"<p>This section is optional and demonstrates how to ask Quarkus to create a container and deploy it to Kubernetes. We will need a running Kubernetes. We will use Rancher Desktop as indicated in the prerequisites.</p>"},{"location":"Super-Heroes-Workshop/#prerequisites","title":"Prerequisites","text":"<ol>\n<li>\n<p>Make sure that Docker Desktop (if installed) is turned off</p>\n</li>\n<li>\n<p>Make sure Rancher Desktop is started. The container runtime must be dockerd (Preferences \u2192 Container Runtime \u2192 dockerd (moby)).</p>\n</li>\n</ol>"},{"location":"Super-Heroes-Workshop/#deploying-to-kubernetes","title":"Deploying to Kubernetes","text":"<p>Quarkus can also run our application in Kubernetes and compute the Kubernetes descriptor. In addition to allow customizing any part of the descriptor, it is possible to configure config maps, secrets\u2026</p>\n<p>As mentioned above, we will use Rancher Desktop. Adapt the instructions for your Kubernetes:</p><ol><li><p>Make sure you are logged in</p></li><li><p>Make sure you use the correct namespace</p></li></ol>\n\n<p>Edit the <code>src/main/resources/application.properties</code> to add the following lines:</p>\n<pre><code>quarkus.kubernetes.namespace=default # Added\nquarkus.kubernetes.image-pull-policy=IfNotPresent # Added\n\n%prod.quarkus.http.port=8080 # Added\n%prod.quarkus.datasource.username=superbad\n%prod.quarkus.datasource.password=superbad\n%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://my-villains-db-postgresql:5432/villains_database # Updated\n%prod.quarkus.hibernate-orm.sql-load-script=import.sql\n</code></pre>\n<p>Add the <code>quarkus-kubernetes</code> extension using the following command:</p>\n<pre><code>./mvnw quarkus:add-extension -Dextensions=\"kubernetes\"\n</code></pre>\n<p>Alternatively, you can add the following dependency to the <code>pom.xml</code> file directly:</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-kubernetes&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Rancher Desktop authentication use elliptic algorithms not supported by default in Java. So, we also need to add the following dependency to the project:</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;\n  &lt;artifactId&gt;bcpkix-jdk18on&lt;/artifactId&gt;\n  &lt;version&gt;1.71&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Before deploying our application, we need to deploy the database. To achieve this, we are going to use helm (installed alongside Rancher Desktop) and the following postgresql package.</p>\n<p>Run the following commands:</p>\n<pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm install my-villains-db \\\n    --set auth.postgresPassword=superbad \\\n    --set auth.username=superbad \\\n    --set auth.password=superbad \\\n    --set auth.database=villains_database bitnami/postgresql\n</code></pre>\n<p>Finally, deploy the application using:</p>\n<pre><code>./mvnw clean package -Dquarkus.kubernetes.deploy=true -DskipTests\n</code></pre>\n<p>Check the pods with the following command:</p>\n<p>You should see something like:</p>\n<pre><code>NAME                             READY   STATUS    RESTARTS   AGE\nmy-villains-db-postgresql-0      1/1     Running   0          28m\nrest-villains-7c7479b959-7fn64   1/1     Running   0          12m\n</code></pre>\n<p>Make sure you wait for the <code>rest-villains</code> pod to be ready (1/1).</p>\n<p>Enable port-forwarding to port 8080 either from the rancher desktop UI (Preferences \u2192 Port Forwarding \u2192 default / rest-villains / http), or using the following command line:</p>\n<pre><code>kubectl port-forward pods/rest-villains-7c7479b959-7fn64 8080:8080\n</code></pre>"},{"location":"Super-Heroes-Workshop/#deploying-to-open-shift","title":"Deploying to Open Shift","text":""},{"location":"Super-Heroes-Workshop/#conclusion","title":"Conclusion","text":"<p>This is the end of the Super Hero workshop. We hope you liked it, learnt a few things, and more importantly, will be able to take this knowledge back to your projects.</p>\n<p>This workshop started making sure your development environment was ready to develop the entire application. Then, there was some brief terminology to help you in understanding some concepts around Quarkus. If you find it was too short and need more details on Quarkus, Microservices, MicroProfile, Cloud Native, or GraalVM, check the Quarkus website for more references</p>\n<p>Then, we focused on developing several isolated microservices. Some written in pure JAX-RS (such as the Villain) others with Reactive JAX-RS and Reactive Hibernate (such as the Hero). These microservices return data in JSON, validate data thanks to Bean Validation, store and retrieve data from a relational database with the help of JPA, Panache and JTA.</p>\n<p>You then installed an already coded React application on another instance of Quarkus. At this stage, the React application couldn\u2019t access the microservices because of CORS issues that we quickly fixed.</p>\n<p>Then, we made the microservices communicate with each other in HTTP thanks to REST Client. But HTTP-related technologies usually use synchronous communication and therefore need to deal with invocation failure. With Fault Tolerance, it was just a matter of using a few annotations and we can get some fallback when the communication fails.</p>\n<p>That\u2019s also why we introduced Reactive Messaging with Kafka: so we don\u2019t have a temporal coupling between the microservices.</p>\n<p>We\u2019ve also added some Artificial Intelligence. Thanks to Semantic Kernel, with a few lines of code, we allowed our Narration microservice to narrate the fight between a Super Hero and a Super Villain.</p>\n<p>Then, came production time. With Quarkus it\u2019s very easy to build executable JARs. With a JVM installed you can execute these JARs which are optimal for production. And if you need to turn your microservice into an executable binary (thanks to GraalVM), that\u2019s easy too. Quarkus supports GraalVM since the beginning and makes its integration smooth. Same if you want to package microservices into Docker containers. Quarkus supports Jib. So with a simple Maven command you can turn your microservice into a container.</p>"},{"location":"Super-Heroes-Workshop/#references","title":"References","text":"<ul>\n<li>\n<p>https://github.com/cescoffier/quarkus-todo-app</p>\n</li>\n<li>\n<p>https://github.com/agoncal/baking-microservice-pie</p>\n</li>\n<li>\n<p>https://forge.jboss.org/document/hands-on-lab</p>\n</li>\n<li>\n<p>https://bit.ly/forge-hol</p>\n</li>\n<li>\n<p>https://quarkus.io</p>\n</li>\n<li>\n<p>https://code.quarkus.io</p>\n</li>\n<li>\n<p>https://quarkus.io/guides/all-config</p>\n</li>\n<li>\n<p>Azure Container Apps Overview</p>\n</li>\n<li>\n<p>Azure Container Apps Documentation</p>\n</li>\n<li>\n<p>Managed Kafka Quarkus</p>\n</li>\n</ul>"},{"location":"Super-Heroes-Workshop/#apache-maven-39x","title":"Apache Maven 3.9.x","text":"<p>All the examples of this workshop are built and tested using Maven Maven offers a building solution, shared libraries, and a plugin platform for your projects, allowing you to do quality control, documentation, teamwork, and so forth. Based on the \"convention over configuration\" principle, Maven brings a standard project description and a number of conventions such as a standard directory structure. With an extensible architecture based on plugins, Maven can offer many different services.</p>"},{"location":"Super-Heroes-Workshop/#installing-maven","title":"Installing Maven","text":"<p>The examples of this workshop have been developed with Apache Maven 3.9.x. For this workshop, it is not necessary to install Maven. You can just use the Maven wrapper in your working directory, <code>./mvnw</code>. The wrapper is always at a suitable Maven version.</p>\n<p>However, if you\u2019d prefer to have a global installation of Maven (<code>mvn</code>), here\u2019s how. Once you have installed JDK 21, make sure the <code>JAVA_HOME</code> environment variable is set. Then, download Maven from http://maven.apache.org/, unzip the file on your hard drive and add the <code>apache-maven/bin</code> directory to your <code>PATH</code> variable. More details about the installation process are available on https://maven.apache.org/install.html.</p>"},{"location":"Super-Heroes-Workshop/#checking-for-maven-installation","title":"Checking for Maven Installation","text":"<p>Once you\u2019ve got Maven installed, open a command line and enter <code>mvn -version</code> to validate your installation. Maven should print its version and the JDK version it uses (which is handy as you might have different JDK versions installed on the same machine).</p>\n<pre><code>$ mvn -version\nApache Maven 3.9.4 (ea98e05a04480131370aa0c110b8c54cf726c06f)\nMaven home: /usr/local/Cellar/maven/3.9.4/libexec\nJava version: 21.0.0, vendor: AdoptOpenJDK, runtime: /Users/clement/.sdkman/candidates/java/11.0.15.hs-adpt\nDefault locale: en_FR, platform encoding: UTF-8\nOS name: \"mac os x\", version: \"21.5\", arch: \"x86_64\", family: \"mac\"\n</code></pre>\n<p>Be aware that Maven needs Internet access to download plugins and project dependencies from the Maven Central and other remote repositories</p>"},{"location":"Super-Heroes-Workshop/#some-maven-commands","title":"Some Maven Commands","text":"<p>Maven is a command-line utility where you can use several parameters and options to build, test, or package your code. To get some help on the commands, you can type, use the following command:</p>\n<pre><code>$ mvn --help\n\nusage: mvn [options] [&lt;goal(s)&gt;] [&lt;phase(s)&gt;]\n</code></pre>\n<p>Here are some commands that you will be using to run the examples in the workshop. Each invokes a different phase of the project life cycle (clean, compile, install, etc.) and use the <code>pom.xml</code> to download libraries, customize the compilation, or extend some behaviors with plugins:</p>\n<ul>\n<li>\n<p><code>mvn clean</code>: Deletes all generated files (compiled classes, generated code, artifacts etc.).</p>\n</li>\n<li>\n<p><code>mvn compile</code>: Compiles the main Java classes.</p>\n</li>\n<li>\n<p><code>mvn test-compile</code>: Compiles the test classes.</p>\n</li>\n<li>\n<p><code>mvn test</code>: Compiles the main Java classes as well as the test classes and executes the tests.</p>\n</li>\n<li>\n<p><code>mvn package</code>: Compiles, executes the tests, and packages the code into an archive.</p>\n</li>\n<li>\n<p><code>mvn install</code>: Builds and installs the artifacts in your local repository.</p>\n</li>\n<li>\n<p><code>mvn clean install</code>: Cleans and installs (note that you can add several commands separated by a space, like <code>mvn clean compile test</code>).</p>\n</li>\n</ul>"},{"location":"Super-Heroes-Workshop/#curl","title":"cURL","text":"<p>To invoke the REST Web Services described in this workshop, we often use cURL cURL is a command-line tool and library to do reliable data transfers with various protocols, including HTTP. It is free, open-source (available under the MIT Licence), and has been ported to several operating systems. If your operating system does not already include cURL (most do), here is how to install it.</p>"},{"location":"Super-Heroes-Workshop/#installing-curl","title":"Installing cURL","text":""},{"location":"Super-Heroes-Workshop/#checking-for-curl-installation","title":"Checking for cURL Installation","text":"<p>Once installed, check for cURL by running <code>curl --version</code> in the terminal. It should display cURL version:</p>\n<pre><code>$ curl --version\ncurl 7.64.1 (x86_64-apple-darwin20.0) libcurl/7.64.1 (SecureTransport) LibreSSL/2.8.3 zlib/1.2.11 nghttp2/1.41.0\nRelease-Date: 2019-03-27\nProtocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp\nFeatures: AsynchDNS GSS-API HTTP2 HTTPS-proxy IPv6 Kerberos Largefile libz MultiSSL NTLM NTLM_WB SPNEGO SSL UnixSockets\n</code></pre>"},{"location":"Super-Heroes-Workshop/#some-curl-commands","title":"Some cURL Commands","text":"<p>cURL is a command-line utility where you can use several parameters and options to invoke URLs. You invoke <code>curl</code> with zero, one, or several command-line options to accompany the URL (or set of URLs) you want the transfer to be about. cURL supports over two hundred different options, and I would recommend reading the documentation for more help To get some help on the commands and options, you can type, use the following command:</p>\n<pre><code>$ curl --help\n\nUsage: curl [options...] &lt;url&gt;\n</code></pre>\n<p>You can also opt to use <code>curl --manual</code>, which will output the entire man page for cURL plus an appended tutorial for the most common use cases.</p>\n<p>Here are some commands you will use to invoke the RESTful web service examples in this workshop.</p>\n<ul>\n<li>\n<p><code>curl [http://localhost:8083/api/heroes/hello](http://localhost:8083/api/heroes/hello)</code>: HTTP GET on a given URL.</p>\n</li>\n<li>\n<p><code>curl -X GET [http://localhost:8083/api/heroes/hello](http://localhost:8083/api/heroes/hello)</code>: Same effect as the previous command, an HTTP GET on a given URL.</p>\n</li>\n<li>\n<p><code>curl -v [http://localhost:8083/api/heroes/hello](http://localhost:8083/api/heroes/hello)</code>: HTTP GET on a given URL with verbose mode on.</p>\n</li>\n<li>\n<p><code>curl -H 'Content-Type: application/json' [http://localhost:8083/api/heroes/hello](http://localhost:8083/api/heroes/hello)</code>: HTTP GET on a given URL passing the JSON Content Type in the HTTP Header.</p>\n</li>\n<li>\n<p><code>curl -X DELETE [http://localhost:8083/api/heroes/1](http://localhost:8083/api/heroes/1)</code>: HTTP DELETE on a given URL.</p>\n</li>\n</ul>"},{"location":"Super-Heroes-Workshop/#warming-the-caches","title":"Warming the caches","text":"<p>This workshop needs internet access to download all sorts of Maven artifacts, Docker images, and even pictures. Some of these artifacts are large, and because we have to share internet connexions at the workshop, it is better to download them before the workshop.</p>\n<p>If you\u2019re getting ready for a workshop, you might find it helpful to pre-download some Docker images. This can save strain on shared bandwidth. If, however, you\u2019re already attending a workshop, don\u2019t worry about warming anything up.</p>"},{"location":"Super-Heroes-Workshop/#warming-up-maven","title":"Warming up Maven","text":""},{"location":"Super-Heroes-Workshop/#download-the-workshop-scaffolding_1","title":"Download the workshop scaffolding","text":""},{"location":"Super-Heroes-Workshop/#download-the-maven-dependencies","title":"Download the Maven dependencies","text":"<p>Now that you have the initial structure in place, navigate to the root directory and run:</p>\n<p>By running this command, it downloads all the required dependencies.</p>"},{"location":"Super-Heroes-Workshop/#warming-up-docker-images","title":"Warming up Docker images","text":"<p>To warm up your Docker image repository, navigate to the <code>quarkus-workshop-super-heroes/super-heroes/infrastructure</code> directory. Here, you will find a <code>docker-compose.yaml</code> file which defines all the needed Docker images. Notice that there is a <code>db-init</code> directory with an <code>initialize-databases.sql</code> script which sets up our databases, and a <code>monitoring</code> directory (all that will be explained later).</p>\n<p>Then execute the following command which will download all the Docker images and start the containers:</p>\n<pre><code>docker compose -f docker-compose.yaml up -d\n</code></pre>\n<p>If you have an issue creating the roles for the database with the <code>initialize-databases.sql</code> file, you have to execute the following commands:</p><pre><code>docker exec -it --user postgres super-database psql -c \"CREATE ROLE superman LOGIN PASSWORD 'superman' NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE NOREPLICATION\"\ndocker exec -it --user postgres super-database psql -c \"CREATE ROLE superbad LOGIN PASSWORD 'superbad' NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE NOREPLICATION\"\ndocker exec -it --user postgres super-database psql -c \"CREATE ROLE superfight LOGIN PASSWORD 'superfight' NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE NOREPLICATION\"</code></pre>\n\n<p>After this, verify the containers are running using the following command:</p>\n<pre><code>docker compose -f docker-compose.yaml ps\n</code></pre>\n<p>The output should resemble something like this:</p>\n<pre><code>     Name                   Command               State           Ports\n--------------------------------------------------------------------------------\nkafka            sh -c bin/kafka-server-sta ...   Up      0.0.0.0:9092-&gt;9092/tcp\nsuper-database   docker-entrypoint.sh postgres    Up      0.0.0.0:5432-&gt;5432/tcp\nsuper-visor      /bin/prometheus --config.f ...   Up      0.0.0.0:9090-&gt;9090/tcp\nzookeeper        sh -c bin/zookeeper-server ...   Up      0.0.0.0:2181-&gt;2181/tcp\n</code></pre>\n<p>Once all the containers are up and running, you can shut them down and remove their volumes with the commands:</p>\n<pre><code>docker compose -f docker-compose.yaml down\ndocker compose -f docker-compose.yaml rm\n</code></pre>\n<p>What\u2019s this infra?</p><p>Any microservice system is going to rely on a set of technical services. In our context, we are going to use PostgreSQL as the database, Prometheus as the monitoring tool, and Kafka as the event/message bus. This infrastructure starts all these services, so you don\u2019t have to worry about them.</p><p>This infra will only be used when we run our services in prod mode. In dev mode, Quarkus will start everything for us.</p>"},{"location":"exam/","title":"Description","text":"<p>The aim of this application is to create a microservice that interacts with a public API about the Harry Potter world.</p> <p>Then we'll be importing the data in the public API in our database and running some queries.</p> <p>This is the project structure: </p> <p>The api package is used to connect to the remote website. The dto package is used to store in the database. The model package is used to parse the api response.</p>"},{"location":"exam/#setup","title":"Setup","text":""},{"location":"exam/#docker-compose","title":"Docker compose","text":"<pre><code>version: \"3\"\nservices:\n  database:\n    image: \"postgres:14\"\n    container_name: \"hp-database\"\n    ports:\n      - \"5432:5432\"\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: quarkusdb\n\n  zookeeper:\n    image: quay.io/strimzi/kafka:0.39.0-kafka-3.6.1\n    command: [\n      \"sh\", \"-c\",\n      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n    ]\n    ports:\n      - \"2181:2181\"\n    environment:\n      LOG_DIR: /tmp/logs\n\n  kafka:\n    image: quay.io/strimzi/kafka:0.39.0-kafka-3.6.1\n    command: [\n      \"sh\", \"-c\",\n      \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}\"\n    ]\n    depends_on:\n      - zookeeper\n    ports:\n      - \"9092:9092\"\n    environment:\n      LOG_DIR: \"/tmp/logs\"\n      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092\n      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n</code></pre>"},{"location":"exam/#project-starter","title":"Project Starter","text":"<p>Download from github</p> <p>Open-api extension already added.</p>"},{"location":"exam/#rest-client","title":"Rest client","text":"<p>Register <code>CharactersApi</code> as a rest client, you can use the Guide as reference. Connect to the <code>https://api.potterdb.com/</code> api to get characters.</p> <p>Here is some documentation: potterdb.com</p> <p>Complete the method to get a character list and by id.</p>"},{"location":"exam/#database","title":"Database","text":"<p>You can use the Guide as reference.</p> <p>1) Create the Enum :</p> <pre><code>package com.course;\n\nenum Houses {\nSlytherin,\nGryffindor,\nRavenclaw,\nHufflepuff\n}\n</code></pre> <p>2) Use ObjectMapper to convert json to class then persist it.</p> <pre><code>//import com.fasterxml.jackson.databind.ObjectMapper;\nObjectMapper objectMapper = new ObjectMapper();\nList&lt;CharacterModel&gt; list = objectMapper.readerForListOf(CharacterModel.class).readValue(getClass().getClassLoader().getResourceAsStream(\"hp.json\"));\n</code></pre> <p>3) Create a Rest load function to initialize the database.</p> <p>4) Create panache queries to complete these REST methods:</p> <pre><code>//GET on /\npublic List&lt;CharacterModel&gt; findAll() {\n}\n//GET on character/{id}\npublic List&lt;CharacterModel&gt; findById(Long id) {\n}\n//GET on houses/{house}\npublic List&lt;CharacterModel&gt; findByHouse(Houses house) {\n}\n\n//GET on houses-count/{house}\npublic int countByHouse(Houses house) {\n}\n//GET on species/{specie}\npublic List&lt;CharacterModel&gt; findBySpeciesLike(String specie) {\n    //Use a namedQuery for this query\n}\n</code></pre>"},{"location":"exam/#messaging","title":"Messaging","text":"<p>We will now send a message containing the <code>House</code> of the character to another microservice each time we add a Character to the database</p> <p>Read the following guide</p> <p>1) Add extension to current project <pre><code>./mvnw quarkus:add-extension -Dextensions=\" io.quarkus:quarkus-messaging-kafka\"\n</code></pre> 2) Create a class named <code>Perso</code>, with a name and the Enum <code>Houses</code>. 3) In the class where you add the <code>Character</code> to the database, each time you add an entry to the database, send a new message using an <code>Emitter</code> 4) Set the configuration on the <code>application.properties</code> file 5) Create a new project</p> <pre><code>./mvnw io.quarkus:quarkus-maven-plugin:3.9.1:create    -\"DplatformVersion=3.9.1\" -\"DprojectGroupId=com.course.hp\"   -\"DprojectArtifactId=message\"    -DclassName=\"com.course.message.MessageResource\"    -Dpath=\"api/message\"   -Dextensions=\"resteasy-jackson,quarkus-smallrye-openapi,,messaging-kafka\"\n</code></pre> <p>6) Copy <code>Perso</code> and <code>Houses</code> to the new project.</p> <p>7) Create in each project a class named <code>Perso</code>, with a name and the Enum <code>Houses</code>.</p> <p>8) In the <code>MessageResource</code> class use the <code>@Incoming</code> annotation on a method called <code>processMessage</code> to receive instances of <code>Perso</code> and store it in a list.</p> <p>9) Set the configuration on the <code>application.properties</code> file</p> <p>10) Create a get method to return the list.</p> <p>11) Create a get method with <code>Houses</code> as parameter, returning the number of <code>Perso</code> corresponding to that house.</p> <p>Now if you run both microservices you should have in the message microservice a <code>Perso</code> message for each database entry.</p>"},{"location":"springboot/","title":"Spring Boot","text":""},{"location":"springboot/#objectifs-du-cours","title":"Objectifs du cours","text":"<ul> <li>D\u00e9couverte et utilisation de microservices</li> <li>Utiliser JPA pour communiquer avec des bases de donn\u00e9es</li> <li>Valider et s\u00e9curiser les donn\u00e9es</li> <li>Gestion d'erreurs</li> </ul>"},{"location":"springboot/#notions-et-definitions","title":"Notions et d\u00e9finitions","text":""},{"location":"springboot/#microservice","title":"Microservice","text":"<p>Les microservices sont une technique de d\u00e9veloppement logiciel \u2014 une variante de l'architecture orient\u00e9e services (SOA) \u2014 qui structure une application comme un ensemble de services faiblement coupl\u00e9s. Les microservices ind\u00e9pendants communiquent les uns avec les autres en utilisant des API ind\u00e9pendantes du langage de programmation.</p> <p></p> <p>Des API REST sont souvent employ\u00e9es pour relier chaque microservice aux autres. Un avantage avanc\u00e9 est que lors d'un besoin critique de mise \u00e0 jour d'une ressource, seul le microservice contenant cette ressource sera mis \u00e0 jour, l'ensemble de l'application restant compatible avec la modification, contrairement \u00e0 la totalit\u00e9 de l'application dans une architecture classique.</p>"},{"location":"springboot/#rest","title":"REST","text":"<p>Rappels rapide REST:</p> <p>REST (pour REpresentational State Transfer) ne d\u00e9crit pas une impl\u00e9mentation mais un style d\u2019architecture qui suit diff\u00e9rents principes :</p> <ul> <li>client-serveur: les responsabilit\u00e9s sont s\u00e9par\u00e9es entre le client et le serveur. L\u2019interface utilisateur est s\u00e9par\u00e9e de celle du stockage des donn\u00e9es. Cela permet aux deux d\u2019\u00e9voluer ind\u00e9pendamment (contrairement \u00e0 des applications qui r\u00e9alisent des requ\u00eates directement en base de donn\u00e9es par exemple\u2026).</li> <li>sans \u00e9tat: la requ\u00eate envoy\u00e9e par le client doit \u00eatre auto-suffisante : ne pas n\u00e9cessiter de sauvegarder un \u00e9tat sur le serveur</li> <li>mise en cache : la possibilit\u00e9 pour le serveur de sp\u00e9cifier les r\u00e9ponses pouvant \u00eatre mises en cache</li> <li>une interface uniforme : chaque ressource est identifi\u00e9e unitairement, les ressources ont des repr\u00e9sentations d\u00e9finies</li> <li>un syst\u00e8me hi\u00e9rarchis\u00e9 par couche: les \u00e9tats de l\u2019application sont repr\u00e9sent\u00e9s par des ressources individuelles. L\u2019ensemble de l\u2019information n\u2019est pas envoy\u00e9e dans une ressource unique.</li> </ul> <p>\u00c0 noter qu\u2019on assimile \u00ab API REST \u00bb avec l\u2019application de ce style d\u2019architecture sur le protocole HTTP et en utilisant le format d\u2019\u00e9change de donn\u00e9es JSON. Avec le protocole HTTP d\u00e9finit les m\u00e9thodes suivantes: GET, POST, PUT, PATCH et DELETE.</p> <p>Exemple: Ressource collection, telle que http://api.exemple.com/collection/</p> <ul> <li>GET: R\u00e9cup\u00e8re les URI des ressources membres de la ressource collection dans le corps de la r\u00e9ponse.</li> <li>POST: Cr\u00e9e une ressource membre dans la ressource collection en utilisant les instructions du corps de la requ\u00eate. L'URI de la ressource membre cr\u00e9\u00e9e est attribu\u00e9 automatiquement et retourn\u00e9 dans le champ d'en-t\u00eate Location de la r\u00e9ponse.</li> <li>PUT: Remplace toutes les repr\u00e9sentations des ressources membres de la ressource collection par la repr\u00e9sentation dans le corps de la requ\u00eate, ou cr\u00e9e la ressource collection si elle n'existe pas.</li> <li>PATCH :Met \u00e0 jour toutes les repr\u00e9sentations des ressources membres de la ressource collection en utilisant les instructions du corps de la requ\u00eate, ou cr\u00e9e \u00e9ventuellement la ressource collection si elle n'existe pas.</li> <li>DETELE: Supprime toutes les repr\u00e9sentations des ressources membres de la ressource collection.</li> </ul> <p>Exemple Swagger</p> <p>Plus d'infos: HTTP, REST</p>"},{"location":"springboot/#mvc","title":"MVC","text":""},{"location":"springboot/#pourquoi-spring-boot","title":"Pourquoi Spring Boot?","text":"<p>D\u00e9finition : Spring est un Framework de d\u00e9veloppement d'applications Java, qui apporte plusieurs fonctionnalit\u00e9s comme Spring Security, SpringMVC, Spring Batch, Spring Data, etc. Ces Frameworks ont pour objectif de faciliter la t\u00e2che aux d\u00e9veloppeurs. Malheureusement, leurs mises en \u0153uvre deviennent tr\u00e8s complexes \u00e0 travers les fichiers de configuration XML qui ne cessent de grossir, et une gestion des d\u00e9pendances fastidieuse. C'est pour r\u00e9pondre \u00e0 cette inqui\u00e9tude que le projet Spring Boot a vu le jour.</p> <p>D\u00e9finition : Spring Boot est un sous projet de Spring qui vise \u00e0 rendre Spring plus facile d'utilisation en \u00e9limant plusieurs \u00e9tapes de configuration. L'objectif de Spring Boot est de permettre aux d\u00e9veloppeurs de se concentrer sur des t\u00e2ches techniques et non des t\u00e2ches de configurations, de d\u00e9ploiements, etc. Ce qui a pour cons\u00e9quences un gain de temps et de productivit\u00e9.</p> <p>Spring Boot apporte \u00e0 Spring une tr\u00e8s grande simplicit\u00e9 d'utilisation :</p> <ul> <li>Il facilite notamment la cr\u00e9ation, la configuration et le d\u00e9ploiement d'une application compl\u00e8te. On n'a plus besoin des fichiers XML \u00e0 configurer (pas besoin du fichier du descripteur de d\u00e9ploiement web.xml dans le cas d'une application web).</li> <li>Spring Boot permet de d\u00e9ployer tr\u00e8s facilement une application dans plusieurs environnements sans avoir \u00e0 \u00e9crire des scripts. Pour ce faire, une simple indication de l'environnement (d\u00e9veloppement ou production) dans le fichier de propri\u00e9t\u00e9s (.properties) suffit \u00e0 d\u00e9ployer l'application dans l'un ou l'autre environnement. Ceci est rendu possible gr\u00e2ce \u00e0 la notion de profil \u00e0 d\u00e9clarer toujours dans le fichier de propri\u00e9t\u00e9s.</li> <li>Spring Boot poss\u00e8de un serveur d'application Tomcat embarqu\u00e9 afin de faciliter le d\u00e9ploiement d'une application web. Il est possible d'utiliser un serveur autre ou externe, gr\u00e2ce \u00e0 une simple d\u00e9claration dans le fichier pom.xml.</li> <li>Spring Boot permet de mettre en place un suivi m\u00e9trique de l'application une fois d\u00e9ploy\u00e9e sur le serveur afin de suivre en temps r\u00e9el l'activit\u00e9 du serveur, ceci gr\u00e2ce \u00e0 spring-boot-starter-actuator.</li> </ul>"},{"location":"springboot/#outil-configuration-spring-boot","title":"Outil configuration spring boot","text":"<p>Le site start.spring.io permet de g\u00e9n\u00e9rer l'ensemble des d\u00e9pendances du projet et cr\u00e9\u00e9 le squelette de l'application.</p> <p></p>"},{"location":"springboot/#hello-rest-world","title":"Hello REST World","text":""},{"location":"springboot/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Java 1.8</li> <li>Maven</li> <li>Spring Tool Suite</li> <li>Git</li> <li>Linux?</li> </ul>"},{"location":"springboot/#fichier-de-build","title":"Fichier de build","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;demo&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre>"},{"location":"springboot/#classe-de-lancement-comexampledemodemoapplication","title":"Classe de lancement: com.example.demo.DemoApplication","text":"<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n    // Bean permettant de lister la liste des bens Spring instanci\u00e9s\n    @Bean\n    public CommandLineRunner commandLineRunner(ApplicationContext ctx) {\n        return args -&gt; {\n            System.out.println(\"Let's inspect the beans provided by Spring Boot:\");\n\n            String[] beanNames = ctx.getBeanDefinitionNames();\n            Arrays.sort(beanNames);\n            for (String beanName : beanNames) {\n                System.out.println(beanName);\n            }\n\n        };\n    }\n\n}\n</code></pre> <p>La classe DemoApplication contient la m\u00e9thode <code>void main(String[] args)</code> n\u00e9cessaire dans une application Spring Boot, et permet l'ex\u00e9cution de celle-ci : c'est le point d'entr\u00e9e de l'application.</p> <p>La classe de d\u00e9marrage de l'application DemoApplication doit \u00eatre \u00e0 la racine du package principal si on veut permettre \u00e0 Spring de scanner les sous-packages en utilisant l'annotation @SpringBootApplication.</p> <p>L'annotation @SpringBootApplication est centrale dans une application Spring Boot et permet de scanner le package courant et ses sous-packages.</p> <p>Elle est \u00e9quivalente \u00e0 l'ensemble des annotations <pre><code>  @Configuration\n  @EnableAutoConfiguration\n  @ComponentScan\n</code></pre></p> <ul> <li>@Configuration permet de configurer une classe comme une source de d\u00e9finition des beans Spring.</li> <li>@EnableAutoConfiguration ajoute l'ensemble des beans du classpath.</li> <li>@ComponentScan autorise Spring \u00e0 rechercher tous les composants, les configurations et autres services de l'application et \u00e0 initialiser tous les contr\u00f4leurs.</li> </ul>"},{"location":"springboot/#le-controleur-comexamplespringboothellocontroller","title":"Le contr\u00f4leur com.example.springboot.HelloController","text":"<pre><code>package com.example.springboot;\n\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/\")\n    public String index() {\n        return \"Greetings from Spring Boot!\";\n    }\n\n}\n</code></pre> <p>Cette classe est annot\u00e9e @RestController, ce qui veut dire qu'elle est pr\u00eate \u00e0 \u00eatre utilis\u00e9e par Spring MVC pour g\u00e9rer des requ\u00eates web.</p> <p>@RequestMapping associe / \u00e0 la m\u00e9thode index().Quand la m\u00e9thode est invoqu\u00e9e depuis un navigateur web ou la commande curl elle retourne le texte du return.</p> <p>L'annotation @RestController, est une combinaison des annotations @Controller et @ResponseBody, cr\u00e9\u00e9e une r\u00e9ponse web retournant de la data plut\u00f4t qu'une vue.</p>"},{"location":"springboot/#lancement","title":"Lancement","text":"<p>Plusieurs possibilit\u00e9s:</p> <ul> <li>Avec Eclipse Run as Spring boot Application</li> <li>Avec maven <code>mvn spring-boot:run</code></li> <li>En lan\u00e7ant le main du jar g\u00e9n\u00e9r\u00e9</li> </ul>"},{"location":"springboot/#tests-manuels","title":"Tests manuels","text":"<p>Il suffit de faire une requ\u00eate http vers localhost:8080</p> <p><code>curl localhost:8080</code></p> <p>ou avec le navigateur:</p> <p><code>firefox http://localhost:8080</code></p> <p>8080 est le port par d\u00e9faut du serveur web embarqu\u00e9 par spring boot.</p>"},{"location":"springboot/#tests-unitaires-junit","title":"Tests unitaires Junit","text":"<pre><code>package com.example.springboot;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class HelloControllerTest {\n\n    @Autowired\n    private MockMvc mvc;\n\n    @Test\n    public void getHello() throws Exception {\n        mvc.perform(MockMvcRequestBuilders.get(\"/\").accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"Greetings from Spring Boot!\")));\n    }\n}\n</code></pre>"},{"location":"springboot/#exo-thymeleaf","title":"Exo thymeleaf","text":"<p>Thymeleaf est un  Java HTML5 Template Engine qui peut travailler \u00e0 la fois dans des environnements Web (Servlet) et celui de non Web. Il est mieux adapt\u00e9 pour diffuser XHTML/HTML5 sur View (View Layer) des applications Web bas\u00e9es sur MVC. Mais il peut traiter n'importe quel fichier XML m\u00eame dans des environnements hors ligne (offline). Il fournit une int\u00e9gration compl\u00e8te de Spring Framework\u200b\u200b\u200b\u200b\u200b\u200b\u200b.</p> <p></p> <p>Le fichier mod\u00e8le (Template file) de Thymeleaf est en substance un fichier de document ordinaire au format HTML5. Thymeleaf Engine (le moteur Thymeleaf) va lire un fichier mod\u00e8le et le combiner avec des objets Java pour g\u00e9n\u00e9rer (generate) un autre document. </p> <p>Voici ce que nous allons r\u00e9aliser:</p> <p></p>"},{"location":"springboot/#exo-thymeleaf-security","title":"Exo thymeleaf Security","text":"<p>Tuto</p> <p>D\u00e9pendances start.spring.io     devtools     web     thymeleaf     Security</p> <p>Ajouter dans le pom g\u00e9n\u00e9r\u00e9:</p> <pre><code>        &lt;dependency&gt;\n           &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;\n           &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Un petit conseil: il vaut mieux supprimer tous les <code>.html</code> non n\u00e9cessaire.</p> <p>Classe de configuration de la s\u00e9curit\u00e9:</p> <pre><code>@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    protected void configure(final HttpSecurity http) throws Exception {\n        http\n            .formLogin()\n            .loginPage(\"/login\")\n            .failureUrl(\"/login-error\")\n          .and()\n            .logout()\n            .logoutSuccessUrl(\"/index\");\n    }\n    @Bean\n    @Override\n    public UserDetailsService userDetailsService() {\n        UserDetails user =\n             User.withDefaultPasswordEncoder()\n                .username(\"user\")\n                .password(\"user\")\n                .roles(\"USER\")\n                .build();\n        UserDetails admin =\n                User.withDefaultPasswordEncoder()\n                .username(\"admin\")\n                .password(\"admin\")\n                .roles(\"ADMIN\")\n                .build();\n\n        return new InMemoryUserDetailsManager(user,admin);\n    }\n}\n</code></pre>"},{"location":"springboot/#spring-controller","title":"Spring Controller","text":"<p>Quelle est la diff\u00e9rence entre les annotations <code>@Controller</code> et <code>@RestController</code> dans Spring MVC?</p>"},{"location":"springboot/#controller","title":"Controller","text":"<p>Les contr\u00f4leurs classiques peuvent \u00eatre annot\u00e9s avec l\u2019annotation <code>@Controller</code> .</p> <p>Il s\u2019agit simplement d\u2019une sp\u00e9cialisation de la classe <code>@Component</code> qui permet de d\u00e9tecter automatiquement les classes d\u2019impl\u00e9mentation via le balayage du classpath.</p> <p><code>@Controller</code> est g\u00e9n\u00e9ralement utilis\u00e9 en combinaison avec une annotation <code>@RequestMapping</code> utilis\u00e9e dans les m\u00e9thodes de traitement des demandes.</p> <p>Voyons un exemple rapide du contr\u00f4leur Spring MVC:</p> <pre><code>@Controller\n@RequestMapping(\"books\")\npublic class SimpleBookController {\n\n    @GetMapping(\"/{id}\", produces = \"application/json\")\n    public @ResponseBody Book getBook(@PathVariable int id) {\n        return findBookById(id);\n    }\n\n    private Book findBookById(int id) {\n       //...\n    }\n}\n</code></pre> <p>La m\u00e9thode de traitement de la demande est annot\u00e9e avec <code>@ResponseBody</code> . Cette annotation active la s\u00e9rialisation automatique de l\u2019objet de retour dans HttpResponse .</p>"},{"location":"springboot/#restcontroller","title":"RestController","text":"<p><code>@RestController</code> est une version sp\u00e9cialis\u00e9e du contr\u00f4leur. Il inclut les annotations <code>@Controller</code> et <code>@ResponseBody</code> et simplifie donc la mise en \u0153uvre du contr\u00f4leur:</p> <pre><code>@RestController\n@RequestMapping(\"books-rest\")\npublic class SimpleBookRestController {\n\n    @GetMapping(\"/{id}\", produces = \"application/json\")\n    public Book getBook(@PathVariable int id) {\n        return findBookById(id);\n    }\n\n    private Book findBookById(int id) {\n       //...\n    }\n}\n</code></pre> <p>Le contr\u00f4leur est annot\u00e9 avec l\u2019annotation <code>@RestController</code> ; par cons\u00e9quent, le <code>@ResponseBody</code> n\u2019est pas requis.</p> <p>Chaque m\u00e9thode de traitement des demandes de la classe de contr\u00f4leur s\u00e9rialise automatiquement les objets renvoy\u00e9s dans HttpResponse .</p>"},{"location":"springboot/#retourner-une-vue","title":"Retourner une vue","text":"<p>Pour retourner une vue (Thymleaf par exemple), il suffit d'avoir un controller et de retourner la string correspondant au fichier de la vue.</p> <pre><code>@Controller\npublic class MainController {\n\n    // Login form\n    @RequestMapping(value = { \"/log-in\", \"/login\" }, method = RequestMethod.GET)\n    public String login() {\n        return \"login\"; //retourne la page login.html\n    }\n}\n</code></pre>"},{"location":"springboot/#autres-annotations","title":"Autres annotations","text":"<ul> <li> <p><code>@Component</code> Cette annotation est utilis\u00e9e sur les classes pour indiquer un composant Spring. L'annotation <code>@Component</code> marque la classe Java en tant que bean ou composant afin que le m\u00e9canisme d'analyse des composants de Spring puisse l'ajouter au contexte de l'application.</p> </li> <li> <p><code>@Controller</code> L'annotation @Controller est utilis\u00e9e pour indiquer que la classe est un contr\u00f4leur Spring. Cette annotation peut \u00eatre utilis\u00e9e pour identifier les contr\u00f4leurs pour Spring MVC ou Spring WebFlux.</p> </li> <li> <p><code>@Service</code> Cette annotation est utilis\u00e9e sur une classe. @Service marque une classe Java qui effectue certains traitements service, tels que l'ex\u00e9cution de la logique m\u00e9tier, l'ex\u00e9cution de calculs et l'appel d'API externes. Cette annotation est une forme sp\u00e9cialis\u00e9e de l'annotation @Component destin\u00e9e \u00e0 \u00eatre utilis\u00e9e dans la couche de service.</p> </li> <li> <p><code>@Repository</code> Cette annotation est utilis\u00e9e sur les classes Java qui acc\u00e8dent directement \u00e0 la base de donn\u00e9es. L'annotation <code>@Repository</code> fonctionne comme un marqueur pour toute classe remplissant le r\u00f4le de r\u00e9f\u00e9rentiel ou d'objet d'acc\u00e8s aux donn\u00e9es.</p> </li> </ul> <p>Cette annotation a une fonction de traduction automatique. Par exemple, lorsqu'une exception se produit dans @Repository, il existe un gestionnaire pour cette exception et il n'est pas n\u00e9cessaire d'ajouter un bloc try-catch.</p>"},{"location":"springboot/Projet/","title":"Projet","text":""},{"location":"springboot/Projet/#descriptif-general","title":"Descriptif g\u00e9n\u00e9ral","text":"<p>Le but du projet et de r\u00e9aliser un agr\u00e9gateur permettant d'acc\u00e9der \u00e0 plusieurs types de r\u00e9seaux sociaux (Facebook /Instagram / Twitter / TikTok / Youtube / ...), de disposer d'une page afin de pouvoir visualiser l'ensemble des contenus avec un template identique. L'utilisateur pourra ajouter \u00e0 son compte autant de comptes publiques ou priv\u00e9s de diff\u00e9rents r\u00e9seaux sociaux. Les donn\u00e9es des diff\u00e9rents r\u00e9seaux seront stock\u00e9es d'une mani\u00e8re g\u00e9n\u00e9rique dans une base propre \u00e0 l'application. L'application finale devra avoir un CI CD d\u00e9ploy\u00e9 dans un Kubernetes host\u00e9 par AWS</p>"},{"location":"springboot/Projet/#deroulement-du-projet","title":"D\u00e9roulement du projet","text":"<p>Le temps du projet r\u00e9serv\u00e9 est de 6 jours mais il devra tr\u00e8s probablement \u00eatre compl\u00e9t\u00e9 par du travail personnel en dehors des heures pr\u00e9vues.</p> <p>Le projet est pr\u00e9vu en deux parties:</p> <ul> <li> <p>La premi\u00e8re est commune \u00e0 tout le monde mais rapporte peu de points. La premi\u00e8re est obligatoire avant de commencer la seconde partie.</p> </li> <li> <p>La seconde partie est r\u00e9alis\u00e9e en groupes de 4 et visera \u00e0 l'am\u00e9lioration de la premi\u00e8re partie sur 4 sujets.</p> </li> </ul>"},{"location":"springboot/Projet/#partie-1","title":"Partie 1","text":"<p>Minimum vital pour la partie 1 :</p> <ul> <li> <p>Int\u00e9gration continue + d\u00e9ploiement kubernetes + AWS</p> </li> <li> <p>Cr\u00e9ation du compte utilisateur et connexion Facebook et Twitter</p> </li> <li> <p>Utilisation de la BDD Redis</p> </li> <li> <p>Utilisation au minimum de Facebook et Twitter</p> </li> <li> <p>Visualisation basique des informations</p> </li> <li> <p>Envoi basique d\u2019un post sur Twitter et Facebook</p> </li> </ul>"},{"location":"springboot/Projet/#partie-2","title":"Partie 2","text":"<p>Les 4 sujets sont les suivants:</p> <ul> <li> <p>Architecture et int\u00e9gration des autres sujets + ajouts autres r\u00e9seaux sociaux.</p> </li> <li> <p>S\u00e9curit\u00e9 et optimisation de la base de donn\u00e9es + tests de charge et test attaque application.</p> </li> <li> <p>Interface graphique et optimisation de l'exp\u00e9rience utilisateur : drag and drop tous types de media, bootstrap, affichage mobile + navigateur.</p> </li> <li> <p>Administration : cr\u00e9ation d\u2019une partie permettant de g\u00e9rer les utilisateurs + reset mot de passe + gestion quota utilisateur BDD + analyse statistique nombre requ\u00e8te utilisateur</p> </li> </ul>"},{"location":"springboot/Projet/#livrables","title":"Livrables","text":"<ul> <li> <p>A la fin de chaque semaine faire un mail par groupe pr\u00e9sentant l'avancement et les points bloquants. </p> </li> <li> <p>A la fin de la premi\u00e8re s\u00e9ance faire une r\u00e9ponse \u00e0 l\u2019\u00e9mission de besoin ( reprendre ce que vous avez compris de la pr\u00e9sentation du projet en d\u00e9taillant techniquement comment vous allez vous y prendre et enfin bien expliquer la partie de votre groupe en proposant la liste des fonctionnalit\u00e9s apport\u00e9s avec au minimum celles pr\u00e9cis\u00e9es plus haut) </p> </li> <li> <p>Pr\u00e9parer une d\u00e9mo pour la fin de la partie 1 </p> </li> <li> <p>Envoi de la partie 2 au d\u00e9but de la derni\u00e8re s\u00e9ance. </p> </li> <li> <p>D\u00e9mo par projet des parties 2 </p> </li> <li> <p>D\u00e9mo globale partie 2 int\u00e9gr\u00e9e </p> </li> </ul>"},{"location":"springboot/ProjetE-Commerce/","title":"Projet E-Commerce","text":""},{"location":"springboot/ProjetE-Commerce/#cahier-des-charges-projet-site-e-commerce","title":"Cahier des charges Projet site E-commerce","text":"<ol> <li>Cr\u00e9ation d\u2019un site d'e-commerce de qualit\u00e9 pro de vente de plusieurs types d\u2019articles. </li> <li>Il devra \u00eatre multilingue (au moins fran\u00e7ais et anglais) . </li> <li>Il devra avoir une barre de recherche et une possibilit\u00e9 de filtrer et trier les r\u00e9sultats affich\u00e9s. </li> <li>Gestion avec s\u00e9curit\u00e9 des comptes utilisateurs. Avec page sign up. </li> <li>Il devra avoir une partie admin permettant de g\u00e9rer les utilisateurs et les articles . </li> <li>Il devra avoir une partie monitoring avec la stack ELK permettant de visualiser les performances du serveur et du flux utilisateur. </li> <li>Il devra pouvoir g\u00e9rer panier, commande, livraison et paiement en ligne par carte et PayPal. </li> <li>Le site devra \u00eatre r\u00e9alis\u00e9 avec Spring boot en backend et angular  et thymeleaf en frontend. Des tests automatiques doivent couvrir la partie backend et frontend. </li> </ol>"},{"location":"springboot/Rattrapage/","title":"Rattrapage","text":""},{"location":"springboot/Rattrapage/#partie-1-exemple-personne","title":"Partie 1 Exemple Personne","text":"<ul> <li>Cette partie (non not\u00e9e) sert d'exemple afin de pouvoir r\u00e9aliser la partie 2 (not\u00e9e). Il est tr\u00e8s vivement conseill\u00e9 de la r\u00e9aliser. Elle permet une meilleure r\u00e9alisation de la suite. Les instructions de 1 \u00e0 4 suivantes ont d\u00e9j\u00e0 \u00e9t\u00e9 r\u00e9alis\u00e9es afin de vous aider. Commencer par le 5)</li> </ul> <p>1) Cr\u00e9er un controller <code>ConsoleController</code> d\u00e9di\u00e9 \u00e0 la console associant l'adresse <code>/console</code> \u00e0 la redirection vers <code>h2-console</code></p> <p>2) Cr\u00e9er un controller <code>MainController</code> permettant de gerer les appels sur nos repository retournant les objets en JSON</p> <ul> <li>Voici les param\u00e8tres \u00e0 utiliser pour les deux prochaines m\u00e9thode: <code>@RequestParam(name = \"method\", required = true, defaultValue = \"id\") String method, @RequestParam(name = \"value\", required = true) String value</code> chaque m\u00e9thode devra avoir un switch prenant en entr\u00e9e <code>method</code></li> </ul> <p>3)  Associer l'adresse <code>/person</code> avec les m\u00e9thodes retournant qu'une valeur (dans le switch)</p> <p>4) Associer l'adresse <code>/persons</code> avec les m\u00e9thodes retournant une liste (dans le switch)</p> <p>5) Acceder \u00e0 la console et cr\u00e9er une querry permettant d'afficher toutes les personnes commen\u00e7ant par <code>S</code></p> <p>6) Cr\u00e9er une nouvelle m\u00e9thode dans le <code>PersonRepository</code> <code>findNameStartingByS</code> et y mapper la query obtenue pr\u00e9c\u00e9demment sachant que dans le code ce n'est pas les tables et champs de la BDD qu'il faut utiliser mais ceux de l'<code>Entity</code></p> <p>7) Refaire la m\u00eame query en language naturel (uniquement en java)  Doc spring</p> <p>8) Cr\u00e9er deux autres query de type different de la premi\u00e8re</p>"},{"location":"springboot/Rattrapage/#partie-2-vraie-bdd","title":"Partie 2 Vraie BDD","text":"<ul> <li>Cr\u00e9er les <code>Entity</code> <code>Agent, Orders, Customer</code> suivant le sch\u00e9ma ci dessous et la d\u00e9claration des tables. Pour le moment considerer les cl\u00e9s \u00e9trang\u00e8res comme des champs simples. Elles seront utilis\u00e9es dans la partie 3. </li> </ul> <pre><code>CREATE TABLE  \"AGENTS\" \n   (    \n    \"AGENT_CODE\" CHAR(6) NOT NULL PRIMARY KEY, \n    \"AGENT_NAME\" CHAR(40), \n    \"WORKING_AREA\" CHAR(35), \n    \"COMMISSION\" NUMBER(10,2), \n    \"PHONE_NO\" CHAR(15), \n    \"COUNTRY\" VARCHAR2(25) \n     );\n\n\nCREATE TABLE  \"CUSTOMER\" \n   (    \n    \"CUST_CODE\" VARCHAR2(6) NOT NULL PRIMARY KEY, \n    \"CUST_NAME\" VARCHAR2(40) NOT NULL, \n    \"CUST_CITY\" CHAR(35), \n    \"WORKING_AREA\" VARCHAR2(35) NOT NULL, \n    \"CUST_COUNTRY\" VARCHAR2(20) NOT NULL, \n    \"GRADE\" NUMBER, \n    \"OPENING_AMT\" NUMBER(12,2) NOT NULL, \n    \"RECEIVE_AMT\" NUMBER(12,2) NOT NULL, \n    \"PAYMENT_AMT\" NUMBER(12,2) NOT NULL, \n    \"OUTSTANDING_AMT\" NUMBER(12,2) NOT NULL, \n    \"PHONE_NO\" VARCHAR2(17) NOT NULL, \n    \"AGENT_CODE\" CHAR(6) NOT NULL REFERENCES AGENTS\n); \n\nCREATE TABLE  \"ORDERS\" \n   (\n    \"ORD_NUM\" NUMBER(6,0) NOT NULL PRIMARY KEY, \n    \"ORD_AMOUNT\" NUMBER(12,2) NOT NULL, \n    \"ADVANCE_AMOUNT\" NUMBER(12,2) NOT NULL, \n    \"ORD_DATE\" DATE NOT NULL, \n    \"CUST_CODE\" VARCHAR2(6) NOT NULL REFERENCES CUSTOMER, \n    \"AGENT_CODE\" CHAR(6) NOT NULL REFERENCES AGENTS, \n    \"ORD_DESCRIPTION\" VARCHAR2(60) NOT NULL\n   );\n</code></pre> <ul> <li> <p>Charger les donn\u00e9es de d\u00e9pot Github dataTP2 soit manuellement soit automatiquement.</p> </li> <li> <p>Cr\u00e9er les repository associ\u00e9s et ajouter des m\u00e9thodes pour:</p> <p>1) Trouver des agents par nom, trouver des agents \u00e0 la commission plus petite que la valeur en param\u00e8tre, trouver des agents par COUNTRY</p> <p>2) Trouver des customers par nom, Trouver des customers par ville et Trouver des customers par <code>openingAtm</code> plus petit que le param\u00e8tre</p> <p>3) Trouver des orders par agent code et Trouver des orders par orderAmount plus petit que le param\u00e8tre</p> </li> <li> <p>Cr\u00e9er des requ\u00e8tes de jointure pour chaque order r\u00e9cup\u00e9rer les valeurs associ\u00e9es d'agent et customer </p> </li> <li> <p>Dans le controller y ajouter les m\u00e9thodes de la m\u00eame fa\u00e7on que pour les personnes et y binder toutes les m\u00e9thodes.</p> </li> </ul>"},{"location":"springboot/Rattrapage/#partie-3-optimisations","title":"Partie 3 Optimisations","text":"<ul> <li> <p>Commenter l'annotation <code>@column</code>  pour les cl\u00e9s externes  et rajouter  <code>@ManyToOne     @JoinColumn(      name=\"nom de la colonne\", unique=false, nullable=false, updatable=true)</code> et remplacer le type du champ par l'objet voulu.</p> </li> <li> <p>Afficher la liste des orders. Que constatez vous? Ecrire la r\u00e9ponse en commentaire apr\u00e8s la ligne</p> </li> </ul> <pre><code>public class ExoBddDaoApplication {\n</code></pre>"},{"location":"springboot/Rattrapage/#fin","title":"Fin","text":"<p>Supprimer le dossier target, zipper le projet de me l'envoyer pr mail. V\u00e9rifier l'envoi du mail (pas de mail de retour \u00e0 cause de la pi\u00e8ce jointe)</p>"},{"location":"springboot/TP1/","title":"TP1","text":"<p>url:</p> <p><code>https://start.spring.io/starter.zip?name=webapp&amp;groupId=com.boot&amp;artifactId=webapp&amp;version=0.0.1-SNAPSHOT&amp;description=Demo+project+for+Spring+Boot&amp;packageName=com.example.demo&amp;type=maven-project&amp;packaging=jar&amp;javaVersion=1.8&amp;language=java&amp;bootVersion=2.3.3.RELEASE&amp;dependencies=devtools&amp;dependencies=h2&amp;dependencies=data-jpa&amp;dependencies=security&amp;dependencies=thymeleaf&amp;dependencies=web</code></p>"},{"location":"springboot/TP1/#partie-1-bdd","title":"Partie 1 BDD","text":"<p>L'utilisation de JPA (Java Persistence API) permet de s'abstraire du langage de requ\u00eate de la base de donn\u00e9es.</p> <p>H2 est une base de donn\u00e9es embarqu\u00e9e, en m\u00e9moire, \u00e9crite en Java qui permet de garder le build portable.</p> <p>La configuration de H2 est tr\u00e8s simple. Il suffit de l'ajouter dans le POM pour que Spring Boot cr\u00e9er automatiquement la database, cr\u00e9er les objets JDBC et configure Hibernate. Hibernate va \u00e0 son tour scanner toutes les annotations JPA et va cr\u00e9er automatiquement les tables dans la BDD.</p> <p>Connexion console :     JDBC URL=url=jdbc:h2:mem:testdb</p>"},{"location":"springboot/TP1/#partie-2-mvc","title":"Partie 2 MVC","text":""},{"location":"springboot/TP1/#crud","title":"CRUD","text":"<p>L'acronyme CRUD (pour create, read, update, delete) d\u00e9signe les quatre op\u00e9rations de base pour la persistance des donn\u00e9es, en particulier le stockage d'informations en base de donn\u00e9es.</p> Operation SQL HTTP Create INSERT POST Read SELECT GET Update UPDATE PUT Delete DELETE DELETE <p>L'annotation <code>@Autowired</code> plac\u00e9e sur un setter permet de demander \u00e0 Spring de d'injecter une d\u00e9pendance.</p> <p>L'annotation <code>@Service</code> plac\u00e9e sur une classe permet de declarer \u00e0 Spring que la classe est un service.</p> <ul> <li>Cr\u00e9er une classe annot\u00e9e composant</li> </ul> <pre><code>public class ProductLoader implements ApplicationListener&lt;ContextRefreshedEvent&gt;{}\n</code></pre> <p>Y injecter le ProductRepository. Dans le onApplication event injecter plusieurs instances de produit dans le productRepository.</p> <ul> <li>Cr\u00e9er l'interface ProductService permettant au controller d'interragir avec le mod\u00e8le:</li> </ul> <pre><code>public interface ProductService {\n    Iterable&lt;Product&gt; listAllProducts();\n\n    Product getProductById(Integer id);\n\n    Product saveProduct(Product product);\n\n    void deleteProduct(Integer id);\n}\n</code></pre> <ul> <li> <p>Implementer le @Service ProductServiceImpl en mappant toutes les m\u00e9thodes sur le ProductRepository (\u00e0 injecter)</p> </li> <li> <p>Completer le controller suivant. Il doit utiliser le ProductService.</p> </li> </ul> <pre><code>@Controller\npublic class ProductController {\n     private ProductService productService;\n     //GET sur /products\n\n        public String list(Model model){\n            model.addAttribute(\"products\", ....\n            return \"products\";\n        }\n\n        //GET sur \"product/show/{id}\"\n        public String showProduct(@PathVariable Integer id, Model model){\n            model.addAttribute(\"product\", ...\n            return \"productshow\";\n        }\n\n        //GET sur \"product/edit/{id}\"\n        public String edit(@PathVariable Integer id, Model model){\n            model.addAttribute(\"product\",...\n            return \"productform\";\n        }\n\n        //GET sur\"product/new\"\n        public String newProduct(Model model){\n            model.addAttribute(\"product\", new Product());\n            return \"productform\";\n        }\n\n        //POST sur \"product\"\n        public String saveProduct(Product product){\n            ...\n            return \"redirect:/product/show/\" + product.getId();\n        }\n\n        //GET sur \"product/delete/{id}\"\n        public String delete(@PathVariable Integer id){\n            ...\n            return \"redirect:/products\";\n        }\n}\n</code></pre>"},{"location":"springboot/TP1/#creation-mise-a-jour-dun-product","title":"Cr\u00e9ation / mise \u00e0 jour d'un product","text":"<p>La m\u00eame page HTML peut \u00eatre utilis\u00e9e pour cr\u00e9er et mettre \u00e0 jour les produits.</p> <p>L'astuce consiste \u00e0 faire en sorte que le controller retourne un objet vide pour une cr\u00e9ation et l'objet existant pour une mise \u00e0 jour. De cette fa\u00e7on il n'y aura pas de probl\u00e8mes d'objets null. Et toutes les propri\u00e9t\u00e9s non nulle peuvent se transformer en formulaire.</p> <p>La ligne suivante cr\u00e9e le formulaire dans Thymeleaf.</p> <pre><code>&lt;form class=\"form-horizontal\" th:object=\"${product}\" th:action=\"@{/product}\" method=\"post\"&gt;\n</code></pre> <p>Le tag <code>th:object</code> relie l'objet product au formulaire.</p> <p>Le tag <code>th:action</code> d\u00e9finit quelle url doit \u00eatre appel\u00e9e lors de la soumission du formulaire (/product) url. La m\u00e9thode <code>post</code> est aussi renseign\u00e9e.</p> <p>C'est donc le controller suivant qui va \u00eatre appel\u00e9:</p> <p><pre><code>@RequestMapping(value = \"product\", method = RequestMethod.POST)\npublic String saveProduct(Product product){\n    productService.saveProduct(product);\n    return \"redirect:/product/\" + product.getId();\n}\n</code></pre> Il retourne vers l'objet modifi\u00e9.</p> <p>L'\u00e9tape suivante est cruciale pour que les mise \u00e0 jour fonctionnent.</p> <p>Toutes les entit\u00e9s pr\u00e9sentes en BDD ont un ID. L'utilisateur ne peut pas l'\u00e9diter mais il doit \u00eatre pr\u00e9sent dans la requ\u00eate de retour vers le serveur. Si l'ID est manquant, le syst\u00e8me ne peut pas savoir si c'est une M\u00e0J ou une cr\u00e9ation. En cas d'oubli de l'ID une nouvelle entit\u00e9 sera cr\u00e9e en BDD.</p> <p>La mani\u00e8re de g\u00e9rer ce probl\u00e8me est d'inclure des champs cach\u00e9s. (Pour hibernate le champ version permet d'\u00e9viter les conflits de mise \u00e0 jour)</p> <pre><code>&lt;input type=\"hidden\" th:field=\"*{id}\"/&gt;\n&lt;input type=\"hidden\" th:field=\"*{version}\"/&gt;\n</code></pre> <ul> <li>Dans la prochaine \u00e9tape nous allons utiliser dans fragments dans nos pages HTML pour \u00e9viter de r\u00e9p\u00e9ter du code.</li> </ul> <p>index.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head lang=\"en\"&gt;\n    &lt;title&gt;Spring boot Web app&lt;/title&gt;\n&lt;!--     Inclusion d'un fragment, uniquement visible quand execut\u00e9 par spring --&gt;\n&lt;!--     La mise en commentaire permet de faire afficher la page dans le browser sans erreur --&gt;\n\n    &lt;!--/*/ &lt;th:block th:include=\"fragments/headerinc :: head\"&gt;&lt;/th:block&gt; /*/--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=\"container\"&gt;\n    &lt;!--/*/ &lt;th:block th:include=\"fragments/menu :: header\"&gt;&lt;/th:block&gt; /*/--&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>fragments/headerinc.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n&lt;head lang=\"en\" th:fragment=\"head\"&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;\n&lt;link\n    href=\"http://cdn.jsdelivr.net/webjars/bootstrap/3.3.4/css/bootstrap.min.css\"\n    th:href=\"@{/webjars/bootstrap/3.3.4/css/bootstrap.min.css}\"\n    rel=\"stylesheet\" media=\"screen\" /&gt;\n&lt;script src=\"http://cdn.jsdelivr.net/webjars/jquery/2.1.4/jquery.min.js\"\n    th:src=\"@{/webjars/jquery/2.1.4/jquery.min.js}\"&gt;&lt;/script&gt;\n&lt;link href=\"../../static/css/boot.css\" th:href=\"@{../css/boot.css}\"\n    rel=\"stylesheet\" media=\"screen\" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>fragments/menu.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n&lt;head lang=\"en\"&gt;\n    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt;\n    &lt;link href=\"http://cdn.jsdelivr.net/webjars/bootstrap/3.3.4/css/bootstrap.min.css\"\n          th:href=\"@{/webjars/bootstrap/3.3.4/css/bootstrap.min.css}\"\n          rel=\"stylesheet\" media=\"screen\"/&gt;\n\n    &lt;script src=\"http://cdn.jsdelivr.net/webjars/jquery/2.1.4/jquery.min.js\"\n            th:src=\"@{/webjars/jquery/2.1.4/jquery.min.js}\"&gt;&lt;/script&gt;\n\n   &lt;link href=\"../../static/css/boot.css\" th:href=\"@{../css/boot.css}\"\n    rel=\"stylesheet\" media=\"screen\" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div class=\"container\"&gt;\n    &lt;div th:fragment=\"header\"&gt;\n        &lt;nav class=\"navbar navbar-default\"&gt;\n            &lt;div class=\"container-fluid\"&gt;\n                &lt;div class=\"navbar-header\"&gt;\n                    &lt;a class=\"navbar-brand\" href=\"#\" th:href=\"@{/}\"&gt;Home&lt;/a&gt;\n                    &lt;ul class=\"nav navbar-nav\"&gt;\n                        &lt;li&gt;&lt;a href=\"#\" th:href=\"@{/products}\"&gt;Products&lt;/a&gt;&lt;/li&gt;\n                        &lt;li&gt;&lt;a href=\"#\" th:href=\"@{/product/new}\"&gt;Create Product&lt;/a&gt;&lt;/li&gt;\n                    &lt;/ul&gt;\n\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/nav&gt;\n\n        &lt;div class=\"jumbotron\"&gt;\n            &lt;div class=\"row text-center\"&gt;\n                &lt;div class=\"\"&gt;\n                    &lt;h2&gt;Spring Framework&lt;/h2&gt;\n\n                    &lt;h3&gt;Spring Boot Web App&lt;/h3&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"row text-center\"&gt;\n                &lt;img alt=\"boots\" src=\"images/boots.jpg\" width=\"300\"\n        th:src=\"@{../../images/boots.jpg}\"/&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>Puis nous allons ajouter les vues produit</li> </ul> <p>products.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"\n    xmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\"&gt;\n&lt;head lang=\"en\"&gt;\n\n&lt;title&gt;Spring Framework&lt;/title&gt;\n\n&lt;!--/*/ &lt;th:block th:include=\"fragments/headerinc :: head\"&gt;&lt;/th:block&gt; /*/--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;!--/*/ &lt;th:block th:include=\"fragments/menu :: header\"&gt;&lt;/th:block&gt; /*/--&gt;\n\n        &lt;div th:if=\"${not #lists.isEmpty(products)}\"&gt;\n            &lt;form th:action=\"@{/logout}\" method=\"post\"&gt;\n                &lt;div class=\"col-sm-10\"&gt;\n                    &lt;h2&gt;Product Listing&lt;/h2&gt;\n                &lt;/div&gt;\n                &lt;div class=\"col-sm-2\" style=\"padding-top: 30px;\"&gt;\n                    &lt;span sec:authorize=\"isAuthenticated()\"&gt; &lt;input\n                        type=\"submit\" value=\"Sign Out\" /&gt;\n                    &lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/form&gt;\n            &lt;table class=\"table table-striped\"&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;Id&lt;/th&gt;\n                    &lt;th&gt;Product Id&lt;/th&gt;\n                    &lt;th&gt;Description&lt;/th&gt;\n                    &lt;th&gt;Price&lt;/th&gt;\n                &lt;th sec:authorize=\"hasAnyRole('ROLE_USER','ROLE_ADMIN')\"&gt;View&lt;/th&gt;\n                &lt;th sec:authorize=\"hasRole('ROLE_ADMIN')\"&gt;Edit&lt;/th&gt;\n                &lt;th sec:authorize=\"hasRole('ROLE_ADMIN')\"&gt;Delete&lt;/th&gt;\n                &lt;/tr&gt;\n                &lt;tr th:each=\"product : ${products}\"&gt;\n                    &lt;td th:text=\"${product.id}\"&gt;&lt;a href=\"/product/${product.id}\"&gt;Id&lt;/a&gt;&lt;/td&gt;\n&lt;!--    la notation th est equivalente au java     Product Id permet d'avoir un affichage avec un browser seul--&gt;\n                    &lt;td th:text=\"${product.productId}\"&gt;Product Id&lt;/td&gt;\n                    &lt;td th:text=\"${product.description}\"&gt;descirption&lt;/td&gt;\n                    &lt;td th:text=\"${product.price}\"&gt;price&lt;/td&gt;\n                &lt;td sec:authorize=\"hasAnyRole('ROLE_USER','ROLE_ADMIN')\"&gt;&lt;a th:href=\"${'/product/show/' + product.id}\"&gt;View&lt;/a&gt;&lt;/td&gt;\n                &lt;td sec:authorize=\"hasRole('ROLE_ADMIN')\"&gt;&lt;a th:href=\"${'/product/edit/' + product.id}\"&gt;Edit&lt;/a&gt;&lt;/td&gt;\n                &lt;td sec:authorize=\"hasRole('ROLE_ADMIN')\"&gt;&lt;a th:href=\"${'/product/delete/' + product.id}\"&gt;Delete&lt;/a&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>productshow.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\"&gt;\n&lt;head lang=\"en\"&gt;\n&lt;title&gt;Spring Framework&lt;/title&gt;\n&lt;!--/*/ &lt;th:block th:include=\"fragments/headerinc :: head\"&gt;&lt;/th:block&gt; /*/--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n    &lt;!--/*/ &lt;th:block th:include=\"fragments/menu :: header\"&gt;&lt;/th:block&gt; /*/--&gt;\n\n     &lt;form class=\"form-horizontal\" th:action=\"@{/logout}\" method=\"post\"&gt;\n        &lt;div class=\"form-group\"&gt;\n            &lt;div class=\"col-sm-10\"&gt;&lt;h2&gt;Product Details&lt;/h2&gt;&lt;/div&gt;\n            &lt;div class=\"col-sm-2\" style=\"padding-top: 25px;\"&gt;\n         &lt;span sec:authorize=\"isAuthenticated()\"&gt;\n              &lt;input type=\"submit\" value=\"Sign Out\"/&gt;\n           &lt;/span&gt;\n\n            &lt;/div&gt;\n        &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label class=\"col-sm-2 control-label\"&gt;Product Id:&lt;/label&gt;\n                    &lt;div class=\"col-sm-10\"&gt;\n                        &lt;p class=\"form-control-static\" th:text=\"${product.id}\"&gt;Product Id&lt;/p&gt;&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label class=\"col-sm-2 control-label\"&gt;Product Bar Code:&lt;/label&gt;\n                    &lt;div class=\"col-sm-10\"&gt;\n                        &lt;p class=\"form-control-static\" th:text=\"${product.productId}\"&gt;Product Bar code&lt;/p&gt;&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label class=\"col-sm-2 control-label\"&gt;Description:&lt;/label&gt;\n                    &lt;div class=\"col-sm-10\"&gt;\n                        &lt;p class=\"form-control-static\" th:text=\"${product.description}\"&gt;description&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label class=\"col-sm-2 control-label\"&gt;Price:&lt;/label&gt;\n                    &lt;div class=\"col-sm-10\"&gt;\n                        &lt;p class=\"form-control-static\" th:text=\"${product.price}\"&gt;Priceaddd&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label class=\"col-sm-2 control-label\"&gt;Image Url:&lt;/label&gt;\n                    &lt;div class=\"col-sm-10\"&gt;\n                        &lt;p class=\"form-control-static\" th:text=\"${product.imageUrl}\"&gt;url....&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>productform.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n&lt;head lang=\"en\"&gt;\n\n    &lt;title&gt;Spring Framework&lt;/title&gt;\n\n    &lt;!--/*/ &lt;th:block th:include=\"fragments/headerinc :: head\"&gt;&lt;/th:block&gt; /*/--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=\"container\"&gt;\n    &lt;!--/*/ &lt;th:block th:include=\"fragments/menu :: header\"&gt;&lt;/th:block&gt; /*/--&gt;\n\n    &lt;form class=\"form-horizontal\" th:action=\"@{/logout}\" method=\"post\"&gt;\n        &lt;div class=\"form-group\"&gt;\n            &lt;div class=\"col-sm-10\"&gt; &lt;h2&gt;Product Create/Update&lt;/h2&gt;&lt;/div&gt;\n            &lt;div class=\"col-sm-2\" style=\"padding-top: 30px;\"&gt;\n                &lt;input  type=\"submit\" value=\"Sign Out\"/&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n\n    &lt;div&gt;\n        &lt;form class=\"form-horizontal\" th:object=\"${product}\" th:action=\"@{/product}\" method=\"post\"&gt;\n            &lt;input type=\"hidden\" th:field=\"*{id}\"/&gt;\n            &lt;input type=\"hidden\" th:field=\"*{version}\"/&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label class=\"col-sm-2 control-label\"&gt;Bar Code:&lt;/label&gt;\n                &lt;div class=\"col-sm-10\"&gt;\n                    &lt;input type=\"text\" class=\"form-control\" th:field=\"*{productId}\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label class=\"col-sm-2 control-label\"&gt;Description:&lt;/label&gt;\n                &lt;div class=\"col-sm-10\"&gt;\n                    &lt;input type=\"text\" class=\"form-control\" th:field=\"*{description}\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label class=\"col-sm-2 control-label\"&gt;Price:&lt;/label&gt;\n                &lt;div class=\"col-sm-10\"&gt;\n                    &lt;input type=\"text\" class=\"form-control\" th:field=\"*{price}\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label class=\"col-sm-2 control-label\"&gt;Image Url:&lt;/label&gt;\n                &lt;div class=\"col-sm-10\"&gt;\n                    &lt;input type=\"text\" class=\"form-control\" th:field=\"*{imageUrl}\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"row\"&gt;\n                &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"springboot/TP1/#partie-3-securite-roles-et-permissions","title":"Partie 3 S\u00e9curit\u00e9 / R\u00f4les et permissions","text":"<p>Ce que nous voulons r\u00e9aliser:</p> <ul> <li>Pour un utilisateur pas authentifi\u00e9: Vue page d'accueil et liste de produits.</li> <li>Pour un utilisateur authentifi\u00e9 (R\u00f4le USER) vue en plus des d\u00e9tails du produit.</li> <li>Pour un  utilisateur authentifi\u00e9 (R\u00f4le ADMIN) CRUD sur les produits.</li> </ul> <p>A faire:</p> <ul> <li>Ajout d\u00e9pendance <code>thymeleaf-extras-springsecurity5</code></li> <li>Ajout de la page login.html</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n&lt;head&gt;\n&lt;title&gt;Login Form&lt;/title&gt;\n&lt;!--/*/ &lt;th:block th:include=\"fragments/headerinc :: head\"&gt;&lt;/th:block&gt; /*/--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;!--/*/ &lt;th:block th:include=\"fragments/menu :: header\"&gt;&lt;/th:block&gt; /*/--&gt;\n        &lt;div th:if=\"${param.error}\"&gt;\n            &lt;label style=\"color: red\"&gt;Invalid username and password.&lt;/label&gt;\n        &lt;/div&gt;\n        &lt;div th:if=\"${param.logout}\"&gt;\n            &lt;label&gt; You have been logged out. &lt;/label&gt;\n        &lt;/div&gt;\n\n        &lt;form th:action=\"@{/login}\" method=\"post\"&gt;\n\n            &lt;table class=\"table table-striped\"&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;&lt;label&gt; User Name : &lt;input type=\"text\" name=\"username\" /&gt;\n                    &lt;/label&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;&lt;label&gt; Password : &lt;input type=\"password\" name=\"password\" /&gt;\n                    &lt;/label&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;\n                        &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Sign In&lt;/button&gt;\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/table&gt;\n\n        &lt;/form&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li> <p>Ajout dans le ProductController de la gestion de la page login</p> </li> <li> <p>Modification du controller de s\u00e9curit\u00e9:</p> </li> <li>Sp\u00e9cifier les url n\u00e9cessitant de s\u00e9curit\u00e9.</li> <li>Pour toutes les autres rajouter le code suivant:</li> </ul> <pre><code>    .anyRequest().permitAll()\n            .and().formLogin().loginPage(\"/login\").permitAll()\n            .and().logout().permitAll();\n</code></pre> <ul> <li> <p>R\u00e9utiliser le bean de cr\u00e9ation d'utilisateurs du TP Thymleaf-security</p> </li> <li> <p>Ajout dans le menu d'une condition de cr\u00e9ation de product: <code>sec:authorize=\"hasRole('ROLE_ADMIN')\"</code></p> </li> </ul>"},{"location":"springboot/TP1/#partie-4-securisation-de-lapplication-avec-la-bdd","title":"Partie 4 S\u00e9curisation de l'application avec la BDD","text":""},{"location":"springboot/TP1/#creation-des-entitees-jpa","title":"Cr\u00e9ation des entit\u00e9es JPA.","text":"<p>Bien lire les commentaires sur les classes. Les classes Roles et User ont une relation multivaleur (many-to-many) qui d\u00e9termine que pour chaque enregistrement d'une table, il peut y avoir aucun, un ou plusieurs enregistrements d'une autre table qui lui soit li\u00e9s.</p> <pre><code>package com.boot.entities;\n\n/**\n * Cette interface permet d avoir une base commune entre les classes User et Role\n */\npublic interface DomainObject {\n\n    Integer getId();\n\n    void setId(Integer id);\n}\n</code></pre> <pre><code>package com.boot.entities;\n\nimport javax.persistence.*;\nimport java.util.Date;\n\n//Permer meme avec heritage de ne pas generer une table pour cet objet\n@MappedSuperclass\npublic class AbstractDomainClass implements DomainObject {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    Integer id;\n\n    @Version\n    private Integer version;\n\n    private Date dateCreated;\n    private Date lastUpdated;\n\n    @Override\n    public Integer getId() {\n        return this.id;\n    }\n\n    @Override\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public Integer getVersion() {\n        return version;\n    }\n\n    public void setVersion(Integer version) {\n        this.version = version;\n    }\n\n    public Date getDateCreated() {\n        return dateCreated;\n    }\n\n    public Date getLastUpdated() {\n        return lastUpdated;\n    }\n\n    //Permet de s assurer que la date est bien mise a jour a chaque update en BDD\n    @PreUpdate\n    @PrePersist\n    public void updateTimeStamps() {\n        lastUpdated = new Date();\n        if (dateCreated==null) {\n            dateCreated = new Date();\n        }\n    }\n}\n</code></pre> <pre><code>package com.boot.entities;\n\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.JoinTable;\nimport javax.persistence.ManyToMany;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n@Entity\npublic class Role extends AbstractDomainClass {\n\n    private String role;\n\n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable\n    // ~ defaults to @JoinTable(name = \"USER_ROLE\", joinColumns = @JoinColumn(name = \"role_id\"),\n    //     inverseJoinColumns = @joinColumn(name = \"user_id\"))\n    private List&lt;User&gt; users = new ArrayList&lt;&gt;();\n\n    public String getRole() {\n        return role;\n    }\n\n    public void setRole(String role) {\n        this.role = role;\n    }\n\n    public List&lt;User&gt; getUsers() {\n        return users;\n    }\n\n    public void setUsers(List&lt;User&gt; users) {\n        this.users = users;\n    }\n\n    public void addUser(User user){\n        if(!this.users.contains(user)){\n            this.users.add(user);\n        }\n\n        if(!user.getRoles().contains(this)){\n            user.getRoles().add(this);\n        }\n    }\n\n    public void removeUser(User user){\n        this.users.remove(user);\n        user.getRoles().remove(this);\n    }\n\n}\n</code></pre> <pre><code> package com.boot.entities;\n\nimport javax.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n@Entity\npublic class User extends AbstractDomainClass  {\n\n    private String username;\n\n    //Le mot de passe est annote Transient afin de ne pas stoquer le mot de passe en clair\n    //mais d utiliser celui encrypte\n    @Transient\n    private String password;\n\n    private String encryptedPassword;\n    private Boolean enabled = true;\n\n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable\n    // ~ defaults to @JoinTable(name = \"USER_ROLE\", joinColumns = @JoinColumn(name = \"user_id\"),\n    //     inverseJoinColumns = @joinColumn(name = \"role_id\"))\n    private List&lt;Role&gt; roles = new ArrayList&lt;&gt;();\n    private Integer failedLoginAttempts = 0;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getEncryptedPassword() {\n        return encryptedPassword;\n    }\n\n    public void setEncryptedPassword(String encryptedPassword) {\n        this.encryptedPassword = encryptedPassword;\n    }\n\n    public Boolean getEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(Boolean enabled) {\n        this.enabled = enabled;\n    }\n\n\n    public List&lt;Role&gt; getRoles() {\n        return roles;\n    }\n\n    public void setRoles(List&lt;Role&gt; roles) {\n        this.roles = roles;\n    }\n\n    public void addRole(Role role){\n        if(!this.roles.contains(role)){\n            this.roles.add(role);\n        }\n\n        if(!role.getUsers().contains(this)){\n            role.getUsers().add(this);\n        }\n    }\n\n    public void removeRole(Role role){\n        this.roles.remove(role);\n        role.getUsers().remove(this);\n    }\n\n    public Integer getFailedLoginAttempts() {\n        return failedLoginAttempts;\n    }\n\n    public void setFailedLoginAttempts(Integer failedLoginAttempts) {\n        this.failedLoginAttempts = failedLoginAttempts;\n    }\n}\n</code></pre>"},{"location":"springboot/TP1/#repositories-jpa","title":"Repositories JPA","text":"<ul> <li> <p>Nous allons cr\u00e9er un UserRepository et un RoleRepository sur le m\u00eame exemple que le ProductRepository.</p> </li> <li> <p>Dans UserRepository ajouter la m\u00e9thode</p> </li> </ul> <p><code>User findByUsername(String username);</code></p> <ul> <li>Les classes d'impl\u00e9mentation seront g\u00e9n\u00e9r\u00e9es automatiquement par Spring JPA.</li> </ul>"},{"location":"springboot/TP1/#services-jpa","title":"Services JPA","text":"<ul> <li>Ajouter :</li> </ul> <pre><code>package com.boot.services;\n\nimport java.util.List;\n\npublic interface CRUDService&lt;T&gt; {\n    List&lt;?&gt; listAll();\n\n    T getById(Integer id);\n\n    T saveOrUpdate(T domainObject);\n\n    void delete(Integer id);\n}\n</code></pre> <p><code>RoleService</code> et <code>UserService</code> \u00e9tendent <code>CRUDService</code> qui d\u00e9finit les op\u00e9rations CRUD de base sur les entit\u00e9s. <code>UserService</code>, avec la m\u00e9thode suppl\u00e9mentaire     <code>User findByUsername(String username);</code> , est une interface de service plus sp\u00e9cialis\u00e9e pour les op\u00e9rations CRUD sur <code>User</code>.</p> <p>Nous avons rendu les interfaces de service g\u00e9n\u00e9riques pour masquer nos impl\u00e9mentations de service en utilisant le design pattern Fa\u00e7ade. Les impl\u00e9mentations peuvent \u00eatre Spring Data JPA avec r\u00e9f\u00e9rentiel, DAO, ou m\u00eame JDBC simple, ou un service Web externe. Le code client n'a pas besoin de conna\u00eetre l'impl\u00e9mentation. En utilisant des interfaces, nous sommes en mesure de tirer parti de plusieurs impl\u00e9mentations concr\u00e8tes des services.</p> <ul> <li> <p>Cr\u00e9er les trois classes (idem que ProductService)</p> </li> <li> <p>Completer UserServiceImpl</p> </li> </ul> <pre><code>package com.boot.services;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Profile;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport com.boot.entities.User;\nimport com.boot.repositories.UserRepository;\nimport com.boot.services.security.EncryptionService;\n\n\n...\npublic class UserServiceImpl implements UserService {\n    // a injecter\n    private UserRepository userRepository;\n\n    ...\n    // a injecter\n    private EncryptionService encryptionService;\n\n    ....\n\n    @Override\n    public List&lt;?&gt; listAll() {\n        ...\n        return users;\n    }\n\n    @Override\n    public User getById(Integer id) {\n        return ...\n    }\n\n    @Override\n    public User saveOrUpdate(User domainObject) {\n        if(domainObject.getPassword() != null){\n            domainObject.setEncryptedPassword(encryptionService.encryptString(domainObject.getPassword()));\n        }\n        return ...\n    }\n    @Override\n      @Transactional\n       public void delete(Integer id) {\n        ...\n    }\n\n    @Override\n    public User findByUsername(String username) {\n        return ...\n    }\n}\n</code></pre> <ul> <li>Completer RoleServiceImpl</li> </ul> <pre><code>package com.boot.services;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Profile;\nimport org.springframework.stereotype.Service;\n\nimport com.boot.entities.Role;\nimport com.boot.repositories.RoleRepository;\n\n...\npublic class RoleServiceImpl implements RoleService {\n    //inject\n    private RoleRepository roleRepository;\n\n    ...\n\n    @Override\n    public List&lt;?&gt; listAll() {\n       ...\n        return roles;\n    }\n\n    @Override\n    public Role getById(Integer id) {\n        return ...\n    }\n\n    @Override\n    public Role saveOrUpdate(Role domainObject) {\n        return ...\n    }\n\n    @Override\n    public void delete(Integer id) {\n        ...\n    }\n}\n</code></pre>"},{"location":"springboot/TP1/#cryptage-du-mot-de-passe","title":"Cryptage du mot de passe","text":"<ul> <li>Ajout des d\u00e9pendances suivantes</li> </ul> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;org.jasypt&lt;/groupId&gt;\n            &lt;artifactId&gt;jasypt-springsecurity4&lt;/artifactId&gt;\n            &lt;version&gt;1.9.3&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;\n            &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre> <ul> <li>Dans la classe placer les bonnes annotations</li> </ul> <pre><code>package com.boot.configuration;\n\nimport org.jasypt.util.password.StrongPasswordEncryptor;\n\n...\npublic class CommonBeanConfig {\n    ...\n    public StrongPasswordEncryptor strongEncryptor() {\n        StrongPasswordEncryptor encryptor = new StrongPasswordEncryptor();\n        return encryptor;\n    }\n}\n</code></pre> <ul> <li>Ajout de EncryptionService</li> </ul> <pre><code>package com.boot.services.security;\n\npublic interface EncryptionService {\n    String encryptString(String input);\n    boolean checkPassword(String plainPassword, String encryptedPassword);\n}\n</code></pre> <ul> <li> <p>Impl\u00e9menter EncryptionServiceImpl en utilisant org.jasypt.util.password.StrongPasswordEncryptor</p> </li> <li> <p>Spring Security fournit une interface UserDetailsService pour rechercher le nom d'utilisateur, le mot de passe et GrantedAuthorities pour tout utilisateur donn\u00e9. Cette interface ne fournit qu'une seule m\u00e9thode, loadUserByUsername (). Cette m\u00e9thode renvoie une impl\u00e9mentation de l'interface UserDetails de Spring Security qui fournit des informations utilisateur.</p> </li> <li> <p>Compl\u00e9ter et ajouter tous les setters n\u00e9cessaires.</p> </li> </ul> <pre><code>package com.boot.services.security;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport java.util.Collection;\n\n\npublic class UserDetailsImpl implements UserDetails {\n\n    private Collection&lt;SimpleGrantedAuthority&gt; authorities;\n    private String username;\n    private String password;\n    private Boolean enabled = true;\n...\n        public void setAuthorities(Collection&lt;SimpleGrantedAuthority&gt; authorities) {\n                this.authorities = authorities;\n        }\n}\n</code></pre> <ul> <li>Dans cette classe, nous avons d\u00e9fini les champs de notre mod\u00e8le de donn\u00e9es et leurs m\u00e9thodes setter correspondantes. Le <code>SimpleGrantedAuthority</code> que nous avons d\u00e9finit est une impl\u00e9mentation Spring Security d'une autorit\u00e9 que nous convertirons de notre r\u00f4le. Pensez \u00e0 une autorit\u00e9 comme \u00e9tant une \u00abpermission\u00bb ou un \u00abdroit\u00bb g\u00e9n\u00e9ralement exprim\u00e9 sous forme de cha\u00eene de caract\u00e8re.</li> </ul> <p>Nous devons fournir une impl\u00e9mentation de la m\u00e9thode <code>loadUserByUsername ()</code> de <code>UserDetailsService</code>. Mais le d\u00e9fi est que la m\u00e9thode <code>findByUsername ()</code> de notre <code>UserService</code> renvoie une entit\u00e9 <code>User</code>, tandis que Spring Security attend un objet <code>UserDetails</code> de la m\u00e9thode <code>loadUserByUsername ()</code>.</p> <p>Nous allons cr\u00e9er un convertisseur pour cela afin de convertir l'impl\u00e9mentation <code>User</code> en <code>UserDetails</code>.</p> <ul> <li>Compl\u00e9ter:</li> </ul> <pre><code>package com.boot.services.security;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Component;\n\nimport com.boot.entities.User;\n\n...\npublic class UserToUserDetails implements Converter&lt;User, UserDetails&gt; {\n    @Override\n    public UserDetails convert(User user) {\n        UserDetailsImpl userDetails = new UserDetailsImpl();\n\n        if (user != null) {\n            userDetails.set...// tout setter\n            Collection&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n            user.getRoles().forEach(role -&gt; {\n                authorities.add(new SimpleGrantedAuthority(role.getRole()));\n            });\n            userDetails.setAuthorities(authorities);\n        }\n\n        return userDetails;\n    }\n}\n</code></pre> <ul> <li>Cette classe impl\u00e9mente l'interface Spring Core Coverter et surcharge la m\u00e9thode <code>convert ()</code> qui accepte un objet User \u00e0 convertir.</li> </ul> <p>Le convertisseur \u00e9tant pr\u00eat, il est d\u00e9sormais facile d\u2019impl\u00e9menter l\u2019interface <code>UserDetailsService</code>. La classe d'impl\u00e9mentation est la suivante.</p> <pre><code>package com.boot.services.security;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport com.boot.entities.User;\nimport com.boot.services.UserService;\n\n@Service(\"userDetailsService\")\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    private UserService userService; // to set\n    private Converter&lt;User, UserDetails&gt; userUserDetailsConverter;\n\n    ...\n\n    ...\n    @Qualifier(value = \"userToUserDetails\")\n    public void setUserUserDetailsConverter(Converter&lt;User, UserDetails&gt; userUserDetailsConverter) {\n        this.userUserDetailsConverter = userUserDetailsConverter;\n    }\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        return userUserDetailsConverter.convert(...//utiliser userService\n    }\n}\n</code></pre>"},{"location":"springboot/TP1/#configuration-de-la-securite","title":"Configuration de la S\u00e9curit\u00e9","text":"<ul> <li>La classe de configuration de s\u00e9curit\u00e9 actuelle, <code>SecurityConfiguration</code>, \u00e9tend <code>WebSecurityConfigurerAdapter</code> pour configurer deux choses. Un fournisseur d'authentification et les URL de l'application \u00e0 prot\u00e9ger.Il reste \u00e0 enregistrer le fournisseur d'authentification DAO pour une utilisation avec Spring Security.</li> </ul> <p>Nous allons commencer par mettre en place un encodeur de mot de passe pour encoder les mots de passe pr\u00e9sents dans l'objet <code>UserDetails</code> renvoy\u00e9 par le <code>configuredUserDetailsService</code>. Nous allons d\u00e9finir un nouveau bean pour <code>PasswordEncoder</code> de Spring Security qui prend en charge le bean <code>StrongPassordEncryptor</code>.</p> <p>Rappelez-vous que nous avons cr\u00e9\u00e9 <code>StrongPassordEncryptor</code> plus t\u00f4t dans la classe de configuration <code>CommonBeanConfig</code>?</p> <ul> <li>Compl\u00e9ter la classe</li> </ul> <pre><code>package com.boot.configuration;\n\nimport org.jasypt.springsecurity4.crypto.password.PasswordEncoder;\nimport org.jasypt.util.password.StrongPasswordEncryptor;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.provisioning.InMemoryUserDetailsManager;\n\n...\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .antMatchers(\"/product/edit/*\",\"/product/new\",\"/product/delete/*\",\"/product/show/*\").authenticated()\n            .anyRequest().permitAll()\n            .and().formLogin().loginPage(\"/login\").permitAll()\n            .and().logout().permitAll();\n        http.csrf().disable();\n        http.headers().frameOptions().disable();\n    }\n\n    ...\n    public PasswordEncoder passwordEncoder(StrongPasswordEncryptor passwordEncryptor){\n        PasswordEncoder passwordEncoder = new PasswordEncoder();\n        passwordEncoder.setPasswordEncryptor(passwordEncryptor);\n        return passwordEncoder;\n    }\n    ...\n    public DaoAuthenticationProvider daoAuthenticationProvider(PasswordEncoder passwordEncoder, UserDetailsService userDetailsService){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder);\n        daoAuthenticationProvider.setUserDetailsService(userDetailsService);\n        return daoAuthenticationProvider;\n    }\n    ...\n    public void configureAuthManager(AuthenticationManagerBuilder authenticationManagerBuilder, @Qualifier(\"daoAuthenticationProvider\") AuthenticationProvider authenticationProvider){\n        authenticationManagerBuilder.authenticationProvider(authenticationProvider);\n    }\n}\n</code></pre> <ul> <li><code>PasswordEncoder</code> va utiliser la biblioth\u00e8que <code>Jasypt</code> pour encoder le mot de passe et v\u00e9rifier que les mots de passe correspondent. Le <code>UserDetailsService</code> r\u00e9cup\u00e9rera l'objet User de la base de donn\u00e9es et le transf\u00e9rera \u00e0 Spring Security en tant qu'objet <code>UserDetails</code>.</li> </ul>"},{"location":"springboot/TP1/#initialisation-de-lapplication","title":"Initialisation de l'Application","text":"<p>Pour les donn\u00e9es de d\u00e9part de l'application, nous avons une classe d'impl\u00e9mentation <code>ApplicationListener</code> qui est appel\u00e9e sur le <code>ContextRefresedEvent</code> au d\u00e9marrage. Dans cette classe, nous utiliserons Spring pour injecter les r\u00e9f\u00e9rentiels JPA <code>UserRepository</code> et <code>RoleRepository</code>. Nous allons cr\u00e9er deux entit\u00e9s <code>User</code> et deux <code>Role</code> et les enregistrer dans la base de donn\u00e9es au d\u00e9marrage de l'application.</p> <ul> <li> <p>Supprimer la classe <code>ProductLoader</code></p> </li> <li> <p>Compl\u00e9ter la classe suivante</p> </li> </ul> <pre><code>package com.boot.mocks;\n\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.event.ContextRefreshedEvent;\nimport org.springframework.stereotype.Component;\n\nimport com.boot.entities.Product;\nimport com.boot.entities.Role;\nimport com.boot.entities.User;\nimport com.boot.repositories.ProductRepository;\nimport com.boot.services.RoleService;\nimport com.boot.services.UserService;\n\n...\npublic class SpringJpaBootstrap implements ApplicationListener&lt;ContextRefreshedEvent&gt; {\n\n    private ProductRepository productRepository; //To inject\n    private UserService userService; //To inject\n    private RoleService roleService; //To inject\n\n    private Logger log = LoggerFactory.getLogger(SpringJpaBootstrap.class);\n\n...\n\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n        loadProducts();\n        loadUsers();\n        loadRoles();\n        assignUsersToUserRole();\n        assignUsersToAdminRole();\n    }\n\n    private void loadProducts() {\n        Product shirt = new Product();\n        shirt.setDescription(\" Chemise Lacouste\");\n        shirt.setPrice(18.95f);\n        shirt.setImageUrl(\"https://www.vision-naire.com/wp-content/uploads/2016/11/T-SHIRT-V-150x150.jpg\");\n        shirt.setProductId(\"235268845711068308\");\n        productRepository.save(shirt);\n\n        log.info(\"Saved Shirt - id: \" + shirt.getId());\n\n        Product pant = new Product();\n        pant.setDescription(\"Pantalon Hugo Boot\");\n        pant.setPrice(120.9f);\n        pant.setImageUrl(\"https://www.vision-naire.com/wp-content/uploads/2020/06/jogging-visionnaire-2-100x100.jpg\");\n        pant.setProductId(\"168639393495335947\");\n        productRepository.save(pant);\n\n        log.info(\"Saved Mug - id:\" + pant.getId());\n    }\n\n    private void loadUsers() {\n        User user1 = new User();\n        user1.setUsername(\"user\");\n        user1.setPassword(\"user\");\n        userService.saveOrUpdate(user1);\n\n        User user2 = new User();\n        user2.setUsername(\"admin\");\n        user2.setPassword(\"admin\");\n        userService.saveOrUpdate(user2);\n\n    }\n\n    private void loadRoles() {\n        Role role = ...\n                // Cr\u00e9er et enregistrer les r\u00f4les \"ADMIN\" et \"USER\"\n    }\n    private void assignUsersToUserRole() {\n        List&lt;Role&gt; roles = ...\n        List&lt;User&gt; users = ...\n\n        roles.forEach(role -&gt; {\n            if (role.getRole().equalsIgnoreCase(\"USER\")) {\n                            ...\n                            //assigner le r\u00f4le \u00e0 l'utilisateur \"user\"\n\n            }\n        });\n    }\n    private void assignUsersToAdminRole() {\n        List&lt;Role&gt; roles = ...\n        List&lt;User&gt; users = ...\n\n        roles.forEach(role -&gt; {\n            if (role.getRole().equalsIgnoreCase(\"ADMIN\")) {\n                            ...\n                            //assigner le r\u00f4le \u00e0 l'utilisateur \"admin\"\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"springboot/TP1/#thymleaf-security","title":"Thymleaf Security","text":"<ul> <li> <p>Actuellement, USER et ROLE sont r\u00e9f\u00e9renc\u00e9s \u00e0 partir du code de couche de pr\u00e9sentation comme ROLE_USER et ROLE_ADMIN. Cela \u00e9tait n\u00e9cessaire car nous nous appuyions sur le fournisseur d'authentification en m\u00e9moire de Spring Security pour g\u00e9rer nos utilisateurs et nos r\u00f4les, et la fonctionnalit\u00e9 interne de Spring Security mappe un r\u00f4le configur\u00e9 au nom de r\u00f4le pr\u00e9c\u00e9d\u00e9 de ROLE_.</p> </li> <li> <p>Avec le fournisseur d'authentification DAO, nos r\u00f4les sont mapp\u00e9s aux autorit\u00e9s telles quelles (nous l'avons fait dans le convertisseur <code>UserToUserDetails</code>), et nous pouvons les r\u00e9f\u00e9rer directement \u00e0 partir du code en tant que USER et ADMIN.</p> </li> <li> <p>Le deuxi\u00e8me changement est apport\u00e9 par GrantedAuthority utilis\u00e9 par l'interface Spring Security <code>UserDetails</code>. Si vous vous en souvenez, nous avons mapp\u00e9 notre impl\u00e9mentation de r\u00f4le \u00e0 <code>SimpleGrantedAuthority</code> dans le convertisseur <code>UserToUserDetails</code>.</p> </li> <li> <p>Par cons\u00e9quent, dans les mod\u00e8les Thymeleaf, nous devons changer les expressions d'autorisation hasRole () et hasAnyRole () en hasAuthority () et hasAnyAuthority ()</p> </li> <li> <p>Changer les templates menu et produit</p> </li> </ul>"},{"location":"springboot/TP2/","title":"TP2","text":""},{"location":"springboot/TP2/#partie-1-exemple-personne","title":"Partie 1 Exemple Personne","text":"<ul> <li> <p>Cr\u00e9er un controller <code>ConsoleController</code> d\u00e9di\u00e9 \u00e0 la console associant l'adresse <code>/console</code> \u00e0 la redirection vers <code>h2-console</code></p> </li> <li> <p>Cr\u00e9er un controller <code>MainController</code> permettant de gerer les appels sur nos repository retournant les objets en JSON</p> </li> <li> <p>Voici les param\u00e8tres \u00e0 utiliser pour les deux prochaines m\u00e9thode: <code>@RequestParam(name = \"method\", required = true, defaultValue = \"id\") String method, @RequestParam(name = \"value\", required = true) String value</code> chaque m\u00e9thode devra avoir un switch prenant en entr\u00e9e <code>method</code></p> </li> <li>Associer l'adresse <code>/person</code> avec les m\u00e9thodes retournant qu'une valeur (dans le switch)</li> <li> <p>Associer l'adresse <code>/persons</code> avec les m\u00e9thodes retournant une liste (dans le switch)</p> </li> <li> <p>Acceder \u00e0 la console et cr\u00e9er une querry permettant d'afficher toutes les personnes commen\u00e7ant par <code>S</code></p> </li> <li> <p>Cr\u00e9er une nouvelle m\u00e9thode dans le <code>PersonRepository</code> <code>findNameStartingByS</code> et y mapper la query obtenue pr\u00e9c\u00e9demment sachant que dans le code ce n'est pas les tables et champs de la BDD qu'il faut utiliser mais ceux de l'<code>Entity</code></p> </li> <li> <p>Refaire la m\u00eame query en language naturel (uniquement en java)  Doc spring</p> </li> <li> <p>Cr\u00e9er deux autres query de type different de la premi\u00e8re</p> </li> </ul>"},{"location":"springboot/TP2/#partie-2-vraie-bdd","title":"Partie 2 Vraie BDD","text":"<ul> <li>Cr\u00e9er les <code>Entity</code> <code>Agent, Orders, Customer</code> suivant le sch\u00e9ma ci dessous et la d\u00e9claration des tables. Pour le moment considerer les cl\u00e9s \u00e9trang\u00e8res comme des champs simples. Elles seront utilis\u00e9es dans la partie 3. </li> </ul> <pre><code>CREATE TABLE  \"AGENTS\" \n   (    \n    \"AGENT_CODE\" CHAR(6) NOT NULL PRIMARY KEY, \n    \"AGENT_NAME\" CHAR(40), \n    \"WORKING_AREA\" CHAR(35), \n    \"COMMISSION\" NUMBER(10,2), \n    \"PHONE_NO\" CHAR(15), \n    \"COUNTRY\" VARCHAR2(25) \n     );\n\n\nCREATE TABLE  \"CUSTOMER\" \n   (    \n    \"CUST_CODE\" VARCHAR2(6) NOT NULL PRIMARY KEY, \n    \"CUST_NAME\" VARCHAR2(40) NOT NULL, \n    \"CUST_CITY\" CHAR(35), \n    \"WORKING_AREA\" VARCHAR2(35) NOT NULL, \n    \"CUST_COUNTRY\" VARCHAR2(20) NOT NULL, \n    \"GRADE\" NUMBER, \n    \"OPENING_AMT\" NUMBER(12,2) NOT NULL, \n    \"RECEIVE_AMT\" NUMBER(12,2) NOT NULL, \n    \"PAYMENT_AMT\" NUMBER(12,2) NOT NULL, \n    \"OUTSTANDING_AMT\" NUMBER(12,2) NOT NULL, \n    \"PHONE_NO\" VARCHAR2(17) NOT NULL, \n    \"AGENT_CODE\" CHAR(6) NOT NULL REFERENCES AGENTS\n); \n\nCREATE TABLE  \"ORDERS\" \n   (\n    \"ORD_NUM\" NUMBER(6,0) NOT NULL PRIMARY KEY, \n    \"ORD_AMOUNT\" NUMBER(12,2) NOT NULL, \n    \"ADVANCE_AMOUNT\" NUMBER(12,2) NOT NULL, \n    \"ORD_DATE\" DATE NOT NULL, \n    \"CUST_CODE\" VARCHAR2(6) NOT NULL REFERENCES CUSTOMER, \n    \"AGENT_CODE\" CHAR(6) NOT NULL REFERENCES AGENTS, \n    \"ORD_DESCRIPTION\" VARCHAR2(60) NOT NULL\n   );\n</code></pre> <ul> <li> <p>Charger les donn\u00e9es de d\u00e9pot Github dataTP2 soit manuellement soit automatiquement.</p> </li> <li> <p>Cr\u00e9er les repository associ\u00e9s et ajouter des m\u00e9thodes pour:</p> </li> </ul> <p>-- Trouver des agents par nom, trouver des agents \u00e0 la commission plus grande que la valeur en param\u00e8tre, trouver des agents par Working Area</p> <p>-- Trouver des customers par nom, Trouver des customers par ville et Trouver des customers par <code>openingAtm</code> plus grand que le param\u00e8tre</p> <p>-- Trouver des orders par agent code et Trouver des orders par orderAmount plus grand que le param\u00e8tre</p> <ul> <li> <p>Cr\u00e9er des requ\u00e8tes de jointure pour chaque order r\u00e9cup\u00e9rer les valeurs associ\u00e9es d'agent et customer </p> </li> <li> <p>Dans le controller y ajouter les m\u00e9thodes de la m\u00eame fa\u00e7on que pour les personnes et y binder toutes les m\u00e9thodes.</p> </li> </ul>"},{"location":"springboot/TP2/#partie-3-optimisations","title":"Partie 3 Optimisations","text":"<ul> <li> <p>remplacer pour les cl\u00e9s externes l'annotation <code>@column</code> par <code>@ManyToOne     @JoinColumn(      name=\"nom de la colonne\", unique=false, nullable=false, updatable=true)</code> et remplacer le type du champ par l'objet voulu.</p> </li> <li> <p>Afficher la liste des orders. Que constatez vous? Ecrire la r\u00e9ponse en commentaire apr\u00e8s la ligne</p> </li> </ul> <pre><code>public class ExoBddDaoApplication {\n</code></pre>"},{"location":"springboot/TP2/#fin","title":"Fin","text":"<p>Supprimer le dossier target, zipper le projet de me l'envoyer pr mail. V\u00e9rifier l'envoi du mail (pas de mail de retour \u00e0 cause de la pi\u00e8ce jointe)</p>"},{"location":"springboot/about/","title":"Liens utiles","text":""},{"location":"springboot/about/#jpa","title":"JPA","text":"<p>JPA1</p> <p>Doc spring</p>"},{"location":"springboot/about/#configuration-properties","title":"Configuration properties","text":"<p>Conf1</p> <p>Conf2</p> <p>Conf3</p>"},{"location":"springboot/about/#autres","title":"Autres","text":"<p>Connexion sociale avec OAuth2</p> <p>IHM web auto completion</p> <p>Vid\u00e9o auto configuration</p>"}]}